[
    {
        "task_id": "ClassEval_0",
        "skeleton": "import logging\nimport datetime\n\nclass AccessGatewayFilter:\n    \"\"\"\n    This class is a filter used for accessing gateway filtering, primarily for authentication and access log recording.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def filter(self, request):\n        \"\"\"\n        Filter the incoming request based on certain rules and conditions.\n        :param request: dict, the incoming request details\n        :return: bool, True if the request is allowed, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.filter({'path': '/login', 'method': 'POST'})\n        True\n\n        \"\"\"\n\n\n    def is_start_with(self, request_uri):\n        \"\"\"\n        Check if the request URI starts with certain prefixes.\n        :param request_uri: str, the URI of the request\n        :return: bool, True if the URI starts with certain prefixes, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.is_start_with('/api/data')\n        True\n\n        \"\"\"\n\n\n    def get_jwt_user(self, request):\n        \"\"\"\n        Get the user information from the JWT token in the request.\n        :param request: dict, the incoming request details\n        :return: dict or None, the user information if the token is valid, None otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.get_jwt_user({'headers': {'Authorization': {'user': {'name': 'user1'}, 'jwt': 'user1'+str(datetime.date.today())}}})\n        {'user': {'name': 'user1'}\n\n        \"\"\"\n\n    def set_current_user_info_and_log(self, user):\n        \"\"\"\n        Set the current user information and log the access.\n        :param user: dict, the user information\n        :return: None\n        >>> filter = AccessGatewayFilter()\n        >>> user = {'name': 'user1', 'address': '127.0.0.1'}\n        >>> filter.set_current_user_info_and_log(user)\n\n        \"\"\"",
        "test": "import unittest\n\nclass AccessGatewayFilterTestFilter(unittest.TestCase):\n    def test_filter_1(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/api/data', 'method': 'GET'}\n        res = agf.filter(request)\n        self.assertTrue(res)\n\n    def test_filter_2(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/api/data', 'method': 'POST'}\n        res = agf.filter(request)\n        self.assertTrue(res)\n\n    def test_filter_3(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/login/data', 'method': 'GET'}\n        res = agf.filter(request)\n        self.assertTrue(res)\n\n    def test_filter_4(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/login/data', 'method': 'POST'}\n        res = agf.filter(request)\n        self.assertTrue(res)\n\n    def test_filter_5(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/abc', 'method': 'POST',\n                   'headers': {\n                       'Authorization': {'user': {'name': 'user1', 'level': 5, 'address': 'address1'},\n                                         'jwt': 'user1' + str(datetime.date.today())}}}\n        res = agf.filter(request)\n        self.assertTrue(res)\n\n    def test_filter_6(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/abc', 'method': 'POST',\n                   'headers': {\n                       'Authorization': {'user': {'name': 'user1', 'level': 3, 'address': 'address1'},\n                                         'jwt': 'user1' + str(datetime.date.today() - datetime.timedelta(days=365))}}}\n        res = agf.filter(request)\n        self.assertFalse(res)\n\n    def test_filter_7(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/abc', 'method': 'POST',\n                   'headers': {\n                       'Authorization': {'user': {'name': 'user1', 'level': 1, 'address': 'address1'},\n                                         'jwt': 'user1' + str(datetime.date.today())}}}\n        res = agf.filter(request)\n        self.assertIsNone(res)\n\n    def test_filter_8(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/abc', 'method': 'POST',\n                   'headers': {\n                       'Authorization': {'user': {'name': 'user1', 'level': 3, 'address': 'address1'},\n                                         'jwt': 'user2' + str(datetime.date.today() - datetime.timedelta(days=365))}}}\n        res = agf.filter(request)\n        self.assertTrue(res)\n\n\nclass AccessGatewayFilterTestIsStartWith(unittest.TestCase):\n    def test_is_start_with_1(self):\n        agf = AccessGatewayFilter()\n        request_uri = '/api/data'\n        res = agf.is_start_with(request_uri)\n        self.assertTrue(res)\n\n    def test_is_start_with_2(self):\n        agf = AccessGatewayFilter()\n        request_uri = '/admin/settings'\n        res = agf.is_start_with(request_uri)\n        self.assertFalse(res)\n\n    def test_is_start_with_3(self):\n        agf = AccessGatewayFilter()\n        request_uri = '/login/data'\n        res = agf.is_start_with(request_uri)\n        self.assertTrue(res)\n\n    def test_is_start_with_4(self):\n        agf = AccessGatewayFilter()\n        request_uri = '/abc/data'\n        res = agf.is_start_with(request_uri)\n        self.assertFalse(res)\n\n    def test_is_start_with_5(self):\n        agf = AccessGatewayFilter()\n        request_uri = '/def/data'\n        res = agf.is_start_with(request_uri)\n        self.assertFalse(res)\n\n\nclass AccessGatewayFilterTestGetJwtUser(unittest.TestCase):\n    def test_get_jwt_user_1(self):\n        agf = AccessGatewayFilter()\n        request = {\n            'headers': {'Authorization': {'user': {'name': 'user1'}, 'jwt': 'user1' + str(datetime.date.today())}}}\n        res = agf.get_jwt_user(request)\n        self.assertIsNotNone(res)\n\n    def test_get_jwt_user_2(self):\n        agf = AccessGatewayFilter()\n        request = {\n            'headers': {'Authorization': {'user': {'name': 'user2'}, 'jwt': 'user2' + str(datetime.date.today())}}}\n        res = agf.get_jwt_user(request)\n        self.assertIsNotNone(res)\n\n    def test_get_jwt_user_3(self):\n        agf = AccessGatewayFilter()\n        request = {\n            'headers': {'Authorization': {'user': {'name': 'user3'}, 'jwt': 'user3' + str(datetime.date.today())}}}\n        res = agf.get_jwt_user(request)\n        self.assertIsNotNone(res)\n\n    def test_get_jwt_user_4(self):\n        agf = AccessGatewayFilter()\n        request = {\n            'headers': {'Authorization': {'user': {'name': 'user4'}, 'jwt': 'user4' + str(datetime.date.today())}}}\n        res = agf.get_jwt_user(request)\n        self.assertIsNotNone(res)\n\n    def test_get_jwt_user_5(self):\n        agf = AccessGatewayFilter()\n        request = {'headers': {'Authorization': {'user': {'name': 'user1'}, 'jwt': 'user1' + str(\n            datetime.date.today() - datetime.timedelta(days=5))}}}\n        res = agf.get_jwt_user(request)\n        self.assertIsNone(res)\n\n\nclass AccessGatewayFilterTest(unittest.TestCase):\n    def test_AccessGatewayFilter(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/api/data', 'method': 'GET'}\n        res = agf.filter(request)\n        self.assertTrue(res)\n\n        request_uri = '/api/data'\n        res = agf.is_start_with(request_uri)\n        self.assertTrue(res)\n\n        request = {\n            'headers': {'Authorization': {'user': {'name': 'user1'}, 'jwt': 'user1' + str(datetime.date.today())}}}\n        res = agf.get_jwt_user(request)\n        self.assertIsNotNone(res)",
        "solution_code": "import logging\nimport datetime\n\n\nclass AccessGatewayFilter:\n\n    def __init__(self):\n        pass\n\n    def filter(self, request):\n        request_uri = request['path']\n        method = request['method']\n\n        if self.is_start_with(request_uri):\n            return True\n\n        try:\n            token = self.get_jwt_user(request)\n            user = token['user']\n            if user['level'] > 2:\n                self.set_current_user_info_and_log(user)\n                return True\n        except:\n            return False\n\n    def is_start_with(self, request_uri):\n        start_with = [\"/api\", '/login']\n        for s in start_with:\n            if request_uri.startswith(s):\n                return True\n        return False\n\n    def get_jwt_user(self, request):\n        token = request['headers']['Authorization']\n        user = token['user']\n        if token['jwt'].startswith(user['name']):\n            jwt_str_date = token['jwt'].split(user['name'])[1]\n            jwt_date = datetime.datetime.strptime(jwt_str_date, \"%Y-%m-%d\")\n            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):\n                return None\n        return token\n\n    def set_current_user_info_and_log(self, user):\n        host = user['address']\n        logging.log(msg=user['name'] + host + str(datetime.datetime.now()), level=1)",
        "import_statement": [
            "import logging",
            "import datetime"
        ],
        "class_description": "    \"\"\"\n    This class is a filter used for accessing gateway filtering, primarily for authentication and access log recording.\n    \"\"\"\n",
        "class_name": "AccessGatewayFilter",
        "test_classes": [
            "AccessGatewayFilterTestFilter",
            "AccessGatewayFilterTestIsStartWith",
            "AccessGatewayFilterTestGetJwtUser",
            "AccessGatewayFilterTest"
        ],
        "class_constructor": "class AccessGatewayFilter: \n    def __init__(self):\n        pass\n\n",
        "fields": [],
        "methods_info": [
            {
                "method_name": "filter",
                "method_description": "def filter(self, request):\n        \"\"\"\n        Filter the incoming request based on certain rules and conditions.\n        :param request: dict, the incoming request details\n        :return: bool, True if the request is allowed, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.filter({'path': '/login', 'method': 'POST'})\n        True\n\n        \"\"\"",
                "test_class": "AccessGatewayFilterTestFilter",
                "test_code": "class AccessGatewayFilterTestFilter(unittest.TestCase):\n    def test_filter_1(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/api/data', 'method': 'GET'}\n        res = agf.filter(request)\n        self.assertTrue(res)\n\n    def test_filter_2(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/api/data', 'method': 'POST'}\n        res = agf.filter(request)\n        self.assertTrue(res)\n\n    def test_filter_3(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/login/data', 'method': 'GET'}\n        res = agf.filter(request)\n        self.assertTrue(res)\n\n    def test_filter_4(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/login/data', 'method': 'POST'}\n        res = agf.filter(request)\n        self.assertTrue(res)\n\n    def test_filter_5(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/abc', 'method': 'POST',\n                   'headers': {\n                       'Authorization': {'user': {'name': 'user1', 'level': 5, 'address': 'address1'},\n                                         'jwt': 'user1' + str(datetime.date.today())}}}\n        res = agf.filter(request)\n        self.assertTrue(res)\n\n    def test_filter_6(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/abc', 'method': 'POST',\n                   'headers': {\n                       'Authorization': {'user': {'name': 'user1', 'level': 3, 'address': 'address1'},\n                                         'jwt': 'user1' + str(datetime.date.today() - datetime.timedelta(days=365))}}}\n        res = agf.filter(request)\n        self.assertFalse(res)\n\n    def test_filter_7(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/abc', 'method': 'POST',\n                   'headers': {\n                       'Authorization': {'user': {'name': 'user1', 'level': 1, 'address': 'address1'},\n                                         'jwt': 'user1' + str(datetime.date.today())}}}\n        res = agf.filter(request)\n        self.assertIsNone(res)\n\n    def test_filter_8(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/abc', 'method': 'POST',\n                   'headers': {\n                       'Authorization': {'user': {'name': 'user1', 'level': 3, 'address': 'address1'},\n                                         'jwt': 'user2' + str(datetime.date.today() - datetime.timedelta(days=365))}}}\n        res = agf.filter(request)\n        self.assertTrue(res)",
                "solution_code": "def filter(self, request):\n        request_uri = request['path']\n        method = request['method']\n\n        if self.is_start_with(request_uri):\n            return True\n\n        try:\n            token = self.get_jwt_user(request)\n            user = token['user']\n            if user['level'] > 2:\n                self.set_current_user_info_and_log(user)\n                return True\n        except:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "is_start_with",
                        "get_jwt_user",
                        "set_current_user_info_and_log"
                    ]
                }
            },
            {
                "method_name": "is_start_with",
                "method_description": "def is_start_with(self, request_uri):\n        \"\"\"\n        Check if the request URI starts with certain prefixes.\n        :param request_uri: str, the URI of the request\n        :return: bool, True if the URI starts with certain prefixes, False otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.is_start_with('/api/data')\n        True\n\n        \"\"\"",
                "test_class": "AccessGatewayFilterTestIsStartWith",
                "test_code": "class AccessGatewayFilterTestIsStartWith(unittest.TestCase):\n    def test_is_start_with_1(self):\n        agf = AccessGatewayFilter()\n        request_uri = '/api/data'\n        res = agf.is_start_with(request_uri)\n        self.assertTrue(res)\n\n    def test_is_start_with_2(self):\n        agf = AccessGatewayFilter()\n        request_uri = '/admin/settings'\n        res = agf.is_start_with(request_uri)\n        self.assertFalse(res)\n\n    def test_is_start_with_3(self):\n        agf = AccessGatewayFilter()\n        request_uri = '/login/data'\n        res = agf.is_start_with(request_uri)\n        self.assertTrue(res)\n\n    def test_is_start_with_4(self):\n        agf = AccessGatewayFilter()\n        request_uri = '/abc/data'\n        res = agf.is_start_with(request_uri)\n        self.assertFalse(res)\n\n    def test_is_start_with_5(self):\n        agf = AccessGatewayFilter()\n        request_uri = '/def/data'\n        res = agf.is_start_with(request_uri)\n        self.assertFalse(res)",
                "solution_code": "def is_start_with(self, request_uri):\n        start_with = [\"/api\", '/login']\n        for s in start_with:\n            if request_uri.startswith(s):\n                return True\n        return False",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "get_jwt_user",
                "method_description": "def get_jwt_user(self, request):\n        \"\"\"\n        Get the user information from the JWT token in the request.\n        :param request: dict, the incoming request details\n        :return: dict or None, the user information if the token is valid, None otherwise\n        >>> filter = AccessGatewayFilter()\n        >>> filter.get_jwt_user({'headers': {'Authorization': {'user': {'name': 'user1'}, 'jwt': 'user1'+str(datetime.date.today())}}})\n        {'user': {'name': 'user1'}\n\n        \"\"\"",
                "test_class": "AccessGatewayFilterTestGetJwtUser",
                "test_code": "class AccessGatewayFilterTestGetJwtUser(unittest.TestCase):\n    def test_get_jwt_user_1(self):\n        agf = AccessGatewayFilter()\n        request = {\n            'headers': {'Authorization': {'user': {'name': 'user1'}, 'jwt': 'user1' + str(datetime.date.today())}}}\n        res = agf.get_jwt_user(request)\n        self.assertIsNotNone(res)\n\n    def test_get_jwt_user_2(self):\n        agf = AccessGatewayFilter()\n        request = {\n            'headers': {'Authorization': {'user': {'name': 'user2'}, 'jwt': 'user2' + str(datetime.date.today())}}}\n        res = agf.get_jwt_user(request)\n        self.assertIsNotNone(res)\n\n    def test_get_jwt_user_3(self):\n        agf = AccessGatewayFilter()\n        request = {\n            'headers': {'Authorization': {'user': {'name': 'user3'}, 'jwt': 'user3' + str(datetime.date.today())}}}\n        res = agf.get_jwt_user(request)\n        self.assertIsNotNone(res)\n\n    def test_get_jwt_user_4(self):\n        agf = AccessGatewayFilter()\n        request = {\n            'headers': {'Authorization': {'user': {'name': 'user4'}, 'jwt': 'user4' + str(datetime.date.today())}}}\n        res = agf.get_jwt_user(request)\n        self.assertIsNotNone(res)\n\n    def test_get_jwt_user_5(self):\n        agf = AccessGatewayFilter()\n        request = {'headers': {'Authorization': {'user': {'name': 'user1'}, 'jwt': 'user1' + str(\n            datetime.date.today() - datetime.timedelta(days=5))}}}\n        res = agf.get_jwt_user(request)\n        self.assertIsNone(res)",
                "solution_code": "def get_jwt_user(self, request):\n        token = request['headers']['Authorization']\n        user = token['user']\n        if token['jwt'].startswith(user['name']):\n            jwt_str_date = token['jwt'].split(user['name'])[1]\n            jwt_date = datetime.datetime.strptime(jwt_str_date, \"%Y-%m-%d\")\n            if datetime.datetime.today() - jwt_date >= datetime.timedelta(days=3):\n                return None\n        return token",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "set_current_user_info_and_log",
                "method_description": "def set_current_user_info_and_log(self, user):\n        \"\"\"\n        Set the current user information and log the access.\n        :param user: dict, the user information\n        :return: None\n        >>> filter = AccessGatewayFilter()\n        >>> user = {'name': 'user1', 'address': '127.0.0.1'}\n        >>> filter.set_current_user_info_and_log(user)\n\n        \"\"\"",
                "test_class": "AccessGatewayFilterTest",
                "test_code": "class AccessGatewayFilterTest(unittest.TestCase):\n    def test_AccessGatewayFilter(self):\n        agf = AccessGatewayFilter()\n        request = {'path': '/api/data', 'method': 'GET'}\n        res = agf.filter(request)\n        self.assertTrue(res)\n\n        request_uri = '/api/data'\n        res = agf.is_start_with(request_uri)\n        self.assertTrue(res)\n\n        request = {\n            'headers': {'Authorization': {'user': {'name': 'user1'}, 'jwt': 'user1' + str(datetime.date.today())}}}\n        res = agf.get_jwt_user(request)\n        self.assertIsNotNone(res)",
                "solution_code": "def set_current_user_info_and_log(self, user):\n        host = user['address']\n        logging.log(msg=user['name'] + host + str(datetime.datetime.now()), level=1)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "logging",
                        "datetime"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_1",
        "skeleton": "import math\nclass AreaCalculator:\n    \"\"\"\n    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.\n    \"\"\"\n\n\n    def __init__(self, radius):\n        \"\"\"\n        Initialize the radius for shapes.\n        :param radius: float\n        \"\"\"\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        \"\"\"\n        calculate the area of circle based on self.radius\n        :return: area of circle, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_circle_area()\n        12.566370614359172\n        \"\"\"\n\n    def calculate_sphere_area(self):\n        \"\"\"\n        calculate the area of sphere based on self.radius\n        :return: area of sphere, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sphere_area()\n        50.26548245743669\n        \"\"\"\n\n    def calculate_cylinder_area(self, height):\n        \"\"\"\n        calculate the area of cylinder based on self.radius and height\n        :param height: height of cylinder, float\n        :return: area of cylinder, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_cylinder_area(3)\n        62.83185307179586\n        \"\"\"\n\n    def calculate_sector_area(self, angle):\n        \"\"\"\n        calculate the area of sector based on self.radius and angle\n        :param angle: angle of sector, float\n        :return: area of sector, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sector_area(math.pi)\n        6.283185307179586\n        \"\"\"\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        calculate the area of annulus based on inner_radius and out_radius\n        :param inner_radius: inner radius of sector, float\n        :param outer_radius: outer radius of sector, float\n        :return: area of annulus, float\n        >>> areaCalculator.calculate_annulus_area(2, 3)\n        15.707963267948966\n        \"\"\"",
        "test": "import unittest\n\nclass AreaCalculatorTestCalculateCircleArea(unittest.TestCase):\n    def test_calculate_circle_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(12.56, areaCalculator.calculate_circle_area(), delta=0.01)\n    def test_calculate_circle_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(19.63, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(12566370.61, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_5(self):\n        areaCalculator = AreaCalculator(0.1)\n        self.assertAlmostEqual(0.031, areaCalculator.calculate_circle_area(), delta=0.01)\n\n\nclass AreaCalculatorTestCalculateSphereArea(unittest.TestCase):\n    def test_calculate_sphere_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_sphere_area(), delta=0.01)\n\n    def test_calculate_sphere_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(19.63, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_sphere_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(12566370.61, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_sphere_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_sphere_area_5(self):\n        areaCalculator = AreaCalculator(0.1)\n        self.assertAlmostEqual(0.031, areaCalculator.calculate_circle_area(), delta=0.01)\n\n\nclass AreaCalculatorTestCalculateCylinderArea(unittest.TestCase):\n    def test_calculate_cylinder_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_cylinder_area(2), delta=0.01)\n\n    def test_calculate_cylinder_area_2(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_cylinder_area(0), delta=0.01)\n\n    def test_calculate_cylinder_area_3(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_cylinder_area(2000), delta=0.01)\n\n    def test_calculate_cylinder_area_4(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(70.68, areaCalculator.calculate_cylinder_area(2), delta=0.01)\n\n    def test_calculate_cylinder_area_5(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(62.83, areaCalculator.calculate_cylinder_area(1.5), delta=0.01)\n\nclass AreaCalculatorTestCalculateSectorArea(unittest.TestCase):\n    def test_calculate_sector_area(self):\n        areaCalculator = AreaCalculator(1.5)\n        self.assertAlmostEqual(3.53, areaCalculator.calculate_sector_area(math.pi), delta=0.01)\n\n    def test_calculate_sector_area_2(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(3.14, areaCalculator.calculate_sector_area(math.pi/2), delta=0.01)\n\n    def test_calculate_sector_area_3(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(0, areaCalculator.calculate_sector_area(0), delta=0.01)\n\n    def test_calculate_sector_area_4(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(12.56, areaCalculator.calculate_sector_area(2*math.pi), delta=0.01)\n\n    def test5_calculate_sector_area_5(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_sector_area(math.pi), delta=0.01)\n\nclass AreaCalculatorTestCalculateAnnulusArea(unittest.TestCase):\n    def test_calculate_annulus_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(25.128, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\n    def test_calculate_annulus_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(0, areaCalculator.calculate_annulus_area(3, 3), delta=0.01)\n\n    def test_calculate_annulus_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(3.14, areaCalculator.calculate_annulus_area(0, 1), delta=0.01)\n\n    def test_calculate_annulus_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\n    def test_calculate_annulus_area_5(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\nclass AreaCalculatorTestCalculateMain(unittest.TestCase):\n    def test_main(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(12.56, areaCalculator.calculate_circle_area(), delta=0.01)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_sphere_area(), delta=0.01)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_cylinder_area(2), delta=0.01)\n        self.assertAlmostEqual(6.28, areaCalculator.calculate_sector_area(math.pi), delta=0.01)\n        self.assertAlmostEqual(25.128, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)",
        "solution_code": "import math\n\n\nclass AreaCalculator:\n\n    def __init__(self, radius):\n        self.radius = radius\n\n    def calculate_circle_area(self):\n        return math.pi * self.radius ** 2\n\n    def calculate_sphere_area(self):\n        return 4 * math.pi * self.radius ** 2\n\n    def calculate_cylinder_area(self, height):\n        return 2 * math.pi * self.radius * (self.radius + height)\n\n    def calculate_sector_area(self, angle):\n        return self.radius ** 2 * angle / 2\n\n    def calculate_annulus_area(self, inner_radius, outer_radius):\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)",
        "import_statement": [
            "import math"
        ],
        "class_description": "    \"\"\"\n    This is a class for calculating the area of different shapes, including circle, sphere, cylinder, sector and annulus.\n    \"\"\"\n",
        "class_name": "AreaCalculator",
        "test_classes": [
            "AreaCalculatorTestCalculateCircleArea",
            "AreaCalculatorTestCalculateSphereArea",
            "AreaCalculatorTestCalculateCylinderArea",
            "AreaCalculatorTestCalculateSectorArea",
            "AreaCalculatorTestCalculateAnnulusArea",
            "AreaCalculatorTestCalculateMain"
        ],
        "class_constructor": "class AreaCalculator: \n    def __init__(self, radius):\n        \"\"\"\n        Initialize the radius for shapes.\n        :param radius: float\n        \"\"\"\n        self.radius = radius\n\n",
        "fields": [
            "self.radius"
        ],
        "methods_info": [
            {
                "method_name": "calculate_circle_area",
                "method_description": "def calculate_circle_area(self):\n        \"\"\"\n        calculate the area of circle based on self.radius\n        :return: area of circle, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_circle_area()\n        12.566370614359172\n        \"\"\"",
                "test_class": "AreaCalculatorTestCalculateCircleArea",
                "test_code": "class AreaCalculatorTestCalculateCircleArea(unittest.TestCase):\n    def test_calculate_circle_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(12.56, areaCalculator.calculate_circle_area(), delta=0.01)\n    def test_calculate_circle_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(19.63, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(12566370.61, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_circle_area_5(self):\n        areaCalculator = AreaCalculator(0.1)\n        self.assertAlmostEqual(0.031, areaCalculator.calculate_circle_area(), delta=0.01)",
                "solution_code": "def calculate_circle_area(self):\n        return math.pi * self.radius ** 2",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "math"
                    ],
                    "field_dependencies": [
                        "self.radius"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "calculate_sphere_area",
                "method_description": "def calculate_sphere_area(self):\n        \"\"\"\n        calculate the area of sphere based on self.radius\n        :return: area of sphere, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sphere_area()\n        50.26548245743669\n        \"\"\"",
                "test_class": "AreaCalculatorTestCalculateSphereArea",
                "test_code": "class AreaCalculatorTestCalculateSphereArea(unittest.TestCase):\n    def test_calculate_sphere_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_sphere_area(), delta=0.01)\n\n    def test_calculate_sphere_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(19.63, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_sphere_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(12566370.61, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_sphere_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_circle_area(), delta=0.01)\n\n    def test_calculate_sphere_area_5(self):\n        areaCalculator = AreaCalculator(0.1)\n        self.assertAlmostEqual(0.031, areaCalculator.calculate_circle_area(), delta=0.01)",
                "solution_code": "def calculate_sphere_area(self):\n        return 4 * math.pi * self.radius ** 2",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "math"
                    ],
                    "field_dependencies": [
                        "self.radius"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "calculate_cylinder_area",
                "method_description": "def calculate_cylinder_area(self, height):\n        \"\"\"\n        calculate the area of cylinder based on self.radius and height\n        :param height: height of cylinder, float\n        :return: area of cylinder, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_cylinder_area(3)\n        62.83185307179586\n        \"\"\"",
                "test_class": "AreaCalculatorTestCalculateCylinderArea",
                "test_code": "class AreaCalculatorTestCalculateCylinderArea(unittest.TestCase):\n    def test_calculate_cylinder_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(50.27, areaCalculator.calculate_cylinder_area(2), delta=0.01)\n\n    def test_calculate_cylinder_area_2(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_cylinder_area(0), delta=0.01)\n\n    def test_calculate_cylinder_area_3(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_cylinder_area(2000), delta=0.01)\n\n    def test_calculate_cylinder_area_4(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(70.68, areaCalculator.calculate_cylinder_area(2), delta=0.01)\n\n    def test_calculate_cylinder_area_5(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(62.83, areaCalculator.calculate_cylinder_area(1.5), delta=0.01)",
                "solution_code": "def calculate_cylinder_area(self, height):\n        return 2 * math.pi * self.radius * (self.radius + height)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "math"
                    ],
                    "field_dependencies": [
                        "self.radius"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "calculate_sector_area",
                "method_description": "def calculate_sector_area(self, angle):\n        \"\"\"\n        calculate the area of sector based on self.radius and angle\n        :param angle: angle of sector, float\n        :return: area of sector, float\n        >>> areaCalculator = AreaCalculator(2)\n        >>> areaCalculator.calculate_sector_area(math.pi)\n        6.283185307179586\n        \"\"\"",
                "test_class": "AreaCalculatorTestCalculateSectorArea",
                "test_code": "class AreaCalculatorTestCalculateSectorArea(unittest.TestCase):\n    def test_calculate_sector_area(self):\n        areaCalculator = AreaCalculator(1.5)\n        self.assertAlmostEqual(3.53, areaCalculator.calculate_sector_area(math.pi), delta=0.01)\n\n    def test_calculate_sector_area_2(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(3.14, areaCalculator.calculate_sector_area(math.pi/2), delta=0.01)\n\n    def test_calculate_sector_area_3(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(0, areaCalculator.calculate_sector_area(0), delta=0.01)\n\n    def test_calculate_sector_area_4(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(12.56, areaCalculator.calculate_sector_area(2*math.pi), delta=0.01)\n\n    def test5_calculate_sector_area_5(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(0, areaCalculator.calculate_sector_area(math.pi), delta=0.01)",
                "solution_code": "def calculate_sector_area(self, angle):\n        return self.radius ** 2 * angle / 2",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.radius"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "calculate_annulus_area",
                "method_description": "def calculate_annulus_area(self, inner_radius, outer_radius):\n        \"\"\"\n        calculate the area of annulus based on inner_radius and out_radius\n        :param inner_radius: inner radius of sector, float\n        :param outer_radius: outer radius of sector, float\n        :return: area of annulus, float\n        >>> areaCalculator.calculate_annulus_area(2, 3)\n        15.707963267948966\n        \"\"\"",
                "test_class": "AreaCalculatorTestCalculateAnnulusArea",
                "test_code": "class AreaCalculatorTestCalculateAnnulusArea(unittest.TestCase):\n    def test_calculate_annulus_area(self):\n        areaCalculator = AreaCalculator(2)\n        self.assertAlmostEqual(25.128, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\n    def test_calculate_annulus_area_2(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(0, areaCalculator.calculate_annulus_area(3, 3), delta=0.01)\n\n    def test_calculate_annulus_area_3(self):\n        areaCalculator = AreaCalculator(2000)\n        self.assertAlmostEqual(3.14, areaCalculator.calculate_annulus_area(0, 1), delta=0.01)\n\n    def test_calculate_annulus_area_4(self):\n        areaCalculator = AreaCalculator(0)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)\n\n    def test_calculate_annulus_area_5(self):\n        areaCalculator = AreaCalculator(2.5)\n        self.assertAlmostEqual(25.13, areaCalculator.calculate_annulus_area(1, 3), delta=0.01)",
                "solution_code": "def calculate_annulus_area(self, inner_radius, outer_radius):\n        return math.pi * (outer_radius ** 2 - inner_radius ** 2)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "math"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_3",
        "skeleton": "import itertools\n\nclass ArrangementCalculator:\n    \"\"\"\n    The Arrangement class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n\n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of datas.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: int, the count of arrangements.\n        >>> ArrangementCalculator.count(5, 3)\n        60\n\n        \"\"\"\n\n    @staticmethod\n    def count_all(n):\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        :param n: int, the total number of items.\n        :return: int, the count of all arrangements.\n        >>> ArrangementCalculator.count_all(4)\n        64\n\n        \"\"\"\n\n\n    def select(self, m=None):\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal datas.\n        If m is not provided, selects all items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: List, a list of arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3, 4])\n        >>> ac.select(2)\n        [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n\n        \"\"\"\n\n\n    def select_all(self):\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.\n        :return: List, a list of all arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3])\n        >>> ac.select_all()\n        [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n        \"\"\"\n\n\n    @staticmethod\n    def factorial(n):\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial.\n        :return: int, the factorial of the given number.\n        >>> ArrangementCalculator.factorial(4)\n        24\n\n        \"\"\"",
        "test": "import unittest\n\n\nclass ArrangementCalculatorTestCount(unittest.TestCase):\n    def test_count_1(self):\n        res = ArrangementCalculator.count(5, 3)\n        self.assertEqual(res, 60)\n\n    def test_count_2(self):\n        res = ArrangementCalculator.count(4, 3)\n        self.assertEqual(res, 24)\n\n    def test_count_3(self):\n        res = ArrangementCalculator.count(6, 3)\n        self.assertEqual(res, 120)\n\n    def test_count_4(self):\n        res = ArrangementCalculator.count(7, 3)\n        self.assertEqual(res, 210)\n\n    def test_count_5(self):\n        res = ArrangementCalculator.count(4, 4)\n        self.assertEqual(res, 24)\n\n\nclass ArrangementCalculatorTestCountAll(unittest.TestCase):\n    def test_count_all_1(self):\n        res = ArrangementCalculator.count_all(4)\n        self.assertEqual(res, 64)\n\n    def test_count_all_2(self):\n        res = ArrangementCalculator.count_all(1)\n        self.assertEqual(res, 1)\n\n    def test_count_all_3(self):\n        res = ArrangementCalculator.count_all(2)\n        self.assertEqual(res, 4)\n\n    def test_count_all_4(self):\n        res = ArrangementCalculator.count_all(3)\n        self.assertEqual(res, 15)\n\n    def test_count_all_5(self):\n        res = ArrangementCalculator.count_all(5)\n        self.assertEqual(res, 325)\n\n\nclass ArrangementCalculatorTestSelect(unittest.TestCase):\n    def test_select_1(self):\n        ac = ArrangementCalculator([1, 2, 3, 4])\n        res = ac.select(2)\n        expected = [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n        self.assertEqual(res, expected)\n\n    def test_select_2(self):\n        ac = ArrangementCalculator([1, 2, 3])\n        res = ac.select(2)\n        expected = [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]\n        self.assertEqual(res, expected)\n\n    def test_select_3(self):\n        ac = ArrangementCalculator([2, 3, 4])\n        res = ac.select(2)\n        expected = [[2, 3], [2, 4], [3, 2], [3, 4], [4, 2], [4, 3]]\n        self.assertEqual(res, expected)\n\n    def test_select_4(self):\n        ac = ArrangementCalculator([1, 2])\n        res = ac.select(2)\n        expected = [[1, 2], [2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_5(self):\n        ac = ArrangementCalculator([1, 2, 3, 4])\n        res = ac.select(1)\n        expected = [[1], [2], [3], [4]]\n        self.assertEqual(res, expected)\n\n    def test_select_6(self):\n        ac = ArrangementCalculator([1, 2])\n        res = ac.select()\n        expected = [[1, 2], [2, 1]]\n        self.assertEqual(res, expected)\n\n\nclass ArrangementCalculatorTestSelectAll(unittest.TestCase):\n    def test_select_all_1(self):\n        ac = ArrangementCalculator([1, 2, 3])\n        res = ac.select_all()\n        expected = [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3],\n                    [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_2(self):\n        ac = ArrangementCalculator([1, 2, 4])\n        res = ac.select_all()\n        expected = [[1], [2], [4], [1, 2], [1, 4], [2, 1], [2, 4], [4, 1], [4, 2], [1, 2, 4], [1, 4, 2], [2, 1, 4],\n                    [2, 4, 1], [4, 1, 2], [4, 2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_3(self):\n        ac = ArrangementCalculator([1, 2])\n        res = ac.select_all()\n        expected = [[1], [2], [1, 2], [2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_4(self):\n        ac = ArrangementCalculator([1, 3])\n        res = ac.select_all()\n        expected = [[1], [3], [1, 3], [3, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_5(self):\n        ac = ArrangementCalculator([1])\n        res = ac.select_all()\n        expected = [[1]]\n        self.assertEqual(res, expected)\n\n\nclass ArrangementCalculatorTestFactorial(unittest.TestCase):\n    def test_factorial_1(self):\n        res = ArrangementCalculator.factorial(4)\n        self.assertEqual(res, 24)\n\n    def test_factorial_2(self):\n        res = ArrangementCalculator.factorial(5)\n        self.assertEqual(res, 120)\n\n    def test_factorial_3(self):\n        res = ArrangementCalculator.factorial(3)\n        self.assertEqual(res, 6)\n\n    def test_factorial_4(self):\n        res = ArrangementCalculator.factorial(2)\n        self.assertEqual(res, 2)\n\n    def test_factorial_5(self):\n        res = ArrangementCalculator.factorial(1)\n        self.assertEqual(res, 1)\n\n\nclass ArrangementCalculatorTest(unittest.TestCase):\n    def test_arrangementcalculator(self):\n        res = ArrangementCalculator.count(5, 3)\n        self.assertEqual(res, 60)\n\n        res = ArrangementCalculator.count_all(4)\n        self.assertEqual(res, 64)\n\n        ac = ArrangementCalculator([1, 2, 3, 4])\n        res = ac.select(2)\n        expected = [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n        self.assertEqual(res, expected)\n\n        ac = ArrangementCalculator([1, 2, 3])\n        res = ac.select_all()\n        expected = [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3],\n                    [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n        self.assertEqual(res, expected)\n\n        res = ArrangementCalculator.factorial(4)\n        self.assertEqual(res, 24)",
        "solution_code": "import itertools\n\n\nclass ArrangementCalculator:\n    def __init__(self, datas):\n        self.datas = datas\n\n    @staticmethod\n    def count(n, m=None):\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)\n\n    @staticmethod\n    def count_all(n):\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        return total\n\n    def select(self, m=None):\n        if m is None:\n            m = len(self.datas)\n        result = []\n        for permutation in itertools.permutations(self.datas, m):\n            result.append(list(permutation))\n        return result\n\n    def select_all(self):\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n\n    @staticmethod\n    def factorial(n):\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result",
        "import_statement": [
            "import itertools"
        ],
        "class_description": "    \"\"\"\n    The Arrangement class provides permutation calculations and selection operations for a given set of data elements.\n    \"\"\"\n",
        "class_name": "ArrangementCalculator",
        "test_classes": [
            "ArrangementCalculatorTestCount",
            "ArrangementCalculatorTestCountAll",
            "ArrangementCalculatorTestSelect",
            "ArrangementCalculatorTestSelectAll",
            "ArrangementCalculatorTestFactorial",
            "ArrangementCalculatorTest"
        ],
        "class_constructor": "class ArrangementCalculator: \n    def __init__(self, datas):\n        \"\"\"\n        Initializes the ArrangementCalculator object with a list of datas.\n        :param datas: List, the data elements to be used for arrangements.\n        \"\"\"\n        self.datas = datas\n",
        "fields": [
            "self.datas"
        ],
        "methods_info": [
            {
                "method_name": "count",
                "method_description": "def count(n, m=None):\n        \"\"\"\n        Counts the number of arrangements by choosing m items from n items (permutations).\n        If m is not provided or n equals m, returns factorial(n).\n        :param n: int, the total number of items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: int, the count of arrangements.\n        >>> ArrangementCalculator.count(5, 3)\n        60\n\n        \"\"\"",
                "test_class": "ArrangementCalculatorTestCount",
                "test_code": "class ArrangementCalculatorTestCount(unittest.TestCase):\n    def test_count_1(self):\n        res = ArrangementCalculator.count(5, 3)\n        self.assertEqual(res, 60)\n\n    def test_count_2(self):\n        res = ArrangementCalculator.count(4, 3)\n        self.assertEqual(res, 24)\n\n    def test_count_3(self):\n        res = ArrangementCalculator.count(6, 3)\n        self.assertEqual(res, 120)\n\n    def test_count_4(self):\n        res = ArrangementCalculator.count(7, 3)\n        self.assertEqual(res, 210)\n\n    def test_count_5(self):\n        res = ArrangementCalculator.count(4, 4)\n        self.assertEqual(res, 24)",
                "solution_code": "def count(n, m=None):\n        if m is None or n == m:\n            return ArrangementCalculator.factorial(n)\n        else:\n            return ArrangementCalculator.factorial(n) // ArrangementCalculator.factorial(n - m)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "factorial"
                    ]
                }
            },
            {
                "method_name": "count_all",
                "method_description": "@staticmethod\n    def count_all(n):\n        \"\"\"\n        Counts the total number of all possible arrangements by choosing at least 1 item and at most n items from n items.\n        :param n: int, the total number of items.\n        :return: int, the count of all arrangements.\n        >>> ArrangementCalculator.count_all(4)\n        64\n\n        \"\"\"",
                "test_class": "ArrangementCalculatorTestCountAll",
                "test_code": "class ArrangementCalculatorTestCountAll(unittest.TestCase):\n    def test_count_all_1(self):\n        res = ArrangementCalculator.count_all(4)\n        self.assertEqual(res, 64)\n\n    def test_count_all_2(self):\n        res = ArrangementCalculator.count_all(1)\n        self.assertEqual(res, 1)\n\n    def test_count_all_3(self):\n        res = ArrangementCalculator.count_all(2)\n        self.assertEqual(res, 4)\n\n    def test_count_all_4(self):\n        res = ArrangementCalculator.count_all(3)\n        self.assertEqual(res, 15)\n\n    def test_count_all_5(self):\n        res = ArrangementCalculator.count_all(5)\n        self.assertEqual(res, 325)",
                "solution_code": "@staticmethod\n    def count_all(n):\n        total = 0\n        for i in range(1, n + 1):\n            total += ArrangementCalculator.count(n, i)\n        return total",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "count"
                    ]
                }
            },
            {
                "method_name": "select",
                "method_description": "def select(self, m=None):\n        \"\"\"\n        Generates a list of arrangements by selecting m items from the internal datas.\n        If m is not provided, selects all items.\n        :param m: int, the number of items to be chosen (default=None).\n        :return: List, a list of arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3, 4])\n        >>> ac.select(2)\n        [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n\n        \"\"\"",
                "test_class": "ArrangementCalculatorTestSelect",
                "test_code": "class ArrangementCalculatorTestSelect(unittest.TestCase):\n    def test_select_1(self):\n        ac = ArrangementCalculator([1, 2, 3, 4])\n        res = ac.select(2)\n        expected = [[1, 2], [1, 3], [1, 4], [2, 1], [2, 3], [2, 4], [3, 1], [3, 2], [3, 4], [4, 1], [4, 2], [4, 3]]\n        self.assertEqual(res, expected)\n\n    def test_select_2(self):\n        ac = ArrangementCalculator([1, 2, 3])\n        res = ac.select(2)\n        expected = [[1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2]]\n        self.assertEqual(res, expected)\n\n    def test_select_3(self):\n        ac = ArrangementCalculator([2, 3, 4])\n        res = ac.select(2)\n        expected = [[2, 3], [2, 4], [3, 2], [3, 4], [4, 2], [4, 3]]\n        self.assertEqual(res, expected)\n\n    def test_select_4(self):\n        ac = ArrangementCalculator([1, 2])\n        res = ac.select(2)\n        expected = [[1, 2], [2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_5(self):\n        ac = ArrangementCalculator([1, 2, 3, 4])\n        res = ac.select(1)\n        expected = [[1], [2], [3], [4]]\n        self.assertEqual(res, expected)\n\n    def test_select_6(self):\n        ac = ArrangementCalculator([1, 2])\n        res = ac.select()\n        expected = [[1, 2], [2, 1]]\n        self.assertEqual(res, expected)",
                "solution_code": "def select(self, m=None):\n        if m is None:\n            m = len(self.datas)\n        result = []\n        for permutation in itertools.permutations(self.datas, m):\n            result.append(list(permutation))\n        return result",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "itertools"
                    ],
                    "field_dependencies": [
                        "self.datas"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "select_all",
                "method_description": "def select_all(self):\n        \"\"\"\n        Generates a list of all arrangements by selecting at least 1 item and at most the number of internal datas.\n        :return: List, a list of all arrangements.\n        >>> ac = ArrangementCalculator([1, 2, 3])\n        >>> ac.select_all()\n        [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n        \"\"\"",
                "test_class": "ArrangementCalculatorTestSelectAll",
                "test_code": "class ArrangementCalculatorTestSelectAll(unittest.TestCase):\n    def test_select_all_1(self):\n        ac = ArrangementCalculator([1, 2, 3])\n        res = ac.select_all()\n        expected = [[1], [2], [3], [1, 2], [1, 3], [2, 1], [2, 3], [3, 1], [3, 2], [1, 2, 3], [1, 3, 2], [2, 1, 3],\n                    [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_2(self):\n        ac = ArrangementCalculator([1, 2, 4])\n        res = ac.select_all()\n        expected = [[1], [2], [4], [1, 2], [1, 4], [2, 1], [2, 4], [4, 1], [4, 2], [1, 2, 4], [1, 4, 2], [2, 1, 4],\n                    [2, 4, 1], [4, 1, 2], [4, 2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_3(self):\n        ac = ArrangementCalculator([1, 2])\n        res = ac.select_all()\n        expected = [[1], [2], [1, 2], [2, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_4(self):\n        ac = ArrangementCalculator([1, 3])\n        res = ac.select_all()\n        expected = [[1], [3], [1, 3], [3, 1]]\n        self.assertEqual(res, expected)\n\n    def test_select_all_5(self):\n        ac = ArrangementCalculator([1])\n        res = ac.select_all()\n        expected = [[1]]\n        self.assertEqual(res, expected)",
                "solution_code": "def select_all(self):\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.datas"
                    ],
                    "method_dependencies": [
                        "select"
                    ]
                }
            },
            {
                "method_name": "factorial",
                "method_description": "@staticmethod\n    def factorial(n):\n        \"\"\"\n        Calculates the factorial of a given number.\n        :param n: int, the number to calculate the factorial.\n        :return: int, the factorial of the given number.\n        >>> ArrangementCalculator.factorial(4)\n        24\n\n        \"\"\"",
                "test_class": "ArrangementCalculatorTestFactorial",
                "test_code": "class ArrangementCalculatorTestFactorial(unittest.TestCase):\n    def test_factorial_1(self):\n        res = ArrangementCalculator.factorial(4)\n        self.assertEqual(res, 24)\n\n    def test_factorial_2(self):\n        res = ArrangementCalculator.factorial(5)\n        self.assertEqual(res, 120)\n\n    def test_factorial_3(self):\n        res = ArrangementCalculator.factorial(3)\n        self.assertEqual(res, 6)\n\n    def test_factorial_4(self):\n        res = ArrangementCalculator.factorial(2)\n        self.assertEqual(res, 2)\n\n    def test_factorial_5(self):\n        res = ArrangementCalculator.factorial(1)\n        self.assertEqual(res, 1)",
                "solution_code": "@staticmethod\n    def factorial(n):\n        result = 1\n        for i in range(2, n + 1):\n            result *= i\n        return result",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_12",
        "skeleton": "import random\nclass BlackjackGame:\n    \"\"\"\n    This is a class representing a game of blackjack, which includes creating a deck, calculating the value of a hand, and determine the winner based on the hand values of the player and dealer.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand.\n        While initializing deck attribute, call the create_deck method to generate.\n        The deck stores 52 rondom order poker with the Jokers removed, format is ['AS', '2S', ...].\n        player_hand is a list which stores player's hand cards.\n        dealer_hand is is a list which stores dealer's hand cards.\n        \"\"\"\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        \"\"\"\n        Create a deck of 52 cards, which stores 52 rondom order poker with the Jokers removed.\n        :return: a list of 52 rondom order poker with the Jokers removed, format is ['AS', '2S', ...].\n        >>> black_jack_game = BlackjackGame()\n        >>> black_jack_game.create_deck()\n        ['QD', '9D', 'JC', 'QH', '2S', 'JH', '7D', '6H', '9S', '5C', '7H', 'QS', '5H',\n        '6C', '7C', '3D', '10C', 'AD', '4C', '5D', 'AH', '2D', 'QC', 'KH', '9C', '9H',\n        '4H', 'JS', '6S', '8H', '8C', '4S', '3H', '10H', '7S', '6D', '3C', 'KC', '3S',\n        '2H', '10D', 'KS', '4D', 'AC', '10S', '2C', 'KD', '5S', 'JD', '8S', 'AS', '8D']\n        \"\"\"\n\n    def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculate the value of the poker cards stored in hand list according to the rules of the Blackjack Game.\n        If the card is a digit, its value is added to the total hand value.\n        Value of J, Q, or K is 10, while Aces are worth 11.\n        If the total hand value exceeds 21 and there are Aces present, one Ace is treated as having a value of 1 instead of 11,\n        until the hand value is less than or equal to 21, or all Aces have been counted as value of 1.\n        :param hand: list\n        :return: the value of the poker cards stored in hand list, a number.\n        >>> black_jack_game.calculate_hand_value(['QD', '9D', 'JC', 'QH', 'AS'])\n        40\n        \"\"\"\n\n    def check_winner(self, player_hand, dealer_hand):\n        \"\"\"\n        Determines the winner of a game by comparing the hand values of the player and dealer.\n        rule:\n        If both players have hand values that are equal to or less than 21, the winner is the one whose hand value is closer to 21.\n        Otherwise, the winner is the one with the lower hand value.\n        :param player_hand: list\n        :param dealer_hand: list\n        :return: the result of the game, only two certain str: 'Dealer wins' or 'Player wins'\n        >>> black_jack_game.check_winner(['QD', '9D', 'JC', 'QH', 'AS'], ['QD', '9D', 'JC', 'QH', '2S'])\n        'Player wins'\n        \"\"\"",
        "test": "import unittest\n\nclass BlackjackGameTestCreateDeck(unittest.TestCase):\n    def setUp(self):\n        self.blackjackGame = BlackjackGame()\n        self.deck = self.blackjackGame.deck\n\n    def test_create_deck_1(self):\n        self.assertEqual(len(self.deck), 52)\n\n    def test_create_deck_2(self):\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        for suit in suits:\n            for rank in ranks:\n                self.assertIn(rank + suit, self.deck)\n\n    def test_create_deck_3(self):\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9']\n        for suit in suits:\n            for rank in ranks:\n                self.assertIn(rank + suit, self.deck)\n\n    def test_create_deck_4(self):\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['10', 'J', 'Q', 'K']\n        for suit in suits:\n            for rank in ranks:\n                self.assertIn(rank + suit, self.deck)\n\n    def test_create_deck_5(self):\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9']\n        for suit in suits:\n            for rank in ranks:\n                self.assertIn(rank + suit, self.deck)\n\nclass BlackjackGameTestCalculateHandValue(unittest.TestCase):\n    def test_calculate_hand_value_1(self):\n        blackjackGame = BlackjackGame()\n        hand = ['2S', '3S', '4S', '5S']\n        self.assertEqual(blackjackGame.calculate_hand_value(hand), 14)\n\n    def test_calculate_hand_value_2(self):\n        blackjackGame = BlackjackGame()\n        hand = ['2S', '3S', 'JS', 'QS']\n        self.assertEqual(blackjackGame.calculate_hand_value(hand), 25)\n\n    def test_calculate_hand_value_3(self):\n        blackjackGame = BlackjackGame()\n        hand = ['2S', '3S', '4S', 'AS']\n        self.assertEqual(blackjackGame.calculate_hand_value(hand), 20)\n\n    def test_calculate_hand_value_4(self):\n        blackjackGame = BlackjackGame()\n        hand = ['JS', 'QS', '4S', 'AS']\n        self.assertEqual(blackjackGame.calculate_hand_value(hand), 25)\n\n    def test_calculate_hand_value_5(self):\n        blackjackGame = BlackjackGame()\n        hand = ['JS', 'QS', 'AS', 'AS', 'AS']\n        self.assertEqual(blackjackGame.calculate_hand_value(hand), 23)\n\n    def test_calculate_hand_value_6(self):\n        blackjackGame = BlackjackGame()\n        hand = ['JS', 'QS', 'BS', 'CS']\n        self.assertEqual(blackjackGame.calculate_hand_value(hand), 20)\n\n\nclass BlackjackGameTestCheckWinner(unittest.TestCase):\n    def setUp(self):\n        self.blackjackGame = BlackjackGame()\n\n    # player > 21 but dealer not, dealer wins.\n    def test_check_winner_1(self):\n        player_hand = ['2S', 'JS', 'QS']\n        dealer_hand = ['7S', '9S']\n        self.assertEqual(self.blackjackGame.check_winner(player_hand, dealer_hand), 'Dealer wins')\n\n    # dealer > 21 but player not, player wins.\n    def test_check_winner_2(self):\n        player_hand = ['2S', '4S', '5S']\n        dealer_hand = ['2S', 'JS', 'QS']\n        self.assertEqual(self.blackjackGame.check_winner(player_hand, dealer_hand), 'Player wins')\n\n    # both > 21 but dealer smaller, dealer wins.\n    def test_check_winner_3(self):\n        player_hand = ['3S', 'JS', 'QS']\n        dealer_hand = ['2S', 'JS', 'QS']\n        self.assertEqual(self.blackjackGame.check_winner(player_hand, dealer_hand), 'Dealer wins')\n\n    # both > 21 but player smaller, player wins.\n    def test_check_winner_4(self):\n        player_hand = ['2S', 'JS', 'QS']\n        dealer_hand = ['3S', 'JS', 'QS']\n        self.assertEqual(self.blackjackGame.check_winner(player_hand, dealer_hand), 'Player wins')\n\n    # both < 21 but dealer is bigger, dealer wins.\n    def test_check_winner_5(self):\n        player_hand = ['2S', '3S', '5S']\n        dealer_hand = ['AS', 'JS']\n        self.assertEqual(self.blackjackGame.check_winner(player_hand, dealer_hand), 'Dealer wins')\n\n    # both < 21 but player is bigger, player wins.\n    def test_check_winner_6(self):\n        player_hand = ['AS', 'JS']\n        dealer_hand = ['2S', '3S', '5S']\n        self.assertEqual(self.blackjackGame.check_winner(player_hand, dealer_hand), 'Player wins')\n\n\nclass BlackjackGameTestMain(unittest.TestCase):\n    # calculate_hand_value method will be invoked in check_winner\n    def test_main_1(self):\n        blackjackGame = BlackjackGame()\n        deck = blackjackGame.deck\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        for suit in suits:\n            for rank in ranks:\n                self.assertIn(rank + suit, deck)\n        player_hand = ['2S', 'JS', 'QS']\n        dealer_hand = ['7S', '9S']\n        self.assertEqual(blackjackGame.check_winner(player_hand, dealer_hand), 'Dealer wins')",
        "solution_code": "import random\n\n\nclass BlackjackGame:\n    def __init__(self):\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n    def create_deck(self):\n        deck = []\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        for suit in suits:\n            for rank in ranks:\n                deck.append(rank + suit)\n        random.shuffle(deck)\n        return deck\n\n    def calculate_hand_value(self, hand):\n        value = 0\n        num_aces = 0\n        for card in hand:\n            rank = card[:-1]\n            if rank.isdigit():\n                value += int(rank)\n            elif rank in ['J', 'Q', 'K']:\n                value += 10\n            elif rank == 'A':\n                value += 11\n                num_aces += 1\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        return value\n\n    def check_winner(self, player_hand, dealer_hand):\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n        if player_value > 21 and dealer_value > 21:\n            if player_value <= dealer_value:\n                return 'Player wins'\n            else:\n                return 'Dealer wins'\n        elif player_value > 21:\n            return 'Dealer wins'\n        elif dealer_value > 21:\n            return 'Player wins'\n        else:\n            if player_value <= dealer_value:\n                return 'Dealer wins'\n            else:\n                return 'Player wins'",
        "import_statement": [
            "import random"
        ],
        "class_description": "    \"\"\"\n    This is a class representing a game of blackjack, which includes creating a deck, calculating the value of a hand, and determine the winner based on the hand values of the player and dealer.\n    \"\"\"\n",
        "class_name": "BlackjackGame",
        "test_classes": [
            "BlackjackGameTestCreateDeck",
            "BlackjackGameTestCalculateHandValue",
            "BlackjackGameTestCheckWinner",
            "BlackjackGameTestMain"
        ],
        "class_constructor": "class BlackjackGame: \n    def __init__(self):\n        \"\"\"\n        Initialize the Blackjack Game with the attribute deck, player_hand and dealer_hand.\n        While initializing deck attribute, call the create_deck method to generate.\n        The deck stores 52 rondom order poker with the Jokers removed, format is ['AS', '2S', ...].\n        player_hand is a list which stores player's hand cards.\n        dealer_hand is is a list which stores dealer's hand cards.\n        \"\"\"\n        self.deck = self.create_deck()\n        self.player_hand = []\n        self.dealer_hand = []\n\n",
        "fields": [
            "self.dealer_hand",
            "self.deck",
            "self.player_hand"
        ],
        "methods_info": [
            {
                "method_name": "create_deck",
                "method_description": "def create_deck(self):\n        \"\"\"\n        Create a deck of 52 cards, which stores 52 rondom order poker with the Jokers removed.\n        :return: a list of 52 rondom order poker with the Jokers removed, format is ['AS', '2S', ...].\n        >>> black_jack_game = BlackjackGame()\n        >>> black_jack_game.create_deck()\n        ['QD', '9D', 'JC', 'QH', '2S', 'JH', '7D', '6H', '9S', '5C', '7H', 'QS', '5H',\n        '6C', '7C', '3D', '10C', 'AD', '4C', '5D', 'AH', '2D', 'QC', 'KH', '9C', '9H',\n        '4H', 'JS', '6S', '8H', '8C', '4S', '3H', '10H', '7S', '6D', '3C', 'KC', '3S',\n        '2H', '10D', 'KS', '4D', 'AC', '10S', '2C', 'KD', '5S', 'JD', '8S', 'AS', '8D']\n        \"\"\"",
                "test_class": "BlackjackGameTestCreateDeck",
                "test_code": "class BlackjackGameTestCreateDeck(unittest.TestCase):\n    def setUp(self):\n        self.blackjackGame = BlackjackGame()\n        self.deck = self.blackjackGame.deck\n\n    def test_create_deck_1(self):\n        self.assertEqual(len(self.deck), 52)\n\n    def test_create_deck_2(self):\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        for suit in suits:\n            for rank in ranks:\n                self.assertIn(rank + suit, self.deck)\n\n    def test_create_deck_3(self):\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9']\n        for suit in suits:\n            for rank in ranks:\n                self.assertIn(rank + suit, self.deck)\n\n    def test_create_deck_4(self):\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['10', 'J', 'Q', 'K']\n        for suit in suits:\n            for rank in ranks:\n                self.assertIn(rank + suit, self.deck)\n\n    def test_create_deck_5(self):\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9']\n        for suit in suits:\n            for rank in ranks:\n                self.assertIn(rank + suit, self.deck)",
                "solution_code": "def create_deck(self):\n        deck = []\n        suits = ['S', 'C', 'D', 'H']\n        ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']\n        for suit in suits:\n            for rank in ranks:\n                deck.append(rank + suit)\n        random.shuffle(deck)\n        return deck",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "random"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "calculate_hand_value",
                "method_description": "def calculate_hand_value(self, hand):\n        \"\"\"\n        Calculate the value of the poker cards stored in hand list according to the rules of the Blackjack Game.\n        If the card is a digit, its value is added to the total hand value.\n        Value of J, Q, or K is 10, while Aces are worth 11.\n        If the total hand value exceeds 21 and there are Aces present, one Ace is treated as having a value of 1 instead of 11,\n        until the hand value is less than or equal to 21, or all Aces have been counted as value of 1.\n        :param hand: list\n        :return: the value of the poker cards stored in hand list, a number.\n        >>> black_jack_game.calculate_hand_value(['QD', '9D', 'JC', 'QH', 'AS'])\n        40\n        \"\"\"",
                "test_class": "BlackjackGameTestCalculateHandValue",
                "test_code": "class BlackjackGameTestCalculateHandValue(unittest.TestCase):\n    def test_calculate_hand_value_1(self):\n        blackjackGame = BlackjackGame()\n        hand = ['2S', '3S', '4S', '5S']\n        self.assertEqual(blackjackGame.calculate_hand_value(hand), 14)\n\n    def test_calculate_hand_value_2(self):\n        blackjackGame = BlackjackGame()\n        hand = ['2S', '3S', 'JS', 'QS']\n        self.assertEqual(blackjackGame.calculate_hand_value(hand), 25)\n\n    def test_calculate_hand_value_3(self):\n        blackjackGame = BlackjackGame()\n        hand = ['2S', '3S', '4S', 'AS']\n        self.assertEqual(blackjackGame.calculate_hand_value(hand), 20)\n\n    def test_calculate_hand_value_4(self):\n        blackjackGame = BlackjackGame()\n        hand = ['JS', 'QS', '4S', 'AS']\n        self.assertEqual(blackjackGame.calculate_hand_value(hand), 25)\n\n    def test_calculate_hand_value_5(self):\n        blackjackGame = BlackjackGame()\n        hand = ['JS', 'QS', 'AS', 'AS', 'AS']\n        self.assertEqual(blackjackGame.calculate_hand_value(hand), 23)\n\n    def test_calculate_hand_value_6(self):\n        blackjackGame = BlackjackGame()\n        hand = ['JS', 'QS', 'BS', 'CS']\n        self.assertEqual(blackjackGame.calculate_hand_value(hand), 20)",
                "solution_code": "def calculate_hand_value(self, hand):\n        value = 0\n        num_aces = 0\n        for card in hand:\n            rank = card[:-1]\n            if rank.isdigit():\n                value += int(rank)\n            elif rank in ['J', 'Q', 'K']:\n                value += 10\n            elif rank == 'A':\n                value += 11\n                num_aces += 1\n        while value > 21 and num_aces > 0:\n            value -= 10\n            num_aces -= 1\n        return value",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "check_winner",
                "method_description": "def check_winner(self, player_hand, dealer_hand):\n        \"\"\"\n        Determines the winner of a game by comparing the hand values of the player and dealer.\n        rule:\n        If both players have hand values that are equal to or less than 21, the winner is the one whose hand value is closer to 21.\n        Otherwise, the winner is the one with the lower hand value.\n        :param player_hand: list\n        :param dealer_hand: list\n        :return: the result of the game, only two certain str: 'Dealer wins' or 'Player wins'\n        >>> black_jack_game.check_winner(['QD', '9D', 'JC', 'QH', 'AS'], ['QD', '9D', 'JC', 'QH', '2S'])\n        'Player wins'\n        \"\"\"",
                "test_class": "BlackjackGameTestCheckWinner",
                "test_code": "class BlackjackGameTestCheckWinner(unittest.TestCase):\n    def setUp(self):\n        self.blackjackGame = BlackjackGame()\n\n    # player > 21 but dealer not, dealer wins.\n    def test_check_winner_1(self):\n        player_hand = ['2S', 'JS', 'QS']\n        dealer_hand = ['7S', '9S']\n        self.assertEqual(self.blackjackGame.check_winner(player_hand, dealer_hand), 'Dealer wins')\n\n    # dealer > 21 but player not, player wins.\n    def test_check_winner_2(self):\n        player_hand = ['2S', '4S', '5S']\n        dealer_hand = ['2S', 'JS', 'QS']\n        self.assertEqual(self.blackjackGame.check_winner(player_hand, dealer_hand), 'Player wins')\n\n    # both > 21 but dealer smaller, dealer wins.\n    def test_check_winner_3(self):\n        player_hand = ['3S', 'JS', 'QS']\n        dealer_hand = ['2S', 'JS', 'QS']\n        self.assertEqual(self.blackjackGame.check_winner(player_hand, dealer_hand), 'Dealer wins')\n\n    # both > 21 but player smaller, player wins.\n    def test_check_winner_4(self):\n        player_hand = ['2S', 'JS', 'QS']\n        dealer_hand = ['3S', 'JS', 'QS']\n        self.assertEqual(self.blackjackGame.check_winner(player_hand, dealer_hand), 'Player wins')\n\n    # both < 21 but dealer is bigger, dealer wins.\n    def test_check_winner_5(self):\n        player_hand = ['2S', '3S', '5S']\n        dealer_hand = ['AS', 'JS']\n        self.assertEqual(self.blackjackGame.check_winner(player_hand, dealer_hand), 'Dealer wins')\n\n    # both < 21 but player is bigger, player wins.\n    def test_check_winner_6(self):\n        player_hand = ['AS', 'JS']\n        dealer_hand = ['2S', '3S', '5S']\n        self.assertEqual(self.blackjackGame.check_winner(player_hand, dealer_hand), 'Player wins')",
                "solution_code": "def check_winner(self, player_hand, dealer_hand):\n        player_value = self.calculate_hand_value(player_hand)\n        dealer_value = self.calculate_hand_value(dealer_hand)\n        if player_value > 21 and dealer_value > 21:\n            if player_value <= dealer_value:\n                return 'Player wins'\n            else:\n                return 'Dealer wins'\n        elif player_value > 21:\n            return 'Dealer wins'\n        elif dealer_value > 21:\n            return 'Player wins'\n        else:\n            if player_value <= dealer_value:\n                return 'Dealer wins'\n            else:\n                return 'Player wins'",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "calculate_hand_value"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_20",
        "skeleton": "from datetime import datetime\n\nclass Chat:\n    \"\"\"\n    This is a chat class with the functions of adding users, removing users, sending messages, and obtaining messages.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the Chat with an attribute users, which is an empty dictionary.\n        \"\"\"\n        self.users = {}\n\n    def add_user(self, username):\n        \"\"\"\n        Add a new user to the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns False, otherwise, returns True.\n        >>> chat = Chat()\n        >>> chat.add_user('John')\n        True\n        self.users = {'John': []}\n        >>> chat.add_user('John')\n        False\n\n        \"\"\"\n\n    def remove_user(self, username):\n        \"\"\"\n        Remove a user from the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns True, otherwise, returns False.\n        >>> chat = Chat()\n        >>> chat.users = {'John': []}\n        >>> chat.remove_user('John')\n        True\n        >>> chat.remove_user('John')\n        False\n\n        \"\"\"\n\n    def send_message(self, sender, receiver, message):\n        \"\"\"\n        Send a message from a user to another user.\n        :param sender: The sender's name, str.\n        :param receiver: The receiver's name, str.\n        :param message: The message, str.\n        :return: If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.\n        >>> chat = Chat()\n        >>> chat.users = {'John': [], 'Mary': []}\n        >>> chat.send_message('John', 'Mary', 'Hello')\n        True\n        >>> chat.send_message('John', 'Tom', 'Hello')\n        False\n\n        \"\"\"\n\n    def get_messages(self, username):\n        \"\"\"\n        Get all the messages of a user from the Chat.\n        :param username: The user's name, str.\n        :return: A list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.\n        >>> chat = Chat()\n        >>> chat.users = {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]}\n        >>> chat.get_messages('John')\n        [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]\n        >>> chat.get_messages('Mary')\n        []\n\n        \"\"\"",
        "test": "import unittest\n\nclass ChatTestAddUser(unittest.TestCase):\n    def test_add_user(self):\n        chat = Chat()\n        self.assertEqual(chat.add_user('John'), True)\n        self.assertEqual(chat.users, {'John': []})\n    def test_add_user_2(self):\n        chat = Chat()\n        chat.users = {'John': []}\n        self.assertEqual(chat.add_user('John'), False)\n        self.assertEqual(chat.users, {'John': []})\n\n    def test_add_user_3(self):\n        chat = Chat()\n        chat.users = {'John': []}\n        self.assertEqual(chat.add_user('Mary'), True)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n\n    def test_add_user_4(self):\n        chat = Chat()\n        chat.users = {'John': []}\n        self.assertEqual(chat.add_user('Mary'), True)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n\n    def test_add_user_5(self):\n        chat = Chat()\n        self.assertEqual(chat.add_user('John'), True)\n        self.assertEqual(chat.add_user('Mary'), True)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n\nclass ChatTestRemoveUser(unittest.TestCase):\n    def test_remove_user(self):\n        chat = Chat()\n        chat.users = {'John': []}\n        self.assertEqual(chat.remove_user('John'), True)\n        self.assertEqual(chat.users, {})\n    def test_remove_user_2(self):\n        chat = Chat()\n        self.assertEqual(chat.remove_user('John'), False)\n        self.assertEqual(chat.users, {})\n\n    def test_remove_user_3(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.remove_user('John'), True)\n        self.assertEqual(chat.users, {'Mary': []})\n\n    def test_remove_user_4(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.remove_user('Mary'), True)\n        self.assertEqual(chat.remove_user('John'), True)\n        self.assertEqual(chat.users, {})\n\n    def test_remove_user_5(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.remove_user('Amy'), False)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n\nclass ChatTestSendMessage(unittest.TestCase):\n    def test_send_message(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertEqual(chat.send_message('John', 'Mary', 'Hello'), True)\n        self.assertEqual(chat.users, {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}], 'Mary': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}]})\n\n    def test_send_message_2(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.send_message('John', 'Tom', 'Hello'), False)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n\n    def test_send_message_3(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.send_message('Amy', 'Mary', 'Hello'), False)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n\n    def test_send_message_4(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.send_message('Amy', 'Tom', 'Hello'), False)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n\n    def test_send_message_5(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.send_message('Amy', 'Amy', 'Hello'), False)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n\n\nclass ChatTestGetMessages(unittest.TestCase):\n    def test_get_messages(self):\n        chat = Chat()\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        chat.users = {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}]}\n        self.assertEqual(chat.get_messages('John'), [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}])\n\n    def test_get_messages_2(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.get_messages('John'), [])\n\n    def test_get_messages_3(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.get_messages('Amy'), [])\n\n    def test_get_messages_4(self):\n        chat = Chat()\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        chat.users = {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}]}\n        self.assertEqual(chat.get_messages('Mary'), [])\n\n    def test_get_messages_5(self):\n        chat = Chat()\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        chat.users = {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}]}\n        self.assertEqual(chat.get_messages('Amy'), [])\n\nclass ChatTestMain(unittest.TestCase):\n    def test_main(self):\n        chat = Chat()\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertEqual(chat.add_user('John'), True)\n        self.assertEqual(chat.add_user('Mary'), True)\n        self.assertEqual(chat.add_user('Amy'), True)\n        self.assertEqual(chat.users, {'John': [], 'Mary': [], 'Amy': []})\n        self.assertEqual(chat.remove_user('Amy'), True)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n        self.assertEqual(chat.send_message('John', 'Mary', 'Hello'), True)\n        self.assertEqual(chat.send_message('John', 'Tom', 'Hello'), False)\n        self.assertEqual(chat.users, {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}], 'Mary': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}]})\n        self.assertEqual(chat.get_messages('John'), [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}])\n        self.assertEqual(chat.get_messages('Mary'), [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}])\n\n    def test_main_2(self):\n        chat = Chat()\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertEqual(chat.remove_user('Amy'), False)\n        self.assertEqual(chat.add_user('John'), True)\n        self.assertEqual(chat.add_user('Mary'), True)\n        self.assertEqual(chat.add_user('Amy'), True)\n        self.assertEqual(chat.users, {'John': [], 'Mary': [], 'Amy': []})\n        self.assertEqual(chat.send_message('John', 'Mary', 'Hello'), True)\n        self.assertEqual(chat.send_message('John', 'Tom', 'Hello'), False)\n        self.assertEqual(chat.remove_user('Amy'), True)\n        self.assertEqual(chat.users, {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}], 'Mary': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}]})\n        self.assertEqual(chat.users, {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}], 'Mary': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}]})\n        self.assertEqual(chat.get_messages('John'), [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}])",
        "solution_code": "from datetime import datetime\n\nclass Chat:\n    def __init__(self):\n        self.users = {}\n\n    def add_user(self, username):\n        if username in self.users:\n            return False\n        else:\n            self.users[username] = []\n            return True\n\n    def remove_user(self, username):\n        if username in self.users:\n            del self.users[username]\n            return True\n        else:\n            return False\n\n    def send_message(self, sender, receiver, message):\n        if sender not in self.users or receiver not in self.users:\n            return False\n\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        message_info = {\n            'sender': sender,\n            'receiver': receiver,\n            'message': message,\n            'timestamp': timestamp\n        }\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        return True\n\n    def get_messages(self, username):\n        if username not in self.users:\n            return []\n        return self.users[username]",
        "import_statement": [
            "from datetime import datetime"
        ],
        "class_description": "    \"\"\"\n    This is a chat class with the functions of adding users, removing users, sending messages, and obtaining messages.\n    \"\"\"\n",
        "class_name": "Chat",
        "test_classes": [
            "ChatTestAddUser",
            "ChatTestRemoveUser",
            "ChatTestSendMessage",
            "ChatTestGetMessages",
            "ChatTestMain"
        ],
        "class_constructor": "class Chat: \n    def __init__(self):\n        \"\"\"\n        Initialize the Chat with an attribute users, which is an empty dictionary.\n        \"\"\"\n        self.users = {}\n\n",
        "fields": [
            "self.users"
        ],
        "methods_info": [
            {
                "method_name": "add_user",
                "method_description": "def add_user(self, username):\n        \"\"\"\n        Add a new user to the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns False, otherwise, returns True.\n        >>> chat = Chat()\n        >>> chat.add_user('John')\n        True\n        self.users = {'John': []}\n        >>> chat.add_user('John')\n        False\n\n        \"\"\"",
                "test_class": "ChatTestAddUser",
                "test_code": "class ChatTestAddUser(unittest.TestCase):\n    def test_add_user(self):\n        chat = Chat()\n        self.assertEqual(chat.add_user('John'), True)\n        self.assertEqual(chat.users, {'John': []})\n    def test_add_user_2(self):\n        chat = Chat()\n        chat.users = {'John': []}\n        self.assertEqual(chat.add_user('John'), False)\n        self.assertEqual(chat.users, {'John': []})\n\n    def test_add_user_3(self):\n        chat = Chat()\n        chat.users = {'John': []}\n        self.assertEqual(chat.add_user('Mary'), True)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n\n    def test_add_user_4(self):\n        chat = Chat()\n        chat.users = {'John': []}\n        self.assertEqual(chat.add_user('Mary'), True)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n\n    def test_add_user_5(self):\n        chat = Chat()\n        self.assertEqual(chat.add_user('John'), True)\n        self.assertEqual(chat.add_user('Mary'), True)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})",
                "solution_code": "def add_user(self, username):\n        if username in self.users:\n            return False\n        else:\n            self.users[username] = []\n            return True",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.users"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "remove_user",
                "method_description": "def remove_user(self, username):\n        \"\"\"\n        Remove a user from the Chat.\n        :param username: The user's name, str.\n        :return: If the user is already in the Chat, returns True, otherwise, returns False.\n        >>> chat = Chat()\n        >>> chat.users = {'John': []}\n        >>> chat.remove_user('John')\n        True\n        >>> chat.remove_user('John')\n        False\n\n        \"\"\"",
                "test_class": "ChatTestRemoveUser",
                "test_code": "class ChatTestRemoveUser(unittest.TestCase):\n    def test_remove_user(self):\n        chat = Chat()\n        chat.users = {'John': []}\n        self.assertEqual(chat.remove_user('John'), True)\n        self.assertEqual(chat.users, {})\n    def test_remove_user_2(self):\n        chat = Chat()\n        self.assertEqual(chat.remove_user('John'), False)\n        self.assertEqual(chat.users, {})\n\n    def test_remove_user_3(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.remove_user('John'), True)\n        self.assertEqual(chat.users, {'Mary': []})\n\n    def test_remove_user_4(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.remove_user('Mary'), True)\n        self.assertEqual(chat.remove_user('John'), True)\n        self.assertEqual(chat.users, {})\n\n    def test_remove_user_5(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.remove_user('Amy'), False)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})",
                "solution_code": "def remove_user(self, username):\n        if username in self.users:\n            del self.users[username]\n            return True\n        else:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.users"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "send_message",
                "method_description": "def send_message(self, sender, receiver, message):\n        \"\"\"\n        Send a message from a user to another user.\n        :param sender: The sender's name, str.\n        :param receiver: The receiver's name, str.\n        :param message: The message, str.\n        :return: If the sender or the receiver is not in the Chat, returns False, otherwise, returns True.\n        >>> chat = Chat()\n        >>> chat.users = {'John': [], 'Mary': []}\n        >>> chat.send_message('John', 'Mary', 'Hello')\n        True\n        >>> chat.send_message('John', 'Tom', 'Hello')\n        False\n\n        \"\"\"",
                "test_class": "ChatTestSendMessage",
                "test_code": "class ChatTestSendMessage(unittest.TestCase):\n    def test_send_message(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertEqual(chat.send_message('John', 'Mary', 'Hello'), True)\n        self.assertEqual(chat.users, {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}], 'Mary': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}]})\n\n    def test_send_message_2(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.send_message('John', 'Tom', 'Hello'), False)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n\n    def test_send_message_3(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.send_message('Amy', 'Mary', 'Hello'), False)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n\n    def test_send_message_4(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.send_message('Amy', 'Tom', 'Hello'), False)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})\n\n    def test_send_message_5(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.send_message('Amy', 'Amy', 'Hello'), False)\n        self.assertEqual(chat.users, {'John': [], 'Mary': []})",
                "solution_code": "def send_message(self, sender, receiver, message):\n        if sender not in self.users or receiver not in self.users:\n            return False\n\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        message_info = {\n            'sender': sender,\n            'receiver': receiver,\n            'message': message,\n            'timestamp': timestamp\n        }\n        self.users[sender].append(message_info)\n        self.users[receiver].append(message_info)\n        return True",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime"
                    ],
                    "field_dependencies": [
                        "self.users"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "get_messages",
                "method_description": "def get_messages(self, username):\n        \"\"\"\n        Get all the messages of a user from the Chat.\n        :param username: The user's name, str.\n        :return: A list of messages, each message is a dictionary with keys 'sender', 'receiver', 'message', 'timestamp'.\n        >>> chat = Chat()\n        >>> chat.users = {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]}\n        >>> chat.get_messages('John')\n        [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': '2023-01-01 00:00:00'}]\n        >>> chat.get_messages('Mary')\n        []\n\n        \"\"\"",
                "test_class": "ChatTestGetMessages",
                "test_code": "class ChatTestGetMessages(unittest.TestCase):\n    def test_get_messages(self):\n        chat = Chat()\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        chat.users = {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}]}\n        self.assertEqual(chat.get_messages('John'), [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}])\n\n    def test_get_messages_2(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.get_messages('John'), [])\n\n    def test_get_messages_3(self):\n        chat = Chat()\n        chat.users = {'John': [], 'Mary': []}\n        self.assertEqual(chat.get_messages('Amy'), [])\n\n    def test_get_messages_4(self):\n        chat = Chat()\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        chat.users = {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}]}\n        self.assertEqual(chat.get_messages('Mary'), [])\n\n    def test_get_messages_5(self):\n        chat = Chat()\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        chat.users = {'John': [{'sender': 'John', 'receiver': 'Mary', 'message': 'Hello', 'timestamp': timestamp}]}\n        self.assertEqual(chat.get_messages('Amy'), [])",
                "solution_code": "def get_messages(self, username):\n        if username not in self.users:\n            return []\n        return self.users[username]",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.users"
                    ],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_21",
        "skeleton": "from datetime import datetime\n\nclass Classroom:\n    \"\"\"\n    This is a class representing a classroom, capable of adding and removing courses, checking availability at a given time, and detecting conflicts when scheduling new courses.\n    \"\"\"\n\n    def __init__(self, id):\n        \"\"\"\n        Initialize the classroom management system.\n        :param id: int, the id of classroom\n        \"\"\"\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n        \"\"\"\n        Add course to self.courses list if the course wasn't in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"\n\n    def remove_course(self, course):\n        \"\"\"\n        Remove course from self.courses list if the course was in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"\n\n    def is_free_at(self, check_time):\n        \"\"\"\n        change the time format as '%H:%M' and check the time is free or not in the classroom.\n        :param check_time: str, the time need to be checked\n        :return: True if the check_time does not conflict with every course time, or False otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.is_free_at('10:00')\n        True\n        >>> classroom.is_free_at('9:00')\n        False\n        \"\"\"\n\n    def check_course_conflict(self, new_course):\n        \"\"\"\n        Before adding a new course, check if the new course time conflicts with any other course.\n        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        :return: False if the new course time conflicts(including two courses have the same boundary time) with other courses, or True otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.check_course_conflict({'name': 'SE', 'start_time': '9:40', 'end_time': '10:40'})\n        False\n        \"\"\"",
        "test": "import unittest\nfrom datetime import datetime\n\n\nclass ClassroomTestAddCourse(unittest.TestCase):\n    def test_add_course_1(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)\n\n    def test_add_course_2(self):\n        classroom = Classroom(1)\n        course = {'name': 'Chinese', 'start_time': '10:00', 'end_time': '11:00'}\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)\n\n    def test_add_course_3(self):\n        classroom = Classroom(1)\n        course = {'name': 'English', 'start_time': '11:00', 'end_time': '12:00'}\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)\n\n    def test_add_course_4(self):\n        classroom = Classroom(1)\n        course = {'name': 'Art', 'start_time': '14:00', 'end_time': '15:00'}\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)\n\n    def test_add_course_5(self):\n        classroom = Classroom(1)\n        course = {'name': 'P.E.', 'start_time': '15:00', 'end_time': '16:00'}\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)\n\n    def test_add_course_6(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)\n\n\nclass ClassroomTestRemoveCourse(unittest.TestCase):\n    def test_remove_course_1(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        classroom.remove_course(course)\n        self.assertNotIn(course, classroom.courses)\n\n    def test_remove_course_2(self):\n        classroom = Classroom(1)\n        course = {'name': 'Chinese', 'start_time': '10:00', 'end_time': '11:00'}\n        classroom.add_course(course)\n        classroom.remove_course(course)\n        self.assertNotIn(course, classroom.courses)\n\n    def test_remove_course_3(self):\n        classroom = Classroom(1)\n        course = {'name': 'English', 'start_time': '11:00', 'end_time': '12:00'}\n        classroom.add_course(course)\n        classroom.remove_course(course)\n        self.assertNotIn(course, classroom.courses)\n\n    def test_remove_course_4(self):\n        classroom = Classroom(1)\n        course = {'name': 'Art', 'start_time': '14:00', 'end_time': '15:00'}\n        classroom.add_course(course)\n        classroom.remove_course(course)\n        self.assertNotIn(course, classroom.courses)\n\n    def test_remove_course_5(self):\n        classroom = Classroom(1)\n        course = {'name': 'P.E.', 'start_time': '15:00', 'end_time': '16:00'}\n        classroom.add_course(course)\n        classroom.remove_course(course)\n        self.assertNotIn(course, classroom.courses)\n\n    def test_remove_course_6(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.remove_course(course)\n        self.assertNotIn(course, classroom.courses)\n\n\nclass ClassroomTestIsFreeAt(unittest.TestCase):\n    def test_is_free_at_1(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        check_time = '11:00'\n        result = classroom.is_free_at(check_time)\n        self.assertTrue(result)\n\n    def test_is_free_at_2(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        check_time = '09:30'\n        result = classroom.is_free_at(check_time)\n        self.assertFalse(result)\n\n    def test_is_free_at_3(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        check_time = '12:00'\n        result = classroom.is_free_at(check_time)\n        self.assertTrue(result)\n\n    def test_is_free_at_4(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        check_time = '14:00'\n        result = classroom.is_free_at(check_time)\n        self.assertTrue(result)\n\n    def test_is_free_at_5(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        check_time = '09:40'\n        result = classroom.is_free_at(check_time)\n        self.assertFalse(result)\n\n\nclass ClassroomTestCheckCourseConflict(unittest.TestCase):\n    def test_check_course_conflict_1(self):\n        classroom = Classroom(1)\n        existing_course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(existing_course)\n        new_course = {'name': 'SE', 'start_time': '10:30', 'end_time': '11:30'}\n        result = classroom.check_course_conflict(new_course)\n        self.assertTrue(result)\n\n    def test_check_course_conflict_2(self):\n        classroom = Classroom(1)\n        existing_course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(existing_course)\n        new_course = {'name': 'SE', 'start_time': '09:30', 'end_time': '10:30'}\n        result = classroom.check_course_conflict(new_course)\n        self.assertFalse(result)\n\n    # have the same boundary time\n    # existing_course['end_time'] == new_course['start_time']\n    def test_check_course_conflict_3(self):\n        classroom = Classroom(1)\n        existing_course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(existing_course)\n        new_course = {'name': 'SE', 'start_time': '10:00', 'end_time': '11:30'}\n        result = classroom.check_course_conflict(new_course)\n        self.assertFalse(result)\n\n    def test_check_course_conflict_4(self):\n        classroom = Classroom(1)\n        existing_course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(existing_course)\n        new_course = {'name': 'SE', 'start_time': '09:40', 'end_time': '10:40'}\n        result = classroom.check_course_conflict(new_course)\n        self.assertFalse(result)\n\n    def test_check_course_conflict_5(self):\n        classroom = Classroom(1)\n        existing_course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(existing_course)\n        new_course = {'name': 'SE', 'start_time': '14:30', 'end_time': '15:30'}\n        result = classroom.check_course_conflict(new_course)\n        self.assertTrue(result)\n\n    def test_check_course_conflict_6(self):\n        classroom = Classroom(1)\n        existing_course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(existing_course)\n        new_course = {'name': 'SE', 'start_time': '8:30', 'end_time': '9:30'}\n        result = classroom.check_course_conflict(new_course)\n        self.assertFalse(result)\n\n\nclass ClassroomTestMain(unittest.TestCase):\n    def test_main(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)\n\n        classroom.remove_course(course)\n        self.assertNotIn(course, classroom.courses)\n\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)\n        check_time = '09:30'\n        result = classroom.is_free_at(check_time)\n        self.assertFalse(result)\n\n        new_course = {'name': 'SE', 'start_time': '09:30', 'end_time': '10:30'}\n        result = classroom.check_course_conflict(new_course)\n        self.assertFalse(result)",
        "solution_code": "from datetime import datetime\n\n\nclass Classroom:\n    def __init__(self, id):\n        self.id = id\n        self.courses = []\n\n    def add_course(self, course):\n\n        if course not in self.courses:\n            self.courses.append(course)\n\n    def remove_course(self, course):\n        if course in self.courses:\n            self.courses.remove(course)\n\n    def is_free_at(self, check_time):\n        check_time = datetime.strptime(check_time, '%H:%M')\n\n        for course in self.courses:\n            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],\n                                                                                                   '%H:%M'):\n                return False\n        return True\n\n    def check_course_conflict(self, new_course):\n        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')\n        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')\n\n        flag = True\n        for course in self.courses:\n            start_time = datetime.strptime(course['start_time'], '%H:%M')\n            end_time = datetime.strptime(course['end_time'], '%H:%M')\n            if start_time <= new_start_time and end_time >= new_start_time:\n                flag = False\n            if start_time <= new_end_time and end_time >= new_end_time:\n                flag = False\n        return flag",
        "import_statement": [
            "from datetime import datetime"
        ],
        "class_description": "    \"\"\"\n    This is a class representing a classroom, capable of adding and removing courses, checking availability at a given time, and detecting conflicts when scheduling new courses.\n    \"\"\"\n",
        "class_name": "Classroom",
        "test_classes": [
            "ClassroomTestAddCourse",
            "ClassroomTestRemoveCourse",
            "ClassroomTestIsFreeAt",
            "ClassroomTestCheckCourseConflict",
            "ClassroomTestMain"
        ],
        "class_constructor": "class Classroom: \n    def __init__(self, id):\n        \"\"\"\n        Initialize the classroom management system.\n        :param id: int, the id of classroom\n        \"\"\"\n        self.id = id\n        self.courses = []\n\n",
        "fields": [
            "self.courses",
            "self.id"
        ],
        "methods_info": [
            {
                "method_name": "add_course",
                "method_description": "def add_course(self, course):\n        \"\"\"\n        Add course to self.courses list if the course wasn't in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"",
                "test_class": "ClassroomTestAddCourse",
                "test_code": "class ClassroomTestAddCourse(unittest.TestCase):\n    def test_add_course_1(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)\n\n    def test_add_course_2(self):\n        classroom = Classroom(1)\n        course = {'name': 'Chinese', 'start_time': '10:00', 'end_time': '11:00'}\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)\n\n    def test_add_course_3(self):\n        classroom = Classroom(1)\n        course = {'name': 'English', 'start_time': '11:00', 'end_time': '12:00'}\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)\n\n    def test_add_course_4(self):\n        classroom = Classroom(1)\n        course = {'name': 'Art', 'start_time': '14:00', 'end_time': '15:00'}\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)\n\n    def test_add_course_5(self):\n        classroom = Classroom(1)\n        course = {'name': 'P.E.', 'start_time': '15:00', 'end_time': '16:00'}\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)\n\n    def test_add_course_6(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        classroom.add_course(course)\n        self.assertIn(course, classroom.courses)",
                "solution_code": "def add_course(self, course):\n\n        if course not in self.courses:\n            self.courses.append(course)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.courses"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "remove_course",
                "method_description": "def remove_course(self, course):\n        \"\"\"\n        Remove course from self.courses list if the course was in it.\n        :param course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        \"\"\"",
                "test_class": "ClassroomTestRemoveCourse",
                "test_code": "class ClassroomTestRemoveCourse(unittest.TestCase):\n    def test_remove_course_1(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        classroom.remove_course(course)\n        self.assertNotIn(course, classroom.courses)\n\n    def test_remove_course_2(self):\n        classroom = Classroom(1)\n        course = {'name': 'Chinese', 'start_time': '10:00', 'end_time': '11:00'}\n        classroom.add_course(course)\n        classroom.remove_course(course)\n        self.assertNotIn(course, classroom.courses)\n\n    def test_remove_course_3(self):\n        classroom = Classroom(1)\n        course = {'name': 'English', 'start_time': '11:00', 'end_time': '12:00'}\n        classroom.add_course(course)\n        classroom.remove_course(course)\n        self.assertNotIn(course, classroom.courses)\n\n    def test_remove_course_4(self):\n        classroom = Classroom(1)\n        course = {'name': 'Art', 'start_time': '14:00', 'end_time': '15:00'}\n        classroom.add_course(course)\n        classroom.remove_course(course)\n        self.assertNotIn(course, classroom.courses)\n\n    def test_remove_course_5(self):\n        classroom = Classroom(1)\n        course = {'name': 'P.E.', 'start_time': '15:00', 'end_time': '16:00'}\n        classroom.add_course(course)\n        classroom.remove_course(course)\n        self.assertNotIn(course, classroom.courses)\n\n    def test_remove_course_6(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.remove_course(course)\n        self.assertNotIn(course, classroom.courses)",
                "solution_code": "def remove_course(self, course):\n        if course in self.courses:\n            self.courses.remove(course)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.courses"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "is_free_at",
                "method_description": "def is_free_at(self, check_time):\n        \"\"\"\n        change the time format as '%H:%M' and check the time is free or not in the classroom.\n        :param check_time: str, the time need to be checked\n        :return: True if the check_time does not conflict with every course time, or False otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.is_free_at('10:00')\n        True\n        >>> classroom.is_free_at('9:00')\n        False\n        \"\"\"",
                "test_class": "ClassroomTestIsFreeAt",
                "test_code": "class ClassroomTestIsFreeAt(unittest.TestCase):\n    def test_is_free_at_1(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        check_time = '11:00'\n        result = classroom.is_free_at(check_time)\n        self.assertTrue(result)\n\n    def test_is_free_at_2(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        check_time = '09:30'\n        result = classroom.is_free_at(check_time)\n        self.assertFalse(result)\n\n    def test_is_free_at_3(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        check_time = '12:00'\n        result = classroom.is_free_at(check_time)\n        self.assertTrue(result)\n\n    def test_is_free_at_4(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        check_time = '14:00'\n        result = classroom.is_free_at(check_time)\n        self.assertTrue(result)\n\n    def test_is_free_at_5(self):\n        classroom = Classroom(1)\n        course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(course)\n        check_time = '09:40'\n        result = classroom.is_free_at(check_time)\n        self.assertFalse(result)",
                "solution_code": "def is_free_at(self, check_time):\n        check_time = datetime.strptime(check_time, '%H:%M')\n\n        for course in self.courses:\n            if datetime.strptime(course['start_time'], '%H:%M') <= check_time <= datetime.strptime(course['end_time'],\n                                                                                                   '%H:%M'):\n                return False\n        return True",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime"
                    ],
                    "field_dependencies": [
                        "self.courses"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "check_course_conflict",
                "method_description": "def check_course_conflict(self, new_course):\n        \"\"\"\n        Before adding a new course, check if the new course time conflicts with any other course.\n        :param new_course: dict, information of the course, including 'start_time', 'end_time' and 'name'\n        :return: False if the new course time conflicts(including two courses have the same boundary time) with other courses, or True otherwise.\n        >>> classroom = Classroom(1)\n        >>> classroom.add_course({'name': 'math', 'start_time': '8:00', 'end_time': '9:40'})\n        >>> classroom.check_course_conflict({'name': 'SE', 'start_time': '9:40', 'end_time': '10:40'})\n        False\n        \"\"\"",
                "test_class": "ClassroomTestCheckCourseConflict",
                "test_code": "class ClassroomTestCheckCourseConflict(unittest.TestCase):\n    def test_check_course_conflict_1(self):\n        classroom = Classroom(1)\n        existing_course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(existing_course)\n        new_course = {'name': 'SE', 'start_time': '10:30', 'end_time': '11:30'}\n        result = classroom.check_course_conflict(new_course)\n        self.assertTrue(result)\n\n    def test_check_course_conflict_2(self):\n        classroom = Classroom(1)\n        existing_course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(existing_course)\n        new_course = {'name': 'SE', 'start_time': '09:30', 'end_time': '10:30'}\n        result = classroom.check_course_conflict(new_course)\n        self.assertFalse(result)\n\n    # have the same boundary time\n    # existing_course['end_time'] == new_course['start_time']\n    def test_check_course_conflict_3(self):\n        classroom = Classroom(1)\n        existing_course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(existing_course)\n        new_course = {'name': 'SE', 'start_time': '10:00', 'end_time': '11:30'}\n        result = classroom.check_course_conflict(new_course)\n        self.assertFalse(result)\n\n    def test_check_course_conflict_4(self):\n        classroom = Classroom(1)\n        existing_course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(existing_course)\n        new_course = {'name': 'SE', 'start_time': '09:40', 'end_time': '10:40'}\n        result = classroom.check_course_conflict(new_course)\n        self.assertFalse(result)\n\n    def test_check_course_conflict_5(self):\n        classroom = Classroom(1)\n        existing_course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(existing_course)\n        new_course = {'name': 'SE', 'start_time': '14:30', 'end_time': '15:30'}\n        result = classroom.check_course_conflict(new_course)\n        self.assertTrue(result)\n\n    def test_check_course_conflict_6(self):\n        classroom = Classroom(1)\n        existing_course = {'name': 'math', 'start_time': '09:00', 'end_time': '10:00'}\n        classroom.add_course(existing_course)\n        new_course = {'name': 'SE', 'start_time': '8:30', 'end_time': '9:30'}\n        result = classroom.check_course_conflict(new_course)\n        self.assertFalse(result)",
                "solution_code": "def check_course_conflict(self, new_course):\n        new_start_time = datetime.strptime(new_course['start_time'], '%H:%M')\n        new_end_time = datetime.strptime(new_course['end_time'], '%H:%M')\n\n        flag = True\n        for course in self.courses:\n            start_time = datetime.strptime(course['start_time'], '%H:%M')\n            end_time = datetime.strptime(course['end_time'], '%H:%M')\n            if start_time <= new_start_time and end_time >= new_start_time:\n                flag = False\n            if start_time <= new_end_time and end_time >= new_end_time:\n                flag = False\n        return flag",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime"
                    ],
                    "field_dependencies": [
                        "self.courses"
                    ],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_23",
        "skeleton": "import math\nfrom typing import List\n\nclass CombinationCalculator:\n    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n\n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"\n\n    def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"\n\n    def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of  selecting elements from the given data list,and it uses the select method.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n        \"\"\"\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: The index of the data to be selected,int.\n        :param resultList: The list of elements in the combination,List[str].\n        :param resultIndex: The index of the element in the combination,int.\n        :param result: The list of combinations,List[List[str]].\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> result\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"",
        "test": "import unittest\n\nclass CombinationCalculatorTestCount(unittest.TestCase):\n    def test_count(self):\n        self.assertEqual(CombinationCalculator.count(4, 2), 6)\n    def test_count_2(self):\n        self.assertEqual(CombinationCalculator.count(5, 3), 10)\n\n    def test_count_3(self):\n        self.assertEqual(CombinationCalculator.count(6, 6), 1)\n\n    def test_count_4(self):\n        self.assertEqual(CombinationCalculator.count(6, 0), 1)\n\n    def test_count_5(self):\n        self.assertEqual(CombinationCalculator.count(6, 3), 20)\n\nclass CombinationCalculatorTestCountAll(unittest.TestCase):\n    def test_count_all(self):\n        self.assertEqual(CombinationCalculator.count_all(4), 15)\n\n    def test_count_all_2(self):\n        self.assertEqual(CombinationCalculator.count_all(-1), False)\n\n    def test_count_all_3(self):\n        self.assertEqual(CombinationCalculator.count_all(65), False)\n\n    def test_count_all_4(self):\n        self.assertEqual(CombinationCalculator.count_all(0), 0)\n\n    def test_count_all_5(self):\n        self.assertEqual(CombinationCalculator.count_all(63), float(\"inf\"))\n\nclass CombinationCalculatorTestSelect(unittest.TestCase):\n    def test_select(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(4, 2), 6)\n\n    def test_select_2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(5, 3), 10)\n\n    def test_select_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 6), 1)\n\n    def test_select_4(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 0), 1)\n\n    def test_select_5(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 3), 20)\n\nclass CombinationCalculatorTestSelectAll(unittest.TestCase):\n    def test_select_all(self):\n        calc = CombinationCalculator([\"A\"])\n        self.assertEqual(calc.select_all(), [['A']])\n\n    def test_select_all_2(self):\n        calc = CombinationCalculator([\"A\", \"B\"])\n        self.assertEqual(calc.select_all(), [['A'], ['B'], ['A', 'B']])\n\n    def test_select_all_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\"])\n        self.assertEqual(calc.select_all(),[['A'], ['B'], ['C'], ['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B', 'C']])\n\n    def test_select_all_4(self):\n        calc = CombinationCalculator([])\n        self.assertEqual(calc.select_all(),[])\n\n    def test_select_all_5(self):\n        calc = CombinationCalculator([\"B\"])\n        self.assertEqual(calc.select_all(),[['B']])\n\n\nclass CombinationCalculatorTestSelect2(unittest.TestCase):\n    def test_select2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 2, 0, result)\n        self.assertEqual(result, [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']])\n\n    def test_select2_2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 3, 0, result)\n        self.assertEqual(result, [['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D']])\n\n    def test_select2_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 1, 0, result)\n        self.assertEqual(result, [['A'], ['B'], ['C'], ['D']])\n\n    def test_select2_4(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 0, 0, result)\n        self.assertEqual(result, [[]])\n\n    def test_select2_5(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 4, 0, result)\n        self.assertEqual(result, [['A', 'B', 'C', 'D']])\n\nclass CombinationCalculatorTestMain(unittest.TestCase):\n    def test_main(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(4, 2), 6)\n        self.assertEqual(calc.count_all(4), 15)\n        self.assertEqual(calc.select(2), [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']])\n        self.assertEqual(calc.select_all(), [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']])\n        result = []\n        calc._select(0, [None] * 2, 0, result)\n        self.assertEqual(result, [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']])",
        "solution_code": "import math\nfrom typing import List\n\nclass CombinationCalculator:\n    def __init__(self, datas: List[str]):\n        self.datas = datas\n\n    @staticmethod\n    def count(n: int, m: int) -> int:\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))\n\n    @staticmethod\n    def count_all(n: int) -> int:\n        if n < 0 or n > 63:\n            return False\n        return (1 << n) - 1 if n != 63 else float(\"inf\")\n\n    def select(self, m: int) -> List[List[str]]:\n        result = []\n        self._select(0, [None] * m, 0, result)\n        return result\n\n    def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result\n\n    def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        resultLen = len(resultList)\n        resultCount = resultIndex + 1\n        if resultCount > resultLen:\n            result.append(resultList.copy())\n            return\n\n        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, result)",
        "import_statement": [
            "import math",
            "from typing import List"
        ],
        "class_description": "    \"\"\"\n    This is a class that provides methods to calculate the number of combinations for a specific count, calculate all possible combinations, and generate combinations with a specified number of elements.\n    \"\"\"\n",
        "class_name": "CombinationCalculator",
        "test_classes": [
            "CombinationCalculatorTestCount",
            "CombinationCalculatorTestCountAll",
            "CombinationCalculatorTestSelect",
            "CombinationCalculatorTestSelectAll",
            "CombinationCalculatorTestSelect2",
            "CombinationCalculatorTestMain"
        ],
        "class_constructor": "class CombinationCalculator: \n    def __init__(self, datas: List[str]):\n        \"\"\"\n        Initialize the calculator with a list of data.\n        \"\"\"\n        self.datas = datas\n",
        "fields": [
            "self.datas"
        ],
        "methods_info": [
            {
                "method_name": "count",
                "method_description": "def count(n: int, m: int) -> int:\n        \"\"\"\n        Calculate the number of combinations for a specific count.\n        :param n: The total number of elements,int.\n        :param m: The number of elements in each combination,int.\n        :return: The number of combinations,int.\n        >>> CombinationCalculator.count(4, 2)\n        6\n        \"\"\"",
                "test_class": "CombinationCalculatorTestCount",
                "test_code": "class CombinationCalculatorTestCount(unittest.TestCase):\n    def test_count(self):\n        self.assertEqual(CombinationCalculator.count(4, 2), 6)\n    def test_count_2(self):\n        self.assertEqual(CombinationCalculator.count(5, 3), 10)\n\n    def test_count_3(self):\n        self.assertEqual(CombinationCalculator.count(6, 6), 1)\n\n    def test_count_4(self):\n        self.assertEqual(CombinationCalculator.count(6, 0), 1)\n\n    def test_count_5(self):\n        self.assertEqual(CombinationCalculator.count(6, 3), 20)",
                "solution_code": "def count(n: int, m: int) -> int:\n        if m == 0 or n == m:\n            return 1\n        return math.factorial(n) // (math.factorial(n - m) * math.factorial(m))",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "math"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "count_all",
                "method_description": "@staticmethod\n    def count_all(n: int) -> int:\n        \"\"\"\n        Calculate the number of all possible combinations.\n        :param n: The total number of elements,int.\n        :return: The number of all possible combinations,int,if the number of combinations is greater than 2^63-1,return float(\"inf\").\n        >>> CombinationCalculator.count_all(4)\n        15\n        \"\"\"",
                "test_class": "CombinationCalculatorTestCountAll",
                "test_code": "class CombinationCalculatorTestCountAll(unittest.TestCase):\n    def test_count_all(self):\n        self.assertEqual(CombinationCalculator.count_all(4), 15)\n\n    def test_count_all_2(self):\n        self.assertEqual(CombinationCalculator.count_all(-1), False)\n\n    def test_count_all_3(self):\n        self.assertEqual(CombinationCalculator.count_all(65), False)\n\n    def test_count_all_4(self):\n        self.assertEqual(CombinationCalculator.count_all(0), 0)\n\n    def test_count_all_5(self):\n        self.assertEqual(CombinationCalculator.count_all(63), float(\"inf\"))",
                "solution_code": "@staticmethod\n    def count_all(n: int) -> int:\n        if n < 0 or n > 63:\n            return False\n        return (1 << n) - 1 if n != 63 else float(\"inf\")",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "select",
                "method_description": "def select(self, m: int) -> List[List[str]]:\n        \"\"\"\n        Generate combinations with a specified number of elements.\n        :param m: The number of elements in each combination,int.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select(2)\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"",
                "test_class": "CombinationCalculatorTestSelect",
                "test_code": "class CombinationCalculatorTestSelect(unittest.TestCase):\n    def test_select(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(4, 2), 6)\n\n    def test_select_2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(5, 3), 10)\n\n    def test_select_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 6), 1)\n\n    def test_select_4(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 0), 1)\n\n    def test_select_5(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        self.assertEqual(calc.count(6, 3), 20)",
                "solution_code": "def select(self, m: int) -> List[List[str]]:\n        result = []\n        self._select(0, [None] * m, 0, result)\n        return result",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "_select"
                    ]
                }
            },
            {
                "method_name": "select_all",
                "method_description": "def select_all(self) -> List[List[str]]:\n        \"\"\"\n        Generate all possible combinations of  selecting elements from the given data list,and it uses the select method.\n        :return: A list of combinations,List[List[str]].\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> calc.select_all()\n        [['A'], ['B'], ['C'], ['D'], ['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D'], ['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D'], ['A', 'B', 'C', 'D']]\n\n        \"\"\"",
                "test_class": "CombinationCalculatorTestSelectAll",
                "test_code": "class CombinationCalculatorTestSelectAll(unittest.TestCase):\n    def test_select_all(self):\n        calc = CombinationCalculator([\"A\"])\n        self.assertEqual(calc.select_all(), [['A']])\n\n    def test_select_all_2(self):\n        calc = CombinationCalculator([\"A\", \"B\"])\n        self.assertEqual(calc.select_all(), [['A'], ['B'], ['A', 'B']])\n\n    def test_select_all_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\"])\n        self.assertEqual(calc.select_all(),[['A'], ['B'], ['C'], ['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B', 'C']])\n\n    def test_select_all_4(self):\n        calc = CombinationCalculator([])\n        self.assertEqual(calc.select_all(),[])\n\n    def test_select_all_5(self):\n        calc = CombinationCalculator([\"B\"])\n        self.assertEqual(calc.select_all(),[['B']])",
                "solution_code": "def select_all(self) -> List[List[str]]:\n        result = []\n        for i in range(1, len(self.datas) + 1):\n            result.extend(self.select(i))\n        return result",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.datas"
                    ],
                    "method_dependencies": [
                        "select"
                    ]
                }
            },
            {
                "method_name": "_select",
                "method_description": "def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        \"\"\"\n        Generate combinations with a specified number of elements by recursion.\n        :param dataIndex: The index of the data to be selected,int.\n        :param resultList: The list of elements in the combination,List[str].\n        :param resultIndex: The index of the element in the combination,int.\n        :param result: The list of combinations,List[List[str]].\n        :return: None.\n        >>> calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        >>> result = []\n        >>> calc._select(0, [None] * 2, 0, result)\n        >>> result\n        [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']]\n\n        \"\"\"",
                "test_class": "CombinationCalculatorTestSelect2",
                "test_code": "class CombinationCalculatorTestSelect2(unittest.TestCase):\n    def test_select2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 2, 0, result)\n        self.assertEqual(result, [['A', 'B'], ['A', 'C'], ['A', 'D'], ['B', 'C'], ['B', 'D'], ['C', 'D']])\n\n    def test_select2_2(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 3, 0, result)\n        self.assertEqual(result, [['A', 'B', 'C'], ['A', 'B', 'D'], ['A', 'C', 'D'], ['B', 'C', 'D']])\n\n    def test_select2_3(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 1, 0, result)\n        self.assertEqual(result, [['A'], ['B'], ['C'], ['D']])\n\n    def test_select2_4(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 0, 0, result)\n        self.assertEqual(result, [[]])\n\n    def test_select2_5(self):\n        calc = CombinationCalculator([\"A\", \"B\", \"C\", \"D\"])\n        result = []\n        calc._select(0, [None] * 4, 0, result)\n        self.assertEqual(result, [['A', 'B', 'C', 'D']])",
                "solution_code": "def _select(self, dataIndex: int, resultList: List[str], resultIndex: int, result: List[List[str]]):\n        resultLen = len(resultList)\n        resultCount = resultIndex + 1\n        if resultCount > resultLen:\n            result.append(resultList.copy())\n            return\n\n        for i in range(dataIndex, len(self.datas) + resultCount - resultLen):\n            resultList[resultIndex] = self.datas[i]\n            self._select(i + 1, resultList, resultIndex + 1, result)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "List"
                    ],
                    "field_dependencies": [
                        "self.datas"
                    ],
                    "method_dependencies": [
                        "select"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_25",
        "skeleton": "import json\n\nclass CookiesUtil:\n    \"\"\"\n    This is a class as utility for managing and manipulating Cookies, including methods for retrieving, saving, and setting Cookies data.\n    \"\"\"\n\n    def __init__(self, cookies_file):\n        \"\"\"\n        Initializes the CookiesUtil with the specified cookies file.\n        :param cookies_file: The cookies file to use, str.\n        \"\"\"\n        self.cookies_file = cookies_file\n        self.cookies = None\n\n    def get_cookies(self, reponse):\n        \"\"\"\n        Gets the cookies from the specified response,and save it to cookies_file.\n        :param reponse: The response to get cookies from, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.get_cookies({'cookies': {'key1': 'value1', 'key2': 'value2'}})\n        >>> cookies_util.cookies\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n\n    def load_cookies(self):\n        \"\"\"\n        Loads the cookies from the cookies_file to the cookies data.\n        :return: The cookies data, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.load_cookies()\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"\n\n    def _save_cookies(self):\n        \"\"\"\n        Saves the cookies to the cookies_file, and returns True if successful, False otherwise.\n        :return: True if successful, False otherwise.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.cookies = {'key1': 'value1', 'key2': 'value2'}\n        >>> cookies_util._save_cookies()\n        True\n\n        \"\"\"",
        "test": "import unittest\n\n\nclass CookiesUtilTestGetCookies(unittest.TestCase):\n\n    def test_get_cookies(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.response = {'cookies': {'key1': 'value1', 'key2': 'value2'}}\n        self.cookies_util.get_cookies(self.response)\n        self.assertEqual(self.cookies_util.cookies, {'key1': 'value1', 'key2': 'value2'})\n\n    def test_get_cookies_2(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.response = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                         'cookies2': {'key3': 'value3', 'key4': 'value4'}}\n        self.cookies_util.get_cookies(self.response)\n        self.assertEqual(self.cookies_util.cookies, {'key1': 'value1', 'key2': 'value2'})\n\n    def test_get_cookies_3(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.response = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                         'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                         'cookies3': {'key5': 'value5', 'key6': 'value6'}}\n        self.cookies_util.get_cookies(self.response)\n        self.assertEqual(self.cookies_util.cookies, {'key1': 'value1', 'key2': 'value2'})\n\n    def test_get_cookies_4(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.response = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                         'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                         'cookies3': {'key5': 'value5', 'key6': 'value6'},\n                         'cookies4': {'key7': 'value7', 'key8': 'value8'}}\n        self.cookies_util.get_cookies(self.response)\n        self.assertEqual(self.cookies_util.cookies, {'key1': 'value1', 'key2': 'value2'})\n\n    def test_get_cookies_5(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.response = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                         'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                         'cookies3': {'key5': 'value5', 'key6': 'value6'},\n                         'cookies4': {'key7': 'value7', 'key8': 'value8'},\n                         'cookies5': {'key9': 'value9', 'key10': 'value10'}}\n        self.cookies_util.get_cookies(self.response)\n        self.assertEqual(self.cookies_util.cookies, {'key1': 'value1', 'key2': 'value2'})\n\n\nclass CookiesUtilTestLoadCookies(unittest.TestCase):\n\n    def test_load_cookies(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.assertEqual(self.cookies_util.load_cookies(), {'key1': 'value1', 'key2': 'value2'})\n\n    def test_load_cookies_2(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'}}\n        self.assertEqual(self.cookies_util.load_cookies(), {'key1': 'value1', 'key2': 'value2'})\n\n    def test_load_cookies_3(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'}}\n        self.assertEqual(self.cookies_util.load_cookies(), {'key1': 'value1', 'key2': 'value2'})\n\n    def test_load_cookies_4(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                                     'cookies3': {'key5': 'value5', 'key6': 'value6'}}\n        self.assertEqual(self.cookies_util.load_cookies(), {'key1': 'value1', 'key2': 'value2'})\n\n    def test_load_cookies_5(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                                     'cookies3': {'key5': 'value5', 'key6': 'value6'},\n                                     'cookies4': {'key7': 'value7', 'key8': 'value8'}}\n        self.assertEqual(self.cookies_util.load_cookies(), {'key1': 'value1', 'key2': 'value2'})\n\n    def test_load_cookies_6(self):\n        self.cookies_util = CookiesUtil('')\n        self.assertEqual(self.cookies_util.load_cookies(), {})\n\n\nclass CookiesUtilTestSaveCookies(unittest.TestCase):\n    def setUp(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'}}\n\n    def test_save_cookies(self):\n        self.assertTrue(self.cookies_util._save_cookies())\n\n    def test_save_cookies_2(self):\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'}}\n        self.assertTrue(self.cookies_util._save_cookies())\n\n    def test_save_cookies_3(self):\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                                     'cookies3': {'key5': 'value5', 'key6': 'value6'}}\n        self.assertTrue(self.cookies_util._save_cookies())\n\n    def test_save_cookies_4(self):\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                                     'cookies3': {'key5': 'value5', 'key6': 'value6'},\n                                     'cookies4': {'key7': 'value7', 'key8': 'value8'}}\n        self.assertTrue(self.cookies_util._save_cookies())\n\n    def test_save_cookies_5(self):\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                                     'cookies3': {'key5': 'value5', 'key6': 'value6'},\n                                     'cookies4': {'key7': 'value7', 'key8': 'value8'},\n                                     'cookies5': {'key9': 'value9', 'key10': 'value10'}}\n        self.assertTrue(self.cookies_util._save_cookies())\n\n    def test_save_cookies_6(self):\n        self.cookies_util = CookiesUtil('')\n        self.assertFalse(self.cookies_util._save_cookies())\n\n\nclass CookiesUtilTestSetCookies(unittest.TestCase):\n    def setUp(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'}}\n\n    def test_set_cookies(self):\n        request = {}\n        self.cookies_util.set_cookies(request)\n        self.assertEqual(request['cookies'], \"cookies={'key1': 'value1', 'key2': 'value2'}\")\n\n\nclass CookiesUtilTestMain(unittest.TestCase):\n    def setUp(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.cookies_data = {'cookies': {'key1': 'value1', 'key2': 'value2'}}\n\n    def test_main(self):\n        self.cookies_util.get_cookies(self.cookies_data)\n        self.assertEqual(self.cookies_util.cookies, {'key1': 'value1', 'key2': 'value2'})\n        self.assertEqual(self.cookies_util.load_cookies(), {'key1': 'value1', 'key2': 'value2'})\n        self.assertTrue(self.cookies_util._save_cookies())",
        "solution_code": "import json\n\nclass CookiesUtil:\n    def __init__(self, cookies_file):\n        self.cookies_file = cookies_file\n        self.cookies = None\n\n    def get_cookies(self, reponse):\n        self.cookies = reponse['cookies']\n        self._save_cookies()\n\n    def load_cookies(self):\n        try:\n            with open(self.cookies_file, 'r') as file:\n                cookies_data = json.load(file)\n                return cookies_data\n        except FileNotFoundError:\n            return {}\n\n    def _save_cookies(self):\n        try:\n            with open(self.cookies_file, 'w') as file:\n                json.dump(self.cookies, file)\n            return True\n        except:\n            return False\n\n    def set_cookies(self, request):\n        request['cookies'] = '; '.join([f'{key}={value}' for key, value in self.cookies.items()])",
        "import_statement": [
            "import json"
        ],
        "class_description": "    \"\"\"\n    This is a class as utility for managing and manipulating Cookies, including methods for retrieving, saving, and setting Cookies data.\n    \"\"\"\n",
        "class_name": "CookiesUtil",
        "test_classes": [
            "CookiesUtilTestGetCookies",
            "CookiesUtilTestLoadCookies",
            "CookiesUtilTestSaveCookies",
            "CookiesUtilTestSetCookies",
            "CookiesUtilTestMain"
        ],
        "class_constructor": "class CookiesUtil: \n    def __init__(self, cookies_file):\n        \"\"\"\n        Initializes the CookiesUtil with the specified cookies file.\n        :param cookies_file: The cookies file to use, str.\n        \"\"\"\n        self.cookies_file = cookies_file\n        self.cookies = None\n\n",
        "fields": [
            "self.cookies",
            "self.cookies_file"
        ],
        "methods_info": [
            {
                "method_name": "get_cookies",
                "method_description": "def get_cookies(self, reponse):\n        \"\"\"\n        Gets the cookies from the specified response,and save it to cookies_file.\n        :param reponse: The response to get cookies from, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.get_cookies({'cookies': {'key1': 'value1', 'key2': 'value2'}})\n        >>> cookies_util.cookies\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"",
                "test_class": "CookiesUtilTestGetCookies",
                "test_code": "class CookiesUtilTestGetCookies(unittest.TestCase):\n\n    def test_get_cookies(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.response = {'cookies': {'key1': 'value1', 'key2': 'value2'}}\n        self.cookies_util.get_cookies(self.response)\n        self.assertEqual(self.cookies_util.cookies, {'key1': 'value1', 'key2': 'value2'})\n\n    def test_get_cookies_2(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.response = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                         'cookies2': {'key3': 'value3', 'key4': 'value4'}}\n        self.cookies_util.get_cookies(self.response)\n        self.assertEqual(self.cookies_util.cookies, {'key1': 'value1', 'key2': 'value2'})\n\n    def test_get_cookies_3(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.response = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                         'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                         'cookies3': {'key5': 'value5', 'key6': 'value6'}}\n        self.cookies_util.get_cookies(self.response)\n        self.assertEqual(self.cookies_util.cookies, {'key1': 'value1', 'key2': 'value2'})\n\n    def test_get_cookies_4(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.response = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                         'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                         'cookies3': {'key5': 'value5', 'key6': 'value6'},\n                         'cookies4': {'key7': 'value7', 'key8': 'value8'}}\n        self.cookies_util.get_cookies(self.response)\n        self.assertEqual(self.cookies_util.cookies, {'key1': 'value1', 'key2': 'value2'})\n\n    def test_get_cookies_5(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.response = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                         'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                         'cookies3': {'key5': 'value5', 'key6': 'value6'},\n                         'cookies4': {'key7': 'value7', 'key8': 'value8'},\n                         'cookies5': {'key9': 'value9', 'key10': 'value10'}}\n        self.cookies_util.get_cookies(self.response)\n        self.assertEqual(self.cookies_util.cookies, {'key1': 'value1', 'key2': 'value2'})",
                "solution_code": "def get_cookies(self, reponse):\n        self.cookies = reponse['cookies']\n        self._save_cookies()",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.cookies"
                    ],
                    "method_dependencies": [
                        "_save_cookies"
                    ]
                }
            },
            {
                "method_name": "load_cookies",
                "method_description": "def load_cookies(self):\n        \"\"\"\n        Loads the cookies from the cookies_file to the cookies data.\n        :return: The cookies data, dict.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.load_cookies()\n        {'key1': 'value1', 'key2': 'value2'}\n\n        \"\"\"",
                "test_class": "CookiesUtilTestLoadCookies",
                "test_code": "class CookiesUtilTestLoadCookies(unittest.TestCase):\n\n    def test_load_cookies(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.assertEqual(self.cookies_util.load_cookies(), {'key1': 'value1', 'key2': 'value2'})\n\n    def test_load_cookies_2(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'}}\n        self.assertEqual(self.cookies_util.load_cookies(), {'key1': 'value1', 'key2': 'value2'})\n\n    def test_load_cookies_3(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'}}\n        self.assertEqual(self.cookies_util.load_cookies(), {'key1': 'value1', 'key2': 'value2'})\n\n    def test_load_cookies_4(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                                     'cookies3': {'key5': 'value5', 'key6': 'value6'}}\n        self.assertEqual(self.cookies_util.load_cookies(), {'key1': 'value1', 'key2': 'value2'})\n\n    def test_load_cookies_5(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                                     'cookies3': {'key5': 'value5', 'key6': 'value6'},\n                                     'cookies4': {'key7': 'value7', 'key8': 'value8'}}\n        self.assertEqual(self.cookies_util.load_cookies(), {'key1': 'value1', 'key2': 'value2'})\n\n    def test_load_cookies_6(self):\n        self.cookies_util = CookiesUtil('')\n        self.assertEqual(self.cookies_util.load_cookies(), {})",
                "solution_code": "def load_cookies(self):\n        try:\n            with open(self.cookies_file, 'r') as file:\n                cookies_data = json.load(file)\n                return cookies_data\n        except FileNotFoundError:\n            return {}",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "json"
                    ],
                    "field_dependencies": [
                        "self.cookies",
                        "self.cookies_file"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "_save_cookies",
                "method_description": "def _save_cookies(self):\n        \"\"\"\n        Saves the cookies to the cookies_file, and returns True if successful, False otherwise.\n        :return: True if successful, False otherwise.\n        >>> cookies_util = CookiesUtil('cookies.json')\n        >>> cookies_util.cookies = {'key1': 'value1', 'key2': 'value2'}\n        >>> cookies_util._save_cookies()\n        True\n\n        \"\"\"",
                "test_class": "CookiesUtilTestSaveCookies",
                "test_code": "class CookiesUtilTestSaveCookies(unittest.TestCase):\n    def setUp(self):\n        self.cookies_util = CookiesUtil('cookies.json')\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'}}\n\n    def test_save_cookies(self):\n        self.assertTrue(self.cookies_util._save_cookies())\n\n    def test_save_cookies_2(self):\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'}}\n        self.assertTrue(self.cookies_util._save_cookies())\n\n    def test_save_cookies_3(self):\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                                     'cookies3': {'key5': 'value5', 'key6': 'value6'}}\n        self.assertTrue(self.cookies_util._save_cookies())\n\n    def test_save_cookies_4(self):\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                                     'cookies3': {'key5': 'value5', 'key6': 'value6'},\n                                     'cookies4': {'key7': 'value7', 'key8': 'value8'}}\n        self.assertTrue(self.cookies_util._save_cookies())\n\n    def test_save_cookies_5(self):\n        self.cookies_util.cookies = {'cookies': {'key1': 'value1', 'key2': 'value2'},\n                                     'cookies2': {'key3': 'value3', 'key4': 'value4'},\n                                     'cookies3': {'key5': 'value5', 'key6': 'value6'},\n                                     'cookies4': {'key7': 'value7', 'key8': 'value8'},\n                                     'cookies5': {'key9': 'value9', 'key10': 'value10'}}\n        self.assertTrue(self.cookies_util._save_cookies())\n\n    def test_save_cookies_6(self):\n        self.cookies_util = CookiesUtil('')\n        self.assertFalse(self.cookies_util._save_cookies())",
                "solution_code": "def _save_cookies(self):\n        try:\n            with open(self.cookies_file, 'w') as file:\n                json.dump(self.cookies, file)\n            return True\n        except:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "json"
                    ],
                    "field_dependencies": [
                        "self.cookies",
                        "self.cookies_file"
                    ],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_26",
        "skeleton": "import csv\n\nclass CSVProcessor:\n    \"\"\"\n    This is a class for processing CSV files, including readring and writing CSV data, as well as processing specific operations and saving as a new CSV file.\n    \"\"\"\n\n\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        \"\"\"\n        Read the csv file by file_name, get the title and data from it\n        :param file_name: str, name of the csv file\n        :return title, data: (list, list), first row is title, the rest is data\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        \"\"\"\n\n    def write_csv(self, data, file_name):\n        \"\"\"\n        Write data into a csv file.\n        :param file_name: str, name of the csv file\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.write_csv([['a', 'b', 'c', 'd'], ['1', '2', '3', '4']], 'write_test.csv')\n        1\n        \"\"\"\n\n    def process_csv_data(self, N, save_file_name):\n        \"\"\"\n        Read a csv file into variable title and data.\n        Only remain the N th (from 0) column data and Capitalize them, store the title and new data into a new csv file.\n        Add '_process' suffix after old file name, as a new file name.\n        :param N: int, the N th column(from 0)\n        :param save_file_name, the name of file that needs to be processed.\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        >>> csvProcessor.process_csv_data(0, 'read_test.csv')\n        1\n        >>> csvProcessor.read_csv('read_test_process.csv')\n        (['a', 'b', 'c', 'd'], [['HELLO']])\n        \"\"\"",
        "test": "import unittest\nimport os\n\n\nclass CSVProcessorTestReadCSV(unittest.TestCase):\n    def test_read_csv_1(self):\n        self.file = 'read_test.csv'\n\n        with open(self.file, 'w') as f:\n            f.write('a,b,c,d\\nhElLo,YoU,ME,LoW')\n\n        expected_title = ['a', 'b', 'c', 'd']\n        expected_data = [['hElLo', 'YoU', 'ME', 'LoW']]\n        csvProcessor = CSVProcessor()\n        title, data = csvProcessor.read_csv(self.file)\n        self.assertEqual(expected_data, data)\n        self.assertEqual(expected_title, title)\n\n    def test_read_csv_2(self):\n        self.file = 'read_test.csv'\n        with open(self.file, 'w') as f:\n            f.write('1234\\nhElLo,YoU,ME,LoW')\n\n        expected_title = ['1234']\n        expected_data = [['hElLo', 'YoU', 'ME', 'LoW']]\n        csvProcessor = CSVProcessor()\n        title, data = csvProcessor.read_csv(self.file)\n        self.assertEqual(expected_data, data)\n        self.assertEqual(expected_title, title)\n\n    def test_read_csv_3(self):\n        self.file = 'read_test.csv'\n\n        with open(self.file, 'w') as f:\n            f.write('title\\nhElLo,YoU,ME,LoW')\n\n        expected_title = ['title']\n        expected_data = [['hElLo', 'YoU', 'ME', 'LoW']]\n        csvProcessor = CSVProcessor()\n        title, data = csvProcessor.read_csv(self.file)\n        self.assertEqual(expected_data, data)\n        self.assertEqual(expected_title, title)\n\n    def test_read_csv_4(self):\n        self.file = 'read_test.csv'\n\n        with open(self.file, 'w') as f:\n            f.write('title4\\nhElLo,YoU,ME,LoW')\n\n        expected_title = ['title4']\n        expected_data = [['hElLo', 'YoU', 'ME', 'LoW']]\n        csvProcessor = CSVProcessor()\n        title, data = csvProcessor.read_csv(self.file)\n        self.assertEqual(expected_data, data)\n        self.assertEqual(expected_title, title)\n\n    def test_read_csv_5(self):\n        self.file = 'read_test.csv'\n\n        with open(self.file, 'w') as f:\n            f.write('title5\\nhElLo,YoU,ME,LoW')\n\n        expected_title = ['title5']\n        expected_data = [['hElLo', 'YoU', 'ME', 'LoW']]\n        csvProcessor = CSVProcessor()\n        title, data = csvProcessor.read_csv(self.file)\n        self.assertEqual(expected_data, data)\n        self.assertEqual(expected_title, title)\n\n\nclass CSVProcessorTestWriteCSV(unittest.TestCase):\n    def test_write_csv_1(self):\n        self.file = 'read_test.csv'\n\n        file_path = self.file\n        csvProcessor = CSVProcessor()\n        data = [['a', 'b', 'c', 'd'], ['1', '2', '3', '4']]\n        # assert return value\n        self.assertEqual(1, csvProcessor.write_csv(data, file_path))\n\n        # read to test if write correctly\n        read_title, read_data = csvProcessor.read_csv(file_path)\n        self.assertEqual(read_title, data[0])\n        self.assertEqual(read_data[0], data[1])\n        os.remove(file_path)\n\n    def test_write_csv_2(self):\n        self.file = 'read_test.csv'\n\n        file_path = self.file\n        csvProcessor = CSVProcessor()\n        data = [['aa', 'bb', 'cc', 'dd'], ['1', '2', '3', '4']]\n        # assert return value\n        self.assertEqual(1, csvProcessor.write_csv(data, file_path))\n\n        # read to test if write correctly\n        read_title, read_data = csvProcessor.read_csv(file_path)\n        self.assertEqual(read_title, data[0])\n        self.assertEqual(read_data[0], data[1])\n        os.remove(file_path)\n\n    def test_write_csv_3(self):\n        self.file = 'read_test.csv'\n\n        file_path = self.file\n        csvProcessor = CSVProcessor()\n        data = [['a', 'b', 'c', 'd'], ['11', '22', '33', '44']]\n        # assert return value\n        self.assertEqual(1, csvProcessor.write_csv(data, file_path))\n\n        # read to test if write correctly\n        read_title, read_data = csvProcessor.read_csv(file_path)\n        self.assertEqual(read_title, data[0])\n        self.assertEqual(read_data[0], data[1])\n        os.remove(file_path)\n\n    def test_write_csv_4(self):\n        self.file = 'read_test.csv'\n\n        file_path = self.file\n        csvProcessor = CSVProcessor()\n        data = [['e', 'f', 'g', 'h'], ['1', '2', '3', '4']]\n        # assert return value\n        self.assertEqual(1, csvProcessor.write_csv(data, file_path))\n\n        # read to test if write correctly\n        read_title, read_data = csvProcessor.read_csv(file_path)\n        self.assertEqual(read_title, data[0])\n        self.assertEqual(read_data[0], data[1])\n        os.remove(file_path)\n\n    def test_write_csv_5(self):\n        self.file = 'read_test.csv'\n\n        file_path = self.file\n        csvProcessor = CSVProcessor()\n        data = [['a', 'b', 'c', 'd'], ['5', '6', '7', '8']]\n        # assert return value\n        self.assertEqual(1, csvProcessor.write_csv(data, file_path))\n\n        # read to test if write correctly\n        read_title, read_data = csvProcessor.read_csv(file_path)\n        self.assertEqual(read_title, data[0])\n        self.assertEqual(read_data[0], data[1])\n        os.remove(file_path)\n\n    def test_write_csv_6(self):\n        self.file = ''\n        file_path = self.file\n        csvProcessor = CSVProcessor()\n        # assert return value\n        self.assertEqual(0, csvProcessor.write_csv([], file_path))\n\n\nclass CSVProcessorTestProcessCSVData(unittest.TestCase):\n    def setUp(self) -> None:\n        self.file = 'read_test.csv'\n        self.file_process = 'read_test_process.csv'\n        with open(self.file, 'w') as f:\n            f.write('a,b,c,d\\nhElLo,YoU,ME,LoW,aBc')\n\n    def test_process_csv_data_1(self):\n        title = ['a', 'b', 'c', 'd']\n        data = ['HELLO']\n        csvProcessor = CSVProcessor()\n        self.assertEqual(1, csvProcessor.process_csv_data(0, self.file))\n\n        read_title, read_data = csvProcessor.read_csv(self.file_process)\n        self.assertEqual(read_title, title)\n        self.assertEqual(read_data[0], data)\n\n    def test_process_csv_data_2(self):\n        title = ['a', 'b', 'c', 'd']\n        data = ['YOU']\n        csvProcessor = CSVProcessor()\n        self.assertEqual(1, csvProcessor.process_csv_data(1, self.file))\n\n        read_title, read_data = csvProcessor.read_csv(self.file_process)\n        self.assertEqual(read_title, title)\n        self.assertEqual(read_data[0], data)\n\n    def test_process_csv_data_3(self):\n        title = ['a', 'b', 'c', 'd']\n        data = ['ME']\n        csvProcessor = CSVProcessor()\n        self.assertEqual(1, csvProcessor.process_csv_data(2, self.file))\n\n        read_title, read_data = csvProcessor.read_csv(self.file_process)\n        self.assertEqual(read_title, title)\n        self.assertEqual(read_data[0], data)\n\n    def test_process_csv_data_4(self):\n        title = ['a', 'b', 'c', 'd']\n        data = ['LOW']\n        csvProcessor = CSVProcessor()\n        self.assertEqual(1, csvProcessor.process_csv_data(3, self.file))\n\n        read_title, read_data = csvProcessor.read_csv(self.file_process)\n        self.assertEqual(read_title, title)\n        self.assertEqual(read_data[0], data)\n\n    def test_process_csv_data_5(self):\n        title = ['a', 'b', 'c', 'd']\n        data = ['ABC']\n        csvProcessor = CSVProcessor()\n        self.assertEqual(1, csvProcessor.process_csv_data(4, self.file))\n\n        read_title, read_data = csvProcessor.read_csv(self.file_process)\n        self.assertEqual(read_title, title)\n        self.assertEqual(read_data[0], data)\n\n\nclass CSVProcessorTestMain(unittest.TestCase):\n    def setUp(self) -> None:\n        self.file = 'test.csv'\n        self.file_process = 'test_process.csv'\n        with open(self.file, 'w') as f:\n            f.write('a,b,c,d\\nhElLo,YoU,ME,LoW')\n\n    def test_main(self):\n        csvProcessor = CSVProcessor()\n        data = [['a', 'b', 'c', 'd'], ['hElLo', 'YoU', 'ME', 'LoW']]\n        # assert return value\n        self.assertEqual(1, csvProcessor.write_csv(data, self.file))\n        expected_title = ['a', 'b', 'c', 'd']\n        expected_data = [['hElLo', 'YoU', 'ME', 'LoW']]\n        title, data = csvProcessor.read_csv(self.file)\n        self.assertEqual(expected_data, data)\n        self.assertEqual(expected_title, title)\n\n        title = ['a', 'b', 'c', 'd']\n        data = ['HELLO']\n        self.assertEqual(1, csvProcessor.process_csv_data(0, self.file))\n\n        read_title, read_data = csvProcessor.read_csv(self.file_process)\n        self.assertEqual(read_title, title)\n        self.assertEqual(read_data[0], data)",
        "solution_code": "import csv\n\n\nclass CSVProcessor:\n\n    def __init__(self):\n        pass\n\n    def read_csv(self, file_name):\n        data = []\n        with open(file_name, 'r') as file:\n            reader = csv.reader(file)\n            title = next(reader)\n            for row in reader:\n                data.append(row)\n        return title, data\n\n    def write_csv(self, data, file_name):\n        try:\n            with open(file_name, 'w', newline='') as file:\n                writer = csv.writer(file)\n                writer.writerows(data)\n            return 1\n        except:\n            return 0\n\n    def process_csv_data(self, N, save_file_name):\n        title, data = self.read_csv(save_file_name)\n        column_data = [row[N] for row in data]\n        column_data = [row.upper() for row in column_data]\n        new_data = [title, column_data]\n        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')",
        "import_statement": [
            "import csv"
        ],
        "class_description": "    \"\"\"\n    This is a class for processing CSV files, including readring and writing CSV data, as well as processing specific operations and saving as a new CSV file.\n    \"\"\"\n",
        "class_name": "CSVProcessor",
        "test_classes": [
            "CSVProcessorTestReadCSV",
            "CSVProcessorTestWriteCSV",
            "CSVProcessorTestProcessCSVData",
            "CSVProcessorTestMain"
        ],
        "class_constructor": "class CSVProcessor: \n    def __init__(self):\n        pass\n\n",
        "fields": [],
        "methods_info": [
            {
                "method_name": "read_csv",
                "method_description": "def read_csv(self, file_name):\n        \"\"\"\n        Read the csv file by file_name, get the title and data from it\n        :param file_name: str, name of the csv file\n        :return title, data: (list, list), first row is title, the rest is data\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        \"\"\"",
                "test_class": "CSVProcessorTestReadCSV",
                "test_code": "class CSVProcessorTestReadCSV(unittest.TestCase):\n    def test_read_csv_1(self):\n        self.file = 'read_test.csv'\n\n        with open(self.file, 'w') as f:\n            f.write('a,b,c,d\\nhElLo,YoU,ME,LoW')\n\n        expected_title = ['a', 'b', 'c', 'd']\n        expected_data = [['hElLo', 'YoU', 'ME', 'LoW']]\n        csvProcessor = CSVProcessor()\n        title, data = csvProcessor.read_csv(self.file)\n        self.assertEqual(expected_data, data)\n        self.assertEqual(expected_title, title)\n\n    def test_read_csv_2(self):\n        self.file = 'read_test.csv'\n        with open(self.file, 'w') as f:\n            f.write('1234\\nhElLo,YoU,ME,LoW')\n\n        expected_title = ['1234']\n        expected_data = [['hElLo', 'YoU', 'ME', 'LoW']]\n        csvProcessor = CSVProcessor()\n        title, data = csvProcessor.read_csv(self.file)\n        self.assertEqual(expected_data, data)\n        self.assertEqual(expected_title, title)\n\n    def test_read_csv_3(self):\n        self.file = 'read_test.csv'\n\n        with open(self.file, 'w') as f:\n            f.write('title\\nhElLo,YoU,ME,LoW')\n\n        expected_title = ['title']\n        expected_data = [['hElLo', 'YoU', 'ME', 'LoW']]\n        csvProcessor = CSVProcessor()\n        title, data = csvProcessor.read_csv(self.file)\n        self.assertEqual(expected_data, data)\n        self.assertEqual(expected_title, title)\n\n    def test_read_csv_4(self):\n        self.file = 'read_test.csv'\n\n        with open(self.file, 'w') as f:\n            f.write('title4\\nhElLo,YoU,ME,LoW')\n\n        expected_title = ['title4']\n        expected_data = [['hElLo', 'YoU', 'ME', 'LoW']]\n        csvProcessor = CSVProcessor()\n        title, data = csvProcessor.read_csv(self.file)\n        self.assertEqual(expected_data, data)\n        self.assertEqual(expected_title, title)\n\n    def test_read_csv_5(self):\n        self.file = 'read_test.csv'\n\n        with open(self.file, 'w') as f:\n            f.write('title5\\nhElLo,YoU,ME,LoW')\n\n        expected_title = ['title5']\n        expected_data = [['hElLo', 'YoU', 'ME', 'LoW']]\n        csvProcessor = CSVProcessor()\n        title, data = csvProcessor.read_csv(self.file)\n        self.assertEqual(expected_data, data)\n        self.assertEqual(expected_title, title)",
                "solution_code": "def read_csv(self, file_name):\n        data = []\n        with open(file_name, 'r') as file:\n            reader = csv.reader(file)\n            title = next(reader)\n            for row in reader:\n                data.append(row)\n        return title, data",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "csv"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "write_csv",
                "method_description": "def write_csv(self, data, file_name):\n        \"\"\"\n        Write data into a csv file.\n        :param file_name: str, name of the csv file\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.write_csv([['a', 'b', 'c', 'd'], ['1', '2', '3', '4']], 'write_test.csv')\n        1\n        \"\"\"",
                "test_class": "CSVProcessorTestWriteCSV",
                "test_code": "class CSVProcessorTestWriteCSV(unittest.TestCase):\n    def test_write_csv_1(self):\n        self.file = 'read_test.csv'\n\n        file_path = self.file\n        csvProcessor = CSVProcessor()\n        data = [['a', 'b', 'c', 'd'], ['1', '2', '3', '4']]\n        # assert return value\n        self.assertEqual(1, csvProcessor.write_csv(data, file_path))\n\n        # read to test if write correctly\n        read_title, read_data = csvProcessor.read_csv(file_path)\n        self.assertEqual(read_title, data[0])\n        self.assertEqual(read_data[0], data[1])\n        os.remove(file_path)\n\n    def test_write_csv_2(self):\n        self.file = 'read_test.csv'\n\n        file_path = self.file\n        csvProcessor = CSVProcessor()\n        data = [['aa', 'bb', 'cc', 'dd'], ['1', '2', '3', '4']]\n        # assert return value\n        self.assertEqual(1, csvProcessor.write_csv(data, file_path))\n\n        # read to test if write correctly\n        read_title, read_data = csvProcessor.read_csv(file_path)\n        self.assertEqual(read_title, data[0])\n        self.assertEqual(read_data[0], data[1])\n        os.remove(file_path)\n\n    def test_write_csv_3(self):\n        self.file = 'read_test.csv'\n\n        file_path = self.file\n        csvProcessor = CSVProcessor()\n        data = [['a', 'b', 'c', 'd'], ['11', '22', '33', '44']]\n        # assert return value\n        self.assertEqual(1, csvProcessor.write_csv(data, file_path))\n\n        # read to test if write correctly\n        read_title, read_data = csvProcessor.read_csv(file_path)\n        self.assertEqual(read_title, data[0])\n        self.assertEqual(read_data[0], data[1])\n        os.remove(file_path)\n\n    def test_write_csv_4(self):\n        self.file = 'read_test.csv'\n\n        file_path = self.file\n        csvProcessor = CSVProcessor()\n        data = [['e', 'f', 'g', 'h'], ['1', '2', '3', '4']]\n        # assert return value\n        self.assertEqual(1, csvProcessor.write_csv(data, file_path))\n\n        # read to test if write correctly\n        read_title, read_data = csvProcessor.read_csv(file_path)\n        self.assertEqual(read_title, data[0])\n        self.assertEqual(read_data[0], data[1])\n        os.remove(file_path)\n\n    def test_write_csv_5(self):\n        self.file = 'read_test.csv'\n\n        file_path = self.file\n        csvProcessor = CSVProcessor()\n        data = [['a', 'b', 'c', 'd'], ['5', '6', '7', '8']]\n        # assert return value\n        self.assertEqual(1, csvProcessor.write_csv(data, file_path))\n\n        # read to test if write correctly\n        read_title, read_data = csvProcessor.read_csv(file_path)\n        self.assertEqual(read_title, data[0])\n        self.assertEqual(read_data[0], data[1])\n        os.remove(file_path)\n\n    def test_write_csv_6(self):\n        self.file = ''\n        file_path = self.file\n        csvProcessor = CSVProcessor()\n        # assert return value\n        self.assertEqual(0, csvProcessor.write_csv([], file_path))",
                "solution_code": "def write_csv(self, data, file_name):\n        try:\n            with open(file_name, 'w', newline='') as file:\n                writer = csv.writer(file)\n                writer.writerows(data)\n            return 1\n        except:\n            return 0",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "csv"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "process_csv_data",
                "method_description": "def process_csv_data(self, N, save_file_name):\n        \"\"\"\n        Read a csv file into variable title and data.\n        Only remain the N th (from 0) column data and Capitalize them, store the title and new data into a new csv file.\n        Add '_process' suffix after old file name, as a new file name.\n        :param N: int, the N th column(from 0)\n        :param save_file_name, the name of file that needs to be processed.\n        :return:int, if success return 1, or 0 otherwise\n        >>> csvProcessor = CSVProcessor()\n        >>> csvProcessor.read_csv('read_test.csv')\n        (['a', 'b', 'c', 'd'], [['hElLo', 'YoU', 'ME', 'LoW']])\n        >>> csvProcessor.process_csv_data(0, 'read_test.csv')\n        1\n        >>> csvProcessor.read_csv('read_test_process.csv')\n        (['a', 'b', 'c', 'd'], [['HELLO']])\n        \"\"\"",
                "test_class": "CSVProcessorTestProcessCSVData",
                "test_code": "class CSVProcessorTestProcessCSVData(unittest.TestCase):\n    def setUp(self) -> None:\n        self.file = 'read_test.csv'\n        self.file_process = 'read_test_process.csv'\n        with open(self.file, 'w') as f:\n            f.write('a,b,c,d\\nhElLo,YoU,ME,LoW,aBc')\n\n    def test_process_csv_data_1(self):\n        title = ['a', 'b', 'c', 'd']\n        data = ['HELLO']\n        csvProcessor = CSVProcessor()\n        self.assertEqual(1, csvProcessor.process_csv_data(0, self.file))\n\n        read_title, read_data = csvProcessor.read_csv(self.file_process)\n        self.assertEqual(read_title, title)\n        self.assertEqual(read_data[0], data)\n\n    def test_process_csv_data_2(self):\n        title = ['a', 'b', 'c', 'd']\n        data = ['YOU']\n        csvProcessor = CSVProcessor()\n        self.assertEqual(1, csvProcessor.process_csv_data(1, self.file))\n\n        read_title, read_data = csvProcessor.read_csv(self.file_process)\n        self.assertEqual(read_title, title)\n        self.assertEqual(read_data[0], data)\n\n    def test_process_csv_data_3(self):\n        title = ['a', 'b', 'c', 'd']\n        data = ['ME']\n        csvProcessor = CSVProcessor()\n        self.assertEqual(1, csvProcessor.process_csv_data(2, self.file))\n\n        read_title, read_data = csvProcessor.read_csv(self.file_process)\n        self.assertEqual(read_title, title)\n        self.assertEqual(read_data[0], data)\n\n    def test_process_csv_data_4(self):\n        title = ['a', 'b', 'c', 'd']\n        data = ['LOW']\n        csvProcessor = CSVProcessor()\n        self.assertEqual(1, csvProcessor.process_csv_data(3, self.file))\n\n        read_title, read_data = csvProcessor.read_csv(self.file_process)\n        self.assertEqual(read_title, title)\n        self.assertEqual(read_data[0], data)\n\n    def test_process_csv_data_5(self):\n        title = ['a', 'b', 'c', 'd']\n        data = ['ABC']\n        csvProcessor = CSVProcessor()\n        self.assertEqual(1, csvProcessor.process_csv_data(4, self.file))\n\n        read_title, read_data = csvProcessor.read_csv(self.file_process)\n        self.assertEqual(read_title, title)\n        self.assertEqual(read_data[0], data)",
                "solution_code": "def process_csv_data(self, N, save_file_name):\n        title, data = self.read_csv(save_file_name)\n        column_data = [row[N] for row in data]\n        column_data = [row.upper() for row in column_data]\n        new_data = [title, column_data]\n        return self.write_csv(new_data, save_file_name.split('.')[0] + '_process.csv')",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "csv"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "read_csv",
                        "write_csv"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_28",
        "skeleton": "import sqlite3\nimport pandas as pd\n\nclass DatabaseProcessor:\n    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n\n    def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"\n\n\n    def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"\n\n\n    def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"\n\n\n    def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"",
        "test": "import unittest\nimport sqlite3\n\n\nclass DatabaseProcessorTestCreateTable(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_create_table_1(self):\n        table_name = \"test_table\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_2(self):\n        table_name = \"test_table2\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_3(self):\n        table_name = \"test_table3\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_4(self):\n        table_name = \"test_table4\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_5(self):\n        table_name = \"test_table5\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n\nclass DatabaseProcessorTestInsertIntoDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_insert_into_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 25)\n\n    def test_insert_into_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 15},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 15)\n\n    def test_insert_into_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 16},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 16)\n\n    def test_insert_into_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 17},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 17)\n\n    def test_insert_into_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 18},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 18)\n\n\nclass DatabaseProcessorTestSearchDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_search_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'John')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n    def test_search_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'Alice')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_search_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'Bob')\n        self.assertIsNone(result)\n\n    def test_search_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'aaa')\n        self.assertIsNone(result)\n\n    def test_search_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'bbb')\n        self.assertIsNone(result)\n\n\nclass DatabaseProcessorTestDeteleFromDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_delete_from_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_delete_from_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'Alice')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n    def test_delete_from_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n        self.processor.delete_from_database(table_name, 'Alice')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_from_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'aaa', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_delete_from_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'bbb', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'bbb')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n\nclass DatabaseProcessorTest(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_DatabaseProcessor(self):\n        table_name = \"test_table\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 25)\n\n        result = self.processor.search_database(table_name, 'John')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')",
        "solution_code": "import sqlite3\nimport pandas as pd\n\n\nclass DatabaseProcessor:\n\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_table(self, table_name, key1, key2):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n\n    def insert_into_database(self, table_name, data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        for item in data:\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n            cursor.execute(insert_query, (item['name'], item['age']))\n\n        conn.commit()\n        conn.close()\n\n    def search_database(self, table_name, name):\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        select_query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n\n        if result:\n            return result\n        else:\n            return None\n\n    def delete_from_database(self, table_name, name):\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        conn.commit()\n        conn.close()",
        "import_statement": [
            "import sqlite3",
            "import pandas as pd"
        ],
        "class_description": "    \"\"\"\n    This is a class for processing a database, supporting to create tables, insert data into the database, search for data based on name, and delete data from the database.\n    \"\"\"\n",
        "class_name": "DatabaseProcessor",
        "test_classes": [
            "DatabaseProcessorTestCreateTable",
            "DatabaseProcessorTestInsertIntoDatabase",
            "DatabaseProcessorTestSearchDatabase",
            "DatabaseProcessorTestDeteleFromDatabase",
            "DatabaseProcessorTest"
        ],
        "class_constructor": "class DatabaseProcessor: \n    def __init__(self, database_name):\n        \"\"\"\n        Initialize database name of database processor\n        \"\"\"\n        self.database_name = database_name\n\n\n",
        "fields": [
            "self.database_name"
        ],
        "methods_info": [
            {
                "method_name": "create_table",
                "method_description": "def create_table(self, table_name, key1, key2):\n        \"\"\"\n        Create a new table in the database if it doesn't exist.\n        And make id (INTEGER) as PRIMARY KEY, make key1 as TEXT, key2 as INTEGER\n        :param table_name: str, the name of the table to create.\n        :param key1: str, the name of the first column in the table.\n        :param key2: str, the name of the second column in the table.\n        >>> db.create_table('user', 'name', 'age')\n        \"\"\"",
                "test_class": "DatabaseProcessorTestCreateTable",
                "test_code": "class DatabaseProcessorTestCreateTable(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_create_table_1(self):\n        table_name = \"test_table\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_2(self):\n        table_name = \"test_table2\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_3(self):\n        table_name = \"test_table3\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_4(self):\n        table_name = \"test_table4\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)\n\n    def test_create_table_5(self):\n        table_name = \"test_table5\"\n        self.processor.create_table(table_name, 'name', 'age')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT name FROM sqlite_master WHERE type='table' AND name=?\", (table_name,))\n        result = cursor.fetchone()\n        conn.close()\n\n        self.assertIsNotNone(result)\n        self.assertEqual(result[0], table_name)",
                "solution_code": "def create_table(self, table_name, key1, key2):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        create_table_query = f\"CREATE TABLE IF NOT EXISTS {table_name} (id INTEGER PRIMARY KEY, {key1} TEXT, {key2} INTEGER)\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "sqlite3"
                    ],
                    "field_dependencies": [
                        "self.database_name"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "insert_into_database",
                "method_description": "def insert_into_database(self, table_name, data):\n        \"\"\"\n        Insert data into the specified table in the database.\n        :param table_name: str, the name of the table to insert data into.\n        :param data: list, a list of dictionaries where each dictionary represents a row of data.\n        >>> db.insert_into_database('user', [\n                {'name': 'John', 'age': 25},\n                {'name': 'Alice', 'age': 30}\n            ])\n        \"\"\"",
                "test_class": "DatabaseProcessorTestInsertIntoDatabase",
                "test_code": "class DatabaseProcessorTestInsertIntoDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_insert_into_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 25)\n\n    def test_insert_into_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 15},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 15)\n\n    def test_insert_into_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 16},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 16)\n\n    def test_insert_into_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 17},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 17)\n\n    def test_insert_into_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 18},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), len(data))\n        self.assertEqual(result[0][2], 18)",
                "solution_code": "def insert_into_database(self, table_name, data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        for item in data:\n            insert_query = f\"INSERT INTO {table_name} (name, age) VALUES (?, ?)\"\n            cursor.execute(insert_query, (item['name'], item['age']))\n\n        conn.commit()\n        conn.close()",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "sqlite3"
                    ],
                    "field_dependencies": [
                        "self.database_name"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "search_database",
                "method_description": "def search_database(self, table_name, name):\n        \"\"\"\n        Search the specified table in the database for rows with a matching name.\n        :param table_name: str, the name of the table to search.\n        :param name: str, the name to search for.\n        :return: list, a list of tuples representing the rows with matching name, if any;\n                    otherwise, returns None.\n        >>> db.search_database('user', 'John')\n        [(1, 'John', 25)]\n        \"\"\"",
                "test_class": "DatabaseProcessorTestSearchDatabase",
                "test_code": "class DatabaseProcessorTestSearchDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_search_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'John')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n    def test_search_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'Alice')\n        self.assertIsNotNone(result)\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_search_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'Bob')\n        self.assertIsNone(result)\n\n    def test_search_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'aaa')\n        self.assertIsNone(result)\n\n    def test_search_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        result = self.processor.search_database(table_name, 'bbb')\n        self.assertIsNone(result)",
                "solution_code": "def search_database(self, table_name, name):\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        select_query = f\"SELECT * FROM {table_name} WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n\n        if result:\n            return result\n        else:\n            return None",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "sqlite3"
                    ],
                    "field_dependencies": [
                        "self.database_name"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "delete_from_database",
                "method_description": "def delete_from_database(self, table_name, name):\n        \"\"\"\n        Delete rows from the specified table in the database with a matching name.\n        :param table_name: str, the name of the table to delete rows from.\n        :param name: str, the name to match for deletion.\n        >>> db.delete_from_database('user', 'John')\n        \"\"\"",
                "test_class": "DatabaseProcessorTestDeteleFromDatabase",
                "test_code": "class DatabaseProcessorTestDeteleFromDatabase(unittest.TestCase):\n    def setUp(self):\n        self.database_name = \"test.db\"\n        self.processor = DatabaseProcessor(self.database_name)\n\n    def tearDown(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(\"DROP TABLE IF EXISTS test_table\")\n        conn.commit()\n        conn.close()\n\n    def test_delete_from_database_1(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_delete_from_database_2(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'Alice')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'John')\n\n    def test_delete_from_database_3(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n        self.processor.delete_from_database(table_name, 'Alice')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_from_database_4(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'John', 'age': 25},\n            {'name': 'aaa', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'John')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_delete_from_database_5(self):\n        table_name = \"test_table\"\n        data = [\n            {'name': 'bbb', 'age': 25},\n            {'name': 'Alice', 'age': 30}\n        ]\n        self.processor.create_table(table_name, 'name', 'age')\n        self.processor.insert_into_database(table_name, data)\n\n        self.processor.delete_from_database(table_name, 'bbb')\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n        cursor.execute(f\"SELECT * FROM {table_name}\")\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')",
                "solution_code": "def delete_from_database(self, table_name, name):\n\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        delete_query = f\"DELETE FROM {table_name} WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        conn.commit()\n        conn.close()",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "sqlite3"
                    ],
                    "field_dependencies": [
                        "self.database_name"
                    ],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_29",
        "skeleton": "from collections import Counter\n\nclass DataStatistics:\n    \"\"\"\n    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.\n    \"\"\"\n\n    def mean(self, data):\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the mean value\n        >>> ds = DataStatistics()\n        >>> ds.mean([1, 2, 3, 4, 5])\n        3.00\n        \"\"\"\n\n    def median(self, data):\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the median value\n        >>> ds = DataStatistics()\n        >>> ds.median([2, 5, 1, 3, 4])\n        3.00\n        \"\"\"\n\n    def mode(self, data):\n        \"\"\"\n        Calculate the mode of a set of data\n        :param data:list, data list\n        :return:float, the mode\n        >>> ds = DataStatistics()\n        >>> ds.mode([2, 2, 3, 3, 4])\n        [2, 3]\n        \"\"\"",
        "test": "import unittest\n\n\nclass DataStatisticsTestMean(unittest.TestCase):\n    def test_mean_1(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 3, 4, 5])\n        self.assertEqual(res, 3.00)\n\n    def test_mean_2(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 3, 4, 5, 6])\n        self.assertEqual(res, 3.50)\n\n    def test_mean_3(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7])\n        self.assertEqual(res, 4.17)\n\n    def test_mean_4(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7, 8])\n        self.assertEqual(res, 4.71)\n\n    def test_mean_5(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7, 8, 9])\n        self.assertEqual(res, 5.25)\n\n\nclass DataStatisticsTestMedian(unittest.TestCase):\n    def test_median_1(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 3, 4])\n        self.assertEqual(res, 3)\n\n    def test_median_2(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 3, 4, 6])\n        self.assertEqual(res, 3.50)\n\n    def test_median_3(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7])\n        self.assertEqual(res, 4.5)\n\n    def test_median_4(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7, 8])\n        self.assertEqual(res, 5)\n\n    def test_median_5(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7, 8, 9])\n        self.assertEqual(res, 5.5)\n\n\nclass DataStatisticsTestMode(unittest.TestCase):\n    def test_mode_1(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4])\n        self.assertEqual(res, [2, 3])\n\n    def test_mode_2(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 2, 3, 3, 4])\n        self.assertEqual(res, [2])\n\n    def test_mode_3(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4])\n        self.assertEqual(res, [2, 3, 4])\n\n    def test_mode_4(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4, 4])\n        self.assertEqual(res, [4])\n\n    def test_mode_5(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4, 4, 5])\n        self.assertEqual(res, [4])\n\n\nclass DataStatisticsTest(unittest.TestCase):\n    def test_datastatistics(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 3, 4, 5])\n        self.assertEqual(res, 3.00)\n        res = ds.median([2, 5, 1, 3, 4])\n        self.assertEqual(res, 3.00)\n        res = ds.mode([2, 2, 3, 3, 4])\n        self.assertEqual(res, [2, 3])",
        "solution_code": "from collections import Counter\n\n\nclass DataStatistics:\n    def mean(self, data):\n        return round(sum(data) / len(data), 2)\n\n    def median(self, data):\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 0:\n            middle = n // 2\n            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)\n        else:\n            middle = n // 2\n            return sorted_data[middle]\n\n    def mode(self, data):\n        counter = Counter(data)\n        mode_count = max(counter.values())\n        mode = [x for x, count in counter.items() if count == mode_count]\n        return mode",
        "import_statement": [
            "from collections import Counter"
        ],
        "class_description": "    \"\"\"\n    This is a class for performing data statistics, supporting to calculate the mean, median, and mode of a given data set.\n    \"\"\"\n",
        "class_name": "DataStatistics",
        "test_classes": [
            "DataStatisticsTestMean",
            "DataStatisticsTestMedian",
            "DataStatisticsTestMode",
            "DataStatisticsTest"
        ],
        "class_constructor": "class DataStatistics: \n",
        "fields": [],
        "methods_info": [
            {
                "method_name": "mean",
                "method_description": "def mean(self, data):\n        \"\"\"\n        Calculate the average value of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the mean value\n        >>> ds = DataStatistics()\n        >>> ds.mean([1, 2, 3, 4, 5])\n        3.00\n        \"\"\"",
                "test_class": "DataStatisticsTestMean",
                "test_code": "class DataStatisticsTestMean(unittest.TestCase):\n    def test_mean_1(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 3, 4, 5])\n        self.assertEqual(res, 3.00)\n\n    def test_mean_2(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 3, 4, 5, 6])\n        self.assertEqual(res, 3.50)\n\n    def test_mean_3(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7])\n        self.assertEqual(res, 4.17)\n\n    def test_mean_4(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7, 8])\n        self.assertEqual(res, 4.71)\n\n    def test_mean_5(self):\n        ds = DataStatistics()\n        res = ds.mean([1, 2, 4, 5, 6, 7, 8, 9])\n        self.assertEqual(res, 5.25)",
                "solution_code": "def mean(self, data):\n        return round(sum(data) / len(data), 2)",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "median",
                "method_description": "def median(self, data):\n        \"\"\"\n        Calculate the median of a group of data, accurate to two digits after the Decimal separator\n        :param data:list, data list\n        :return:float, the median value\n        >>> ds = DataStatistics()\n        >>> ds.median([2, 5, 1, 3, 4])\n        3.00\n        \"\"\"",
                "test_class": "DataStatisticsTestMedian",
                "test_code": "class DataStatisticsTestMedian(unittest.TestCase):\n    def test_median_1(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 3, 4])\n        self.assertEqual(res, 3)\n\n    def test_median_2(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 3, 4, 6])\n        self.assertEqual(res, 3.50)\n\n    def test_median_3(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7])\n        self.assertEqual(res, 4.5)\n\n    def test_median_4(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7, 8])\n        self.assertEqual(res, 5)\n\n    def test_median_5(self):\n        ds = DataStatistics()\n        res = ds.median([2, 5, 1, 4, 6, 7, 8, 9])\n        self.assertEqual(res, 5.5)",
                "solution_code": "def median(self, data):\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 0:\n            middle = n // 2\n            return round((sorted_data[middle - 1] + sorted_data[middle]) / 2, 2)\n        else:\n            middle = n // 2\n            return sorted_data[middle]",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "mode",
                "method_description": "def mode(self, data):\n        \"\"\"\n        Calculate the mode of a set of data\n        :param data:list, data list\n        :return:float, the mode\n        >>> ds = DataStatistics()\n        >>> ds.mode([2, 2, 3, 3, 4])\n        [2, 3]\n        \"\"\"",
                "test_class": "DataStatisticsTestMode",
                "test_code": "class DataStatisticsTestMode(unittest.TestCase):\n    def test_mode_1(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4])\n        self.assertEqual(res, [2, 3])\n\n    def test_mode_2(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 2, 3, 3, 4])\n        self.assertEqual(res, [2])\n\n    def test_mode_3(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4])\n        self.assertEqual(res, [2, 3, 4])\n\n    def test_mode_4(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4, 4])\n        self.assertEqual(res, [4])\n\n    def test_mode_5(self):\n        ds = DataStatistics()\n        res = ds.mode([2, 2, 3, 3, 4, 4, 4, 5])\n        self.assertEqual(res, [4])",
                "solution_code": "def mode(self, data):\n        counter = Counter(data)\n        mode_count = max(counter.values())\n        mode = [x for x, count in counter.items() if count == mode_count]\n        return mode",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "Counter"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_31",
        "skeleton": "import math\n\nclass DataStatistics4:\n    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: The first set of data,list.\n        :param data2: The second set of data,list.\n        :return: The correlation coefficient, float.\n        >>> DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6])\n        0.9999999999999998\n\n        \"\"\"\n\n    @staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: The input data list, list.\n        :return: The skewness, float.\n        >>> DataStatistics4.skewness([1, 2, 5])\n        2.3760224064818463\n\n        \"\"\"\n\n    @staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        >>> DataStatistics4.kurtosis([1, 20,100])\n        -1.5000000000000007\n\n        \"\"\"\n\n    @staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        >>> DataStatistics4.pdf([1, 2, 3], 1, 1)\n        [0.3989422804014327, 0.24197072451914337, 0.05399096651318806]\n\n        \"\"\"",
        "test": "import unittest\n\n\nclass DataStatistics4TestCorrelationCoefficient(unittest.TestCase):\n    def test_correlation_coefficient(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6]), 0.9999999999999998)\n\n    def test_correlation_coefficient_2(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 1, 1], [2, 2, 2]), 0)\n\n    def test_correlation_coefficient_3(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [1, 2, 3]), 0.9999999999999998)\n\n    def test_correlation_coefficient_4(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [1, 2, 4]), 0.9819805060619659)\n\n    def test_correlation_coefficient_5(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [1, 5, 3]), 0.4999999999999999)\n\n\nclass DataStatistics4TestSkewness(unittest.TestCase):\n    def test_skewness(self):\n        self.assertEqual(DataStatistics4.skewness([1, 2, 5]), 2.3760224064818463)\n\n    def test_skewness_2(self):\n        self.assertEqual(DataStatistics4.skewness([1, 1, 1]), 0)\n\n    def test_skewness_3(self):\n        self.assertEqual(DataStatistics4.skewness([1, 2, 3]), 0)\n\n    def test_skewness_4(self):\n        self.assertEqual(DataStatistics4.skewness([1, 2, 4]), 1.7181079837227264)\n\n    def test_skewness_5(self):\n        self.assertEqual(DataStatistics4.skewness([1, 5, 3]), 0.0)\n\n\nclass DataStatistics4TestKurtosis(unittest.TestCase):\n    def test_kurtosis(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 5]), -1.5000000000000002)\n\n    def test_kurtosis_2(self):\n        self.assertTrue(math.isnan(DataStatistics4.kurtosis([1, 1, 1])))\n\n    def test_kurtosis_3(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 3]), -1.5000000000000002)\n\n    def test_kurtosis_4(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 4]), -1.4999999999999996)\n\n    def test_kurtosis_5(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 5, 3]), -1.5000000000000002)\n\n\nclass DataStatistics4TestPDF(unittest.TestCase):\n    def test_pdf(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 1, 1),\n                         [0.3989422804014327, 0.24197072451914337, 0.05399096651318806])\n\n    def test_pdf_2(self):\n        self.assertEqual(DataStatistics4.pdf([1, 1, 1], 1, 1),\n                         [0.3989422804014327, 0.3989422804014327, 0.3989422804014327])\n\n    def test_pdf_3(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 2, 1),\n                         [0.24197072451914337, 0.3989422804014327, 0.24197072451914337])\n\n    def test_pdf_4(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 1, 2),\n                         [0.19947114020071635, 0.17603266338214976, 0.12098536225957168])\n\n    def test_pdf_5(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 2, 2),\n                         [0.17603266338214976, 0.19947114020071635, 0.17603266338214976])\n\n\nclass DataStatistics4TestMain(unittest.TestCase):\n    def test_main(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6]), 0.9999999999999998)\n        self.assertEqual(DataStatistics4.skewness([1, 2, 5]), 2.3760224064818463)\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 5]), -1.5000000000000002)\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 1, 1),\n                         [0.3989422804014327, 0.24197072451914337, 0.05399096651318806])",
        "solution_code": "import math\n\nclass DataStatistics4:\n\n    @staticmethod\n    def correlation_coefficient(data1, data2):\n        n = len(data1)\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))\n\n        return numerator / denominator if denominator != 0 else 0\n    \n    @staticmethod\n    def skewness(data):\n        n = len(data)\n        mean = sum(data) / n\n        variance = sum((x - mean) ** 2 for x in data) / n\n        std_deviation = math.sqrt(variance)\n\n        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0\n\n        return skewness\n    \n    @staticmethod\n    def kurtosis(data):\n\n        n = len(data)\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)\n\n        if std_dev == 0:\n            return math.nan\n\n        centered_data = [(x - mean) for x in data]\n        fourth_moment = sum(x ** 4 for x in centered_data) / n\n\n        kurtosis_value = (fourth_moment / std_dev ** 4) - 3\n\n        return kurtosis_value\n    \n    @staticmethod\n    def pdf(data, mu, sigma):\n        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values",
        "import_statement": [
            "import math"
        ],
        "class_description": "    \"\"\"\n    This is a class that performs advanced mathematical calculations and statistics, including correlation coefficient, skewness, kurtosis, and probability density function (PDF) for a normal distribution.\n    \"\"\"\n",
        "class_name": "DataStatistics4",
        "test_classes": [
            "DataStatistics4TestCorrelationCoefficient",
            "DataStatistics4TestSkewness",
            "DataStatistics4TestKurtosis",
            "DataStatistics4TestPDF",
            "DataStatistics4TestMain"
        ],
        "class_constructor": "class DataStatistics4: \n",
        "fields": [],
        "methods_info": [
            {
                "method_name": "correlation_coefficient",
                "method_description": "def correlation_coefficient(data1, data2):\n        \"\"\"\n        Calculate the correlation coefficient of two sets of data.\n        :param data1: The first set of data,list.\n        :param data2: The second set of data,list.\n        :return: The correlation coefficient, float.\n        >>> DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6])\n        0.9999999999999998\n\n        \"\"\"",
                "test_class": "DataStatistics4TestCorrelationCoefficient",
                "test_code": "class DataStatistics4TestCorrelationCoefficient(unittest.TestCase):\n    def test_correlation_coefficient(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [4, 5, 6]), 0.9999999999999998)\n\n    def test_correlation_coefficient_2(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 1, 1], [2, 2, 2]), 0)\n\n    def test_correlation_coefficient_3(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [1, 2, 3]), 0.9999999999999998)\n\n    def test_correlation_coefficient_4(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [1, 2, 4]), 0.9819805060619659)\n\n    def test_correlation_coefficient_5(self):\n        self.assertEqual(DataStatistics4.correlation_coefficient([1, 2, 3], [1, 5, 3]), 0.4999999999999999)",
                "solution_code": "def correlation_coefficient(data1, data2):\n        n = len(data1)\n        mean1 = sum(data1) / n\n        mean2 = sum(data2) / n\n\n        numerator = sum((data1[i] - mean1) * (data2[i] - mean2) for i in range(n))\n        denominator = math.sqrt(sum((data1[i] - mean1) ** 2 for i in range(n))) * math.sqrt(sum((data2[i] - mean2) ** 2 for i in range(n)))\n\n        return numerator / denominator if denominator != 0 else 0",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "math"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "skewness",
                "method_description": "@staticmethod\n    def skewness(data):\n        \"\"\"\n        Calculate the skewness of a set of data.\n        :param data: The input data list, list.\n        :return: The skewness, float.\n        >>> DataStatistics4.skewness([1, 2, 5])\n        2.3760224064818463\n\n        \"\"\"",
                "test_class": "DataStatistics4TestSkewness",
                "test_code": "class DataStatistics4TestSkewness(unittest.TestCase):\n    def test_skewness(self):\n        self.assertEqual(DataStatistics4.skewness([1, 2, 5]), 2.3760224064818463)\n\n    def test_skewness_2(self):\n        self.assertEqual(DataStatistics4.skewness([1, 1, 1]), 0)\n\n    def test_skewness_3(self):\n        self.assertEqual(DataStatistics4.skewness([1, 2, 3]), 0)\n\n    def test_skewness_4(self):\n        self.assertEqual(DataStatistics4.skewness([1, 2, 4]), 1.7181079837227264)\n\n    def test_skewness_5(self):\n        self.assertEqual(DataStatistics4.skewness([1, 5, 3]), 0.0)",
                "solution_code": "@staticmethod\n    def skewness(data):\n        n = len(data)\n        mean = sum(data) / n\n        variance = sum((x - mean) ** 2 for x in data) / n\n        std_deviation = math.sqrt(variance)\n\n        skewness = sum((x - mean) ** 3 for x in data) * n / ((n - 1) * (n - 2) * std_deviation ** 3) if std_deviation != 0 else 0\n\n        return skewness",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "math"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "kurtosis",
                "method_description": "@staticmethod\n    def kurtosis(data):\n        \"\"\"\n        Calculate the kurtosis of a set of data.\n        :param data: The input data list, list.\n        :return: The kurtosis, float.\n        >>> DataStatistics4.kurtosis([1, 20,100])\n        -1.5000000000000007\n\n        \"\"\"",
                "test_class": "DataStatistics4TestKurtosis",
                "test_code": "class DataStatistics4TestKurtosis(unittest.TestCase):\n    def test_kurtosis(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 5]), -1.5000000000000002)\n\n    def test_kurtosis_2(self):\n        self.assertTrue(math.isnan(DataStatistics4.kurtosis([1, 1, 1])))\n\n    def test_kurtosis_3(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 3]), -1.5000000000000002)\n\n    def test_kurtosis_4(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 2, 4]), -1.4999999999999996)\n\n    def test_kurtosis_5(self):\n        self.assertEqual(DataStatistics4.kurtosis([1, 5, 3]), -1.5000000000000002)",
                "solution_code": "@staticmethod\n    def kurtosis(data):\n\n        n = len(data)\n        mean = sum(data) / n\n        std_dev = math.sqrt(sum((x - mean) ** 2 for x in data) / n)\n\n        if std_dev == 0:\n            return math.nan\n\n        centered_data = [(x - mean) for x in data]\n        fourth_moment = sum(x ** 4 for x in centered_data) / n\n\n        kurtosis_value = (fourth_moment / std_dev ** 4) - 3\n\n        return kurtosis_value",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "math"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "pdf",
                "method_description": "@staticmethod\n    def pdf(data, mu, sigma):\n        \"\"\"\n        Calculate the probability density function (PDF) of a set of data under a normal distribution.\n        :param data: The input data list, list.\n        :param mu: The mean of the normal distribution, float.\n        :param sigma: The standard deviation of the normal distribution, float.\n        :return: The probability density function (PDF), list.\n        >>> DataStatistics4.pdf([1, 2, 3], 1, 1)\n        [0.3989422804014327, 0.24197072451914337, 0.05399096651318806]\n\n        \"\"\"",
                "test_class": "DataStatistics4TestPDF",
                "test_code": "class DataStatistics4TestPDF(unittest.TestCase):\n    def test_pdf(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 1, 1),\n                         [0.3989422804014327, 0.24197072451914337, 0.05399096651318806])\n\n    def test_pdf_2(self):\n        self.assertEqual(DataStatistics4.pdf([1, 1, 1], 1, 1),\n                         [0.3989422804014327, 0.3989422804014327, 0.3989422804014327])\n\n    def test_pdf_3(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 2, 1),\n                         [0.24197072451914337, 0.3989422804014327, 0.24197072451914337])\n\n    def test_pdf_4(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 1, 2),\n                         [0.19947114020071635, 0.17603266338214976, 0.12098536225957168])\n\n    def test_pdf_5(self):\n        self.assertEqual(DataStatistics4.pdf([1, 2, 3], 2, 2),\n                         [0.17603266338214976, 0.19947114020071635, 0.17603266338214976])",
                "solution_code": "@staticmethod\n    def pdf(data, mu, sigma):\n        pdf_values = [1 / (sigma * math.sqrt(2 * math.pi)) * math.exp(-0.5 * ((x - mu) / sigma) ** 2) for x in data]\n        return pdf_values",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "math"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_34",
        "skeleton": "from docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\n\n\nclass DocFileHandler:\n    \"\"\"\n    This is a class that handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initializes the DocFileHandler object with the specified file path.\n        :param file_path: str, the path to the Word document file.\n        \"\"\"\n        self.file_path = file_path\n\n    def read_text(self):\n        \"\"\"\n        Reads the content of a Word document and returns it as a string.\n        :return: str, the content of the Word document.\n        \"\"\"\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Writes the specified content to a Word document.\n        :param content: str, the text content to write.\n        :param font_size: int, optional, the font size of the text (default is 12).\n        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"\n\n    def add_heading(self, heading, level=1):\n        \"\"\"\n        Adds a heading to the Word document.\n        :param heading: str, the text of the heading.\n        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if the heading is successfully added, False otherwise.\n        \"\"\"\n\n    def add_table(self, data):\n        \"\"\"\n        Adds a table to the Word document with the specified data.\n        :param data: list of lists, the data to populate the table.\n        :return: bool, True if the table is successfully added, False otherwise.\n        \"\"\"\n\n    def _get_alignment_value(self, alignment):\n        \"\"\"\n        Returns the alignment value corresponding to the given alignment string.\n        :param alignment: str, the alignment string ('left', 'center', or 'right').\n        :return: int, the alignment value.\n        \"\"\"",
        "test": "import unittest\nimport os\n\n\nclass DocFileHandlerTestReadText(unittest.TestCase):\n    def test_read_text_1(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"Initial content\")\n        doc.save(self.file_path)\n\n        text_content = self.handler.read_text()\n        expected_content = \"Initial content\"\n        self.assertEqual(text_content, expected_content)\n\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_read_text_2(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"111\")\n        doc.save(self.file_path)\n\n        text_content = self.handler.read_text()\n        expected_content = \"111\"\n        self.assertEqual(text_content, expected_content)\n\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_read_text_3(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"aaa\")\n        doc.save(self.file_path)\n\n        text_content = self.handler.read_text()\n        expected_content = \"aaa\"\n        self.assertEqual(text_content, expected_content)\n\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_read_text_4(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"aaa\\nbbb\")\n        doc.save(self.file_path)\n\n        text_content = self.handler.read_text()\n        expected_content = \"aaa\\nbbb\"\n        self.assertEqual(text_content, expected_content)\n\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_read_text_5(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"\")\n        doc.save(self.file_path)\n\n        text_content = self.handler.read_text()\n        expected_content = \"\"\n        self.assertEqual(text_content, expected_content)\n\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n\nclass DocFileHandlerTestWriteText(unittest.TestCase):\n    def setUp(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"Initial content\")\n        doc.save(self.file_path)\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_write_text_1(self):\n        new_content = \"New content 1\"\n        self.handler.write_text(new_content)\n        text_content = self.handler.read_text()\n        self.assertEqual(text_content, new_content)\n\n    def test_write_text_2(self):\n        new_content = \"New content 2\"\n        self.handler.write_text(new_content)\n        text_content = self.handler.read_text()\n        self.assertEqual(text_content, new_content)\n\n    def test_write_text_3(self):\n        new_content = \"New content 3\"\n        self.handler.write_text(new_content)\n        text_content = self.handler.read_text()\n        self.assertEqual(text_content, new_content)\n\n    def test_write_text_4(self):\n        new_content = \"New content 4\"\n        self.handler.write_text(new_content)\n        text_content = self.handler.read_text()\n        self.assertEqual(text_content, new_content)\n\n    def test_write_text_5(self):\n        new_content = \"\"\n        self.handler.write_text(new_content)\n        text_content = self.handler.read_text()\n        self.assertEqual(text_content, new_content)\n\n\nclass DocFileHandlerTestAddHeading(unittest.TestCase):\n    def setUp(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"Initial content\")\n        doc.save(self.file_path)\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_add_heading_1(self):\n        heading = \"Test Heading 1\"\n        self.handler.add_heading(heading)\n        doc = Document(self.file_path)\n        headings = [p.text for p in doc.paragraphs if p.style.name.startswith('Heading')]\n        self.assertIn(heading, headings)\n\n    def test_add_heading_2(self):\n        heading = \"Test Heading 2\"\n        self.handler.add_heading(heading)\n        doc = Document(self.file_path)\n        headings = [p.text for p in doc.paragraphs if p.style.name.startswith('Heading')]\n        self.assertIn(heading, headings)\n\n    def test_add_heading_3(self):\n        heading = \"Test Heading 3\"\n        self.handler.add_heading(heading)\n        doc = Document(self.file_path)\n        headings = [p.text for p in doc.paragraphs if p.style.name.startswith('Heading')]\n        self.assertIn(heading, headings)\n\n    def test_add_heading_4(self):\n        heading = \"Test Heading 4\"\n        self.handler.add_heading(heading)\n        doc = Document(self.file_path)\n        headings = [p.text for p in doc.paragraphs if p.style.name.startswith('Heading')]\n        self.assertIn(heading, headings)\n\n    def test_add_heading_5(self):\n        heading = \"Test Heading 5\"\n        self.handler.add_heading(heading)\n        doc = Document(self.file_path)\n        headings = [p.text for p in doc.paragraphs if p.style.name.startswith('Heading')]\n        self.assertIn(heading, headings)\n\n\nclass DocFileHandlerTestAddTable(unittest.TestCase):\n    def setUp(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"Initial content\")\n        doc.save(self.file_path)\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_add_table_1(self):\n        data = [['Name', 'Age']]\n        self.handler.add_table(data)\n        doc = Document(self.file_path)\n        table = doc.tables[0]\n        self.assertEqual(len(table.rows), 1)\n        self.assertEqual(len(table.columns), 2)\n\n    def test_add_table_2(self):\n        data = [['Name', 'Age'], ['John', '25']]\n        self.handler.add_table(data)\n        doc = Document(self.file_path)\n        table = doc.tables[0]\n        self.assertEqual(len(table.rows), 2)\n        self.assertEqual(len(table.columns), 2)\n        self.assertEqual(table.cell(1, 0).text, 'John')\n\n    def test_add_table_3(self):\n        data = [['Name', 'Age'], ['John', '25'], ['Emma', '30']]\n        self.handler.add_table(data)\n        doc = Document(self.file_path)\n        table = doc.tables[0]\n        self.assertEqual(len(table.rows), 3)\n        self.assertEqual(len(table.columns), 2)\n        self.assertEqual(table.cell(1, 0).text, 'John')\n        self.assertEqual(table.cell(2, 1).text, '30')\n\n    def test_add_table_4(self):\n        data = [['Name', 'Age'], ['aaa', '25'], ['Emma', '30']]\n        self.handler.add_table(data)\n        doc = Document(self.file_path)\n        table = doc.tables[0]\n        self.assertEqual(len(table.rows), 3)\n        self.assertEqual(len(table.columns), 2)\n        self.assertEqual(table.cell(1, 0).text, 'aaa')\n        self.assertEqual(table.cell(2, 1).text, '30')\n\n    def test_add_table_5(self):\n        data = [['Name', 'Age'], ['John', '25'], ['Emma', '90']]\n        self.handler.add_table(data)\n        doc = Document(self.file_path)\n        table = doc.tables[0]\n        self.assertEqual(len(table.rows), 3)\n        self.assertEqual(len(table.columns), 2)\n        self.assertEqual(table.cell(1, 0).text, 'John')\n        self.assertEqual(table.cell(2, 1).text, '90')\n\n\nclass DocFileHandlerTest(unittest.TestCase):\n    def test_DocFileHandler(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"Initial content\")\n        doc.save(self.file_path)\n\n        text_content = self.handler.read_text()\n        expected_content = \"Initial content\"\n        self.assertEqual(text_content, expected_content)\n\n        new_content = \"New content 1\"\n        self.handler.write_text(new_content)\n        text_content = self.handler.read_text()\n        self.assertEqual(text_content, new_content)\n\n        heading = \"Test Heading 1\"\n        self.handler.add_heading(heading)\n        doc = Document(self.file_path)\n        headings = [p.text for p in doc.paragraphs if p.style.name.startswith('Heading')]\n        self.assertIn(heading, headings)\n\n        data = [['Name', 'Age']]\n        self.handler.add_table(data)\n        doc = Document(self.file_path)\n        table = doc.tables[0]\n        self.assertEqual(len(table.rows), 1)\n        self.assertEqual(len(table.columns), 2)\n\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)",
        "solution_code": "from docx import Document\nfrom docx.shared import Pt\nfrom docx.enum.text import WD_PARAGRAPH_ALIGNMENT\n\n\nclass DocFileHandler:\n    def __init__(self, file_path):\n        self.file_path = file_path\n\n    def read_text(self):\n        doc = Document(self.file_path)\n        text = []\n        for paragraph in doc.paragraphs:\n            text.append(paragraph.text)\n        return \"\\n\".join(text)\n\n    def write_text(self, content, font_size=12, alignment='left'):\n        try:\n            doc = Document()\n            paragraph = doc.add_paragraph()\n            run = paragraph.add_run(content)\n            font = run.font\n            font.size = Pt(font_size)\n            alignment_value = self._get_alignment_value(alignment)\n            paragraph.alignment = alignment_value\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def add_heading(self, heading, level=1):\n        try:\n            doc = Document(self.file_path)\n            doc.add_heading(heading, level)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def add_table(self, data):\n        try:\n            doc = Document(self.file_path)\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n            for i, row in enumerate(data):\n                for j, cell_value in enumerate(row):\n                    table.cell(i, j).text = str(cell_value)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False\n\n    def _get_alignment_value(self, alignment):\n        alignment_options = {\n            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,\n            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,\n            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT\n        }\n        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)",
        "import_statement": [
            "from docx import Document",
            "from docx.shared import Pt",
            "from docx.enum.text import WD_PARAGRAPH_ALIGNMENT"
        ],
        "class_description": "    \"\"\"\n    This is a class that handles Word documents and provides functionalities for reading, writing, and modifying the content of Word documents.\n    \"\"\"\n",
        "class_name": "DocFileHandler",
        "test_classes": [
            "DocFileHandlerTestReadText",
            "DocFileHandlerTestWriteText",
            "DocFileHandlerTestAddHeading",
            "DocFileHandlerTestAddTable",
            "DocFileHandlerTest"
        ],
        "class_constructor": "class DocFileHandler: \n    def __init__(self, file_path):\n        \"\"\"\n        Initializes the DocFileHandler object with the specified file path.\n        :param file_path: str, the path to the Word document file.\n        \"\"\"\n        self.file_path = file_path\n\n",
        "fields": [
            "self.file_path"
        ],
        "methods_info": [
            {
                "method_name": "read_text",
                "method_description": "def read_text(self):\n        \"\"\"\n        Reads the content of a Word document and returns it as a string.\n        :return: str, the content of the Word document.\n        \"\"\"",
                "test_class": "DocFileHandlerTestReadText",
                "test_code": "class DocFileHandlerTestReadText(unittest.TestCase):\n    def test_read_text_1(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"Initial content\")\n        doc.save(self.file_path)\n\n        text_content = self.handler.read_text()\n        expected_content = \"Initial content\"\n        self.assertEqual(text_content, expected_content)\n\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_read_text_2(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"111\")\n        doc.save(self.file_path)\n\n        text_content = self.handler.read_text()\n        expected_content = \"111\"\n        self.assertEqual(text_content, expected_content)\n\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_read_text_3(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"aaa\")\n        doc.save(self.file_path)\n\n        text_content = self.handler.read_text()\n        expected_content = \"aaa\"\n        self.assertEqual(text_content, expected_content)\n\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_read_text_4(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"aaa\\nbbb\")\n        doc.save(self.file_path)\n\n        text_content = self.handler.read_text()\n        expected_content = \"aaa\\nbbb\"\n        self.assertEqual(text_content, expected_content)\n\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_read_text_5(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"\")\n        doc.save(self.file_path)\n\n        text_content = self.handler.read_text()\n        expected_content = \"\"\n        self.assertEqual(text_content, expected_content)\n\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)",
                "solution_code": "def read_text(self):\n        doc = Document(self.file_path)\n        text = []\n        for paragraph in doc.paragraphs:\n            text.append(paragraph.text)\n        return \"\\n\".join(text)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "Document"
                    ],
                    "field_dependencies": [
                        "self.file_path"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "write_text",
                "method_description": "def write_text(self, content, font_size=12, alignment='left'):\n        \"\"\"\n        Writes the specified content to a Word document.\n        :param content: str, the text content to write.\n        :param font_size: int, optional, the font size of the text (default is 12).\n        :param alignment: str, optional, the alignment of the text ('left', 'center', or 'right'; default is 'left').\n        :return: bool, True if the write operation is successful, False otherwise.\n        \"\"\"",
                "test_class": "DocFileHandlerTestWriteText",
                "test_code": "class DocFileHandlerTestWriteText(unittest.TestCase):\n    def setUp(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"Initial content\")\n        doc.save(self.file_path)\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_write_text_1(self):\n        new_content = \"New content 1\"\n        self.handler.write_text(new_content)\n        text_content = self.handler.read_text()\n        self.assertEqual(text_content, new_content)\n\n    def test_write_text_2(self):\n        new_content = \"New content 2\"\n        self.handler.write_text(new_content)\n        text_content = self.handler.read_text()\n        self.assertEqual(text_content, new_content)\n\n    def test_write_text_3(self):\n        new_content = \"New content 3\"\n        self.handler.write_text(new_content)\n        text_content = self.handler.read_text()\n        self.assertEqual(text_content, new_content)\n\n    def test_write_text_4(self):\n        new_content = \"New content 4\"\n        self.handler.write_text(new_content)\n        text_content = self.handler.read_text()\n        self.assertEqual(text_content, new_content)\n\n    def test_write_text_5(self):\n        new_content = \"\"\n        self.handler.write_text(new_content)\n        text_content = self.handler.read_text()\n        self.assertEqual(text_content, new_content)",
                "solution_code": "def write_text(self, content, font_size=12, alignment='left'):\n        try:\n            doc = Document()\n            paragraph = doc.add_paragraph()\n            run = paragraph.add_run(content)\n            font = run.font\n            font.size = Pt(font_size)\n            alignment_value = self._get_alignment_value(alignment)\n            paragraph.alignment = alignment_value\n            doc.save(self.file_path)\n            return True\n        except:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "Document",
                        "Pt"
                    ],
                    "field_dependencies": [
                        "self.file_path"
                    ],
                    "method_dependencies": [
                        "_get_alignment_value"
                    ]
                }
            },
            {
                "method_name": "add_heading",
                "method_description": "def add_heading(self, heading, level=1):\n        \"\"\"\n        Adds a heading to the Word document.\n        :param heading: str, the text of the heading.\n        :param level: int, optional, the level of the heading (1, 2, 3, etc.; default is 1).\n        :return: bool, True if the heading is successfully added, False otherwise.\n        \"\"\"",
                "test_class": "DocFileHandlerTestAddHeading",
                "test_code": "class DocFileHandlerTestAddHeading(unittest.TestCase):\n    def setUp(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"Initial content\")\n        doc.save(self.file_path)\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_add_heading_1(self):\n        heading = \"Test Heading 1\"\n        self.handler.add_heading(heading)\n        doc = Document(self.file_path)\n        headings = [p.text for p in doc.paragraphs if p.style.name.startswith('Heading')]\n        self.assertIn(heading, headings)\n\n    def test_add_heading_2(self):\n        heading = \"Test Heading 2\"\n        self.handler.add_heading(heading)\n        doc = Document(self.file_path)\n        headings = [p.text for p in doc.paragraphs if p.style.name.startswith('Heading')]\n        self.assertIn(heading, headings)\n\n    def test_add_heading_3(self):\n        heading = \"Test Heading 3\"\n        self.handler.add_heading(heading)\n        doc = Document(self.file_path)\n        headings = [p.text for p in doc.paragraphs if p.style.name.startswith('Heading')]\n        self.assertIn(heading, headings)\n\n    def test_add_heading_4(self):\n        heading = \"Test Heading 4\"\n        self.handler.add_heading(heading)\n        doc = Document(self.file_path)\n        headings = [p.text for p in doc.paragraphs if p.style.name.startswith('Heading')]\n        self.assertIn(heading, headings)\n\n    def test_add_heading_5(self):\n        heading = \"Test Heading 5\"\n        self.handler.add_heading(heading)\n        doc = Document(self.file_path)\n        headings = [p.text for p in doc.paragraphs if p.style.name.startswith('Heading')]\n        self.assertIn(heading, headings)",
                "solution_code": "def add_heading(self, heading, level=1):\n        try:\n            doc = Document(self.file_path)\n            doc.add_heading(heading, level)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "Document"
                    ],
                    "field_dependencies": [
                        "self.file_path"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "add_table",
                "method_description": "def add_table(self, data):\n        \"\"\"\n        Adds a table to the Word document with the specified data.\n        :param data: list of lists, the data to populate the table.\n        :return: bool, True if the table is successfully added, False otherwise.\n        \"\"\"",
                "test_class": "DocFileHandlerTestAddTable",
                "test_code": "class DocFileHandlerTestAddTable(unittest.TestCase):\n    def setUp(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"Initial content\")\n        doc.save(self.file_path)\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_add_table_1(self):\n        data = [['Name', 'Age']]\n        self.handler.add_table(data)\n        doc = Document(self.file_path)\n        table = doc.tables[0]\n        self.assertEqual(len(table.rows), 1)\n        self.assertEqual(len(table.columns), 2)\n\n    def test_add_table_2(self):\n        data = [['Name', 'Age'], ['John', '25']]\n        self.handler.add_table(data)\n        doc = Document(self.file_path)\n        table = doc.tables[0]\n        self.assertEqual(len(table.rows), 2)\n        self.assertEqual(len(table.columns), 2)\n        self.assertEqual(table.cell(1, 0).text, 'John')\n\n    def test_add_table_3(self):\n        data = [['Name', 'Age'], ['John', '25'], ['Emma', '30']]\n        self.handler.add_table(data)\n        doc = Document(self.file_path)\n        table = doc.tables[0]\n        self.assertEqual(len(table.rows), 3)\n        self.assertEqual(len(table.columns), 2)\n        self.assertEqual(table.cell(1, 0).text, 'John')\n        self.assertEqual(table.cell(2, 1).text, '30')\n\n    def test_add_table_4(self):\n        data = [['Name', 'Age'], ['aaa', '25'], ['Emma', '30']]\n        self.handler.add_table(data)\n        doc = Document(self.file_path)\n        table = doc.tables[0]\n        self.assertEqual(len(table.rows), 3)\n        self.assertEqual(len(table.columns), 2)\n        self.assertEqual(table.cell(1, 0).text, 'aaa')\n        self.assertEqual(table.cell(2, 1).text, '30')\n\n    def test_add_table_5(self):\n        data = [['Name', 'Age'], ['John', '25'], ['Emma', '90']]\n        self.handler.add_table(data)\n        doc = Document(self.file_path)\n        table = doc.tables[0]\n        self.assertEqual(len(table.rows), 3)\n        self.assertEqual(len(table.columns), 2)\n        self.assertEqual(table.cell(1, 0).text, 'John')\n        self.assertEqual(table.cell(2, 1).text, '90')",
                "solution_code": "def add_table(self, data):\n        try:\n            doc = Document(self.file_path)\n            table = doc.add_table(rows=len(data), cols=len(data[0]))\n            for i, row in enumerate(data):\n                for j, cell_value in enumerate(row):\n                    table.cell(i, j).text = str(cell_value)\n            doc.save(self.file_path)\n            return True\n        except:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "Document"
                    ],
                    "field_dependencies": [
                        "self.file_path"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "_get_alignment_value",
                "method_description": "def _get_alignment_value(self, alignment):\n        \"\"\"\n        Returns the alignment value corresponding to the given alignment string.\n        :param alignment: str, the alignment string ('left', 'center', or 'right').\n        :return: int, the alignment value.\n        \"\"\"",
                "test_class": "DocFileHandlerTest",
                "test_code": "class DocFileHandlerTest(unittest.TestCase):\n    def test_DocFileHandler(self):\n        self.file_path = \"test_example.docx\"\n        self.handler = DocFileHandler(self.file_path)\n        doc = Document()\n        doc.add_paragraph(\"Initial content\")\n        doc.save(self.file_path)\n\n        text_content = self.handler.read_text()\n        expected_content = \"Initial content\"\n        self.assertEqual(text_content, expected_content)\n\n        new_content = \"New content 1\"\n        self.handler.write_text(new_content)\n        text_content = self.handler.read_text()\n        self.assertEqual(text_content, new_content)\n\n        heading = \"Test Heading 1\"\n        self.handler.add_heading(heading)\n        doc = Document(self.file_path)\n        headings = [p.text for p in doc.paragraphs if p.style.name.startswith('Heading')]\n        self.assertIn(heading, headings)\n\n        data = [['Name', 'Age']]\n        self.handler.add_table(data)\n        doc = Document(self.file_path)\n        table = doc.tables[0]\n        self.assertEqual(len(table.rows), 1)\n        self.assertEqual(len(table.columns), 2)\n\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)",
                "solution_code": "def _get_alignment_value(self, alignment):\n        alignment_options = {\n            'left': WD_PARAGRAPH_ALIGNMENT.LEFT,\n            'center': WD_PARAGRAPH_ALIGNMENT.CENTER,\n            'right': WD_PARAGRAPH_ALIGNMENT.RIGHT\n        }\n        return alignment_options.get(alignment.lower(), WD_PARAGRAPH_ALIGNMENT.LEFT)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "WD_PARAGRAPH_ALIGNMENT"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_36",
        "skeleton": "from datetime import datetime\n\nclass EmailClient:\n    \"\"\"\n    This is a class that serves as an email client, implementing functions such as checking emails, determining whether there is sufficient space, and cleaning up space\n    \"\"\"\n\n    def __init__(self, addr, capacity) -> None:\n        \"\"\"\n        Initializes the EmailClient class with the email address and the capacity of the email box.\n        :param addr: The email address, str.\n        :param capacity: The capacity of the email box, float.\n        \"\"\"\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n    def send_to(self, recv, content, size):\n        \"\"\"\n        Sends an email to the given email address.\n        :param recv: The email address of the receiver, str.\n        :param content: The content of the email, str.\n        :param size: The size of the email, float.\n        :return: True if the email is sent successfully, False if the receiver's email box is full.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> sender.send_to(receiver, 'Hello', 10)\n        True\n        >>> receiver.inbox\n        {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'unread'}\n\n        \"\"\"\n\n    def fetch(self):\n        \"\"\"\n        Retrieves the first unread email in the email box and marks it as read.\n        :return: The first unread email in the email box, dict.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'unread'}]\n        >>> receiver.fetch()\n        {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'read'}\n\n        \"\"\"\n\n    def is_full_with_one_more_email(self, size):\n        \"\"\"\n        Determines whether the email box is full after adding an email of the given size.\n        :param size: The size of the email, float.\n        :return: True if the email box is full, False otherwise.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.is_full_with_one_more_email(10)\n        False\n\n        \"\"\"\n\n    def get_occupied_size(self):\n        \"\"\"\n        Gets the total size of the emails in the email box.\n        :return: The total size of the emails in the email box, float.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> sender.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': datetime.now, 'state': 'unread'}]\n        >>> sender.get_occupied_size()\n        10\n\n        \"\"\"\n\n    def clear_inbox(self, size):\n        \"\"\"\n        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.\n        :param size: The size of the email, float.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.inbox = [{'size': 10},{'size': 20},{'size': 15}]\n        >>> receiver.clear_inbox(30)\n        >>> receiver.inbox\n        [{'size': 15}]\n\n        \"\"\"",
        "test": "import unittest\n\nclass EmailClientTestSendTo(unittest.TestCase):\n    def test_send_to(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertTrue(sender.send_to(receiver, 'Hello', 10))\n        self.assertEqual(receiver.inbox[0], {\"sender\": 'sender@example.com','receiver': 'receiver@example.com','content': 'Hello','size': 10,'time': timestamp,'state': 'unread'})\n\n    def test_send_to_2(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 0)\n        self.assertFalse(sender.send_to(receiver, 'Hello', 10))\n\n    def test_send_to_3(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        receiver.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 50, 'time': '2021-01-01 00:00:00', 'state': 'unread'}]\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertFalse(sender.send_to(receiver, 'Hello', 10))\n        self.assertEqual(receiver.inbox, [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 50, 'time': '2021-01-01 00:00:00', 'state': 'unread'}])\n\n    def test_send_to_4(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 30)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertTrue(sender.send_to(receiver, 'Hello', 20))\n        self.assertEqual(receiver.inbox, [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 20, 'time': timestamp, 'state': 'unread'}])\n\n    def test_send_to_5(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 30)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertTrue(sender.send_to(receiver, 'bye', 20))\n        self.assertEqual(receiver.inbox, [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'bye', 'size': 20, 'time': timestamp, 'state': 'unread'}])\nclass EmailClientTestFetch(unittest.TestCase):\n    def test_fetch(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        receiver.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time': timestamp, 'state': 'unread'}]\n        self.assertEqual(receiver.fetch(), {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time':timestamp, 'state': 'read'})\n\n    def test_fetch_2(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertEqual(receiver.fetch(),None)\n\n    def test_fetch_3(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        receiver.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time': timestamp, 'state': 'read'}]\n        self.assertEqual(receiver.fetch(), None)\n\n    def test_fetch_4(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        receiver.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time':  '2021-01-01 00:00:00', 'state': 'unread'},\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time': timestamp, 'state': 'unread'}]\n        self.assertEqual(receiver.fetch(), {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time':  '2021-01-01 00:00:00', 'state': 'read'})\n\n    def test_fetch_5(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        receiver.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time': '2021-01-01 00:00:00', 'state': 'read'},\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time': timestamp, 'state': 'unread'}]\n        self.assertEqual(receiver.fetch(), {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time': timestamp, 'state': 'read'})\n\nclass EmailClientTestIsFullWithOneMoreEmail(unittest.TestCase):\n    def test_is_full_with_one_more_email(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        self.assertFalse(receiver.is_full_with_one_more_email(10))\n\n    def test_is_full_with_one_more_email_2(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 0)\n        self.assertTrue(receiver.is_full_with_one_more_email(10))\n\n    def test_is_full_with_one_more_email_3(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 10)\n        self.assertFalse(receiver.is_full_with_one_more_email(10))\n\n    def test_is_full_with_one_more_email_4(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 10)\n        self.assertTrue(receiver.is_full_with_one_more_email(20))\n\n    def test_is_full_with_one_more_email_5(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 20)\n        self.assertFalse(receiver.is_full_with_one_more_email(20))\n\nclass EmailClientTestGetOccupiedSize(unittest.TestCase):\n    def test_get_occupied_size(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        sender.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': datetime.now, 'state': 'unread'}]\n        self.assertEqual(sender.get_occupied_size(), 10)\n\n    def test_get_occupied_size_2(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        sender.inbox =[]\n        self.assertEqual(sender.get_occupied_size(), 0)\n\n    def test_get_occupied_size_3(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        sender.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 20,\n             'time': datetime.now, 'state': 'unread'}]\n        self.assertEqual(sender.get_occupied_size(), 20)\n\n    def test_get_occupied_size_4(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        sender.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 20,\n             'time': datetime.now, 'state': 'unread'},\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 30,\n             'time': datetime.now, 'state': 'unread'}]\n        self.assertEqual(sender.get_occupied_size(), 50)\n\n    def test_get_occupied_size_5(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        sender.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 20,\n             'time': datetime.now, 'state': 'unread'},\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 60,\n             'time': datetime.now, 'state': 'unread'}]\n        self.assertEqual(sender.get_occupied_size(), 80)\n\nclass EmailClientTestClearInbox(unittest.TestCase):\n    def test_clear_inbox(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        receiver.inbox = [{'size': 10},{'size': 20},{'size': 15}]\n        receiver.clear_inbox(30)\n        self.assertEqual(receiver.inbox, [{'size': 15}])\n\n    def test_clear_inbox_2(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('', 50)\n        receiver.inbox = [{'size': 10},{'size': 20},{'size': 15}]\n        self.assertEqual(receiver.clear_inbox(30),None)\n        self.assertEqual(receiver.inbox, [{'size': 10},{'size': 20},{'size': 15}])\n\n    def test_clear_inbox_3(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        receiver.inbox = [{'size': 10}, {'size': 20}, {'size': 15}]\n        self.assertEqual(receiver.clear_inbox(50), None)\n\n    def test_clear_inbox_4(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        receiver.inbox = [{'size': 10}, {'size': 20}, {'size': 15}]\n        receiver.clear_inbox(45)\n        self.assertEqual(receiver.inbox, [])\n    def test_clear_inbox_5(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        receiver.inbox = [{'size': 10}, {'size': 20}, {'size': 15}]\n        receiver.clear_inbox(10)\n        self.assertEqual(receiver.inbox, [{'size': 20}, {'size': 15}])\n\n\n\n\nclass EmailClientTestMain(unittest.TestCase):\n    def test_main(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertTrue(sender.send_to(receiver, 'Hello', 10))\n        self.assertEqual(receiver.inbox[0], {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': timestamp, 'state': 'unread'})\n        self.assertEqual(receiver.fetch(), {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': timestamp, 'state': 'read'})\n        self.assertFalse(receiver.is_full_with_one_more_email(10))\n        self.assertEqual(receiver.get_occupied_size(), 10)\n        receiver.inbox = [{'size': 10},{'size': 20},{'size': 15}]\n        receiver.clear_inbox(30)\n        self.assertEqual(receiver.inbox, [{'size': 15}])",
        "solution_code": "from datetime import datetime\n\nclass EmailClient:\n    def __init__(self, addr, capacity) -> None:\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n    \n    def send_to(self, recv, content, size):\n        if not recv.is_full_with_one_more_email(size):\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            email = {\n                \"sender\": self.addr,\n                \"receiver\": recv.addr,\n                \"content\": content,\n                \"size\": size,\n                \"time\": timestamp,\n                \"state\": \"unread\"\n            }\n            recv.inbox.append(email)\n            return True\n        else:\n            self.clear_inbox(size)\n            return False\n    \n    def fetch(self):\n        if len(self.inbox) == 0:\n            return None\n        for i in range(len(self.inbox)):\n            if self.inbox[i]['state'] == \"unread\":\n                self.inbox[i]['state'] = \"read\"\n                return self.inbox[i]\n        return None\n\n    def is_full_with_one_more_email(self, size):\n        occupied_size = self.get_occupied_size()\n        return True if occupied_size + size > self.capacity else False\n        \n    def get_occupied_size(self):\n        occupied_size = 0\n        for email in self.inbox:\n            occupied_size += email[\"size\"]\n        return occupied_size\n\n    def clear_inbox(self, size):\n        if len(self.addr) == 0:\n            return\n        freed_space = 0\n        while freed_space < size and self.inbox:\n            email = self.inbox[0]\n            freed_space += email['size']\n            del self.inbox[0]",
        "import_statement": [
            "from datetime import datetime"
        ],
        "class_description": "    \"\"\"\n    This is a class that serves as an email client, implementing functions such as checking emails, determining whether there is sufficient space, and cleaning up space\n    \"\"\"\n",
        "class_name": "EmailClient",
        "test_classes": [
            "EmailClientTestSendTo",
            "EmailClientTestFetch",
            "EmailClientTestIsFullWithOneMoreEmail",
            "EmailClientTestGetOccupiedSize",
            "EmailClientTestClearInbox",
            "EmailClientTestMain"
        ],
        "class_constructor": "class EmailClient: \n    def __init__(self, addr, capacity) -> None:\n        \"\"\"\n        Initializes the EmailClient class with the email address and the capacity of the email box.\n        :param addr: The email address, str.\n        :param capacity: The capacity of the email box, float.\n        \"\"\"\n        self.addr = addr\n        self.capacity = capacity\n        self.inbox = []\n\n",
        "fields": [
            "self.addr",
            "self.capacity",
            "self.inbox"
        ],
        "methods_info": [
            {
                "method_name": "send_to",
                "method_description": "def send_to(self, recv, content, size):\n        \"\"\"\n        Sends an email to the given email address.\n        :param recv: The email address of the receiver, str.\n        :param content: The content of the email, str.\n        :param size: The size of the email, float.\n        :return: True if the email is sent successfully, False if the receiver's email box is full.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> sender.send_to(receiver, 'Hello', 10)\n        True\n        >>> receiver.inbox\n        {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'unread'}\n\n        \"\"\"",
                "test_class": "EmailClientTestSendTo",
                "test_code": "class EmailClientTestSendTo(unittest.TestCase):\n    def test_send_to(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertTrue(sender.send_to(receiver, 'Hello', 10))\n        self.assertEqual(receiver.inbox[0], {\"sender\": 'sender@example.com','receiver': 'receiver@example.com','content': 'Hello','size': 10,'time': timestamp,'state': 'unread'})\n\n    def test_send_to_2(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 0)\n        self.assertFalse(sender.send_to(receiver, 'Hello', 10))\n\n    def test_send_to_3(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        receiver.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 50, 'time': '2021-01-01 00:00:00', 'state': 'unread'}]\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertFalse(sender.send_to(receiver, 'Hello', 10))\n        self.assertEqual(receiver.inbox, [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 50, 'time': '2021-01-01 00:00:00', 'state': 'unread'}])\n\n    def test_send_to_4(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 30)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertTrue(sender.send_to(receiver, 'Hello', 20))\n        self.assertEqual(receiver.inbox, [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 20, 'time': timestamp, 'state': 'unread'}])\n\n    def test_send_to_5(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 30)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertTrue(sender.send_to(receiver, 'bye', 20))\n        self.assertEqual(receiver.inbox, [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'bye', 'size': 20, 'time': timestamp, 'state': 'unread'}])",
                "solution_code": "def send_to(self, recv, content, size):\n        if not recv.is_full_with_one_more_email(size):\n            timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n            email = {\n                \"sender\": self.addr,\n                \"receiver\": recv.addr,\n                \"content\": content,\n                \"size\": size,\n                \"time\": timestamp,\n                \"state\": \"unread\"\n            }\n            recv.inbox.append(email)\n            return True\n        else:\n            self.clear_inbox(size)\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime"
                    ],
                    "field_dependencies": [
                        "self.addr"
                    ],
                    "method_dependencies": [
                        "is_full_with_one_more_email",
                        "clear_inbox"
                    ]
                }
            },
            {
                "method_name": "fetch",
                "method_description": "def fetch(self):\n        \"\"\"\n        Retrieves the first unread email in the email box and marks it as read.\n        :return: The first unread email in the email box, dict.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'unread'}]\n        >>> receiver.fetch()\n        {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': '2023-07-13 11:36:40', 'state': 'read'}\n\n        \"\"\"",
                "test_class": "EmailClientTestFetch",
                "test_code": "class EmailClientTestFetch(unittest.TestCase):\n    def test_fetch(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        receiver.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time': timestamp, 'state': 'unread'}]\n        self.assertEqual(receiver.fetch(), {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time':timestamp, 'state': 'read'})\n\n    def test_fetch_2(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        self.assertEqual(receiver.fetch(),None)\n\n    def test_fetch_3(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        receiver.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time': timestamp, 'state': 'read'}]\n        self.assertEqual(receiver.fetch(), None)\n\n    def test_fetch_4(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        receiver.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time':  '2021-01-01 00:00:00', 'state': 'unread'},\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time': timestamp, 'state': 'unread'}]\n        self.assertEqual(receiver.fetch(), {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time':  '2021-01-01 00:00:00', 'state': 'read'})\n\n    def test_fetch_5(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        timestamp = datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        receiver.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time': '2021-01-01 00:00:00', 'state': 'read'},\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time': timestamp, 'state': 'unread'}]\n        self.assertEqual(receiver.fetch(), {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10,\n             'time': timestamp, 'state': 'read'})",
                "solution_code": "def fetch(self):\n        if len(self.inbox) == 0:\n            return None\n        for i in range(len(self.inbox)):\n            if self.inbox[i]['state'] == \"unread\":\n                self.inbox[i]['state'] = \"read\"\n                return self.inbox[i]\n        return None",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.inbox"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "is_full_with_one_more_email",
                "method_description": "def is_full_with_one_more_email(self, size):\n        \"\"\"\n        Determines whether the email box is full after adding an email of the given size.\n        :param size: The size of the email, float.\n        :return: True if the email box is full, False otherwise.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.is_full_with_one_more_email(10)\n        False\n\n        \"\"\"",
                "test_class": "EmailClientTestIsFullWithOneMoreEmail",
                "test_code": "class EmailClientTestIsFullWithOneMoreEmail(unittest.TestCase):\n    def test_is_full_with_one_more_email(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        self.assertFalse(receiver.is_full_with_one_more_email(10))\n\n    def test_is_full_with_one_more_email_2(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 0)\n        self.assertTrue(receiver.is_full_with_one_more_email(10))\n\n    def test_is_full_with_one_more_email_3(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 10)\n        self.assertFalse(receiver.is_full_with_one_more_email(10))\n\n    def test_is_full_with_one_more_email_4(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 10)\n        self.assertTrue(receiver.is_full_with_one_more_email(20))\n\n    def test_is_full_with_one_more_email_5(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 20)\n        self.assertFalse(receiver.is_full_with_one_more_email(20))",
                "solution_code": "def is_full_with_one_more_email(self, size):\n        occupied_size = self.get_occupied_size()\n        return True if occupied_size + size > self.capacity else False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.capacity"
                    ],
                    "method_dependencies": [
                        "get_occupied_size"
                    ]
                }
            },
            {
                "method_name": "get_occupied_size",
                "method_description": "def get_occupied_size(self):\n        \"\"\"\n        Gets the total size of the emails in the email box.\n        :return: The total size of the emails in the email box, float.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> sender.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': datetime.now, 'state': 'unread'}]\n        >>> sender.get_occupied_size()\n        10\n\n        \"\"\"",
                "test_class": "EmailClientTestGetOccupiedSize",
                "test_code": "class EmailClientTestGetOccupiedSize(unittest.TestCase):\n    def test_get_occupied_size(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        sender.inbox = [{'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 10, 'time': datetime.now, 'state': 'unread'}]\n        self.assertEqual(sender.get_occupied_size(), 10)\n\n    def test_get_occupied_size_2(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        sender.inbox =[]\n        self.assertEqual(sender.get_occupied_size(), 0)\n\n    def test_get_occupied_size_3(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        sender.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 20,\n             'time': datetime.now, 'state': 'unread'}]\n        self.assertEqual(sender.get_occupied_size(), 20)\n\n    def test_get_occupied_size_4(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        sender.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 20,\n             'time': datetime.now, 'state': 'unread'},\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 30,\n             'time': datetime.now, 'state': 'unread'}]\n        self.assertEqual(sender.get_occupied_size(), 50)\n\n    def test_get_occupied_size_5(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        sender.inbox = [\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 20,\n             'time': datetime.now, 'state': 'unread'},\n            {'sender': 'sender@example.com', 'receiver': 'receiver@example.com', 'content': 'Hello', 'size': 60,\n             'time': datetime.now, 'state': 'unread'}]\n        self.assertEqual(sender.get_occupied_size(), 80)",
                "solution_code": "def get_occupied_size(self):\n        occupied_size = 0\n        for email in self.inbox:\n            occupied_size += email[\"size\"]\n        return occupied_size",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.inbox"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "clear_inbox",
                "method_description": "def clear_inbox(self, size):\n        \"\"\"\n        Clears the email box by deleting the oldest emails until the email box has enough space to accommodate the given size.\n        :param size: The size of the email, float.\n        >>> sender = EmailClient('sender@example.com', 100)\n        >>> receiver = EmailClient('receiver@example.com', 50)\n        >>> receiver.inbox = [{'size': 10},{'size': 20},{'size': 15}]\n        >>> receiver.clear_inbox(30)\n        >>> receiver.inbox\n        [{'size': 15}]\n\n        \"\"\"",
                "test_class": "EmailClientTestClearInbox",
                "test_code": "class EmailClientTestClearInbox(unittest.TestCase):\n    def test_clear_inbox(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        receiver.inbox = [{'size': 10},{'size': 20},{'size': 15}]\n        receiver.clear_inbox(30)\n        self.assertEqual(receiver.inbox, [{'size': 15}])\n\n    def test_clear_inbox_2(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('', 50)\n        receiver.inbox = [{'size': 10},{'size': 20},{'size': 15}]\n        self.assertEqual(receiver.clear_inbox(30),None)\n        self.assertEqual(receiver.inbox, [{'size': 10},{'size': 20},{'size': 15}])\n\n    def test_clear_inbox_3(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        receiver.inbox = [{'size': 10}, {'size': 20}, {'size': 15}]\n        self.assertEqual(receiver.clear_inbox(50), None)\n\n    def test_clear_inbox_4(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        receiver.inbox = [{'size': 10}, {'size': 20}, {'size': 15}]\n        receiver.clear_inbox(45)\n        self.assertEqual(receiver.inbox, [])\n    def test_clear_inbox_5(self):\n        sender = EmailClient('sender@example.com', 100)\n        receiver = EmailClient('receiver@example.com', 50)\n        receiver.inbox = [{'size': 10}, {'size': 20}, {'size': 15}]\n        receiver.clear_inbox(10)\n        self.assertEqual(receiver.inbox, [{'size': 20}, {'size': 15}])",
                "solution_code": "def clear_inbox(self, size):\n        if len(self.addr) == 0:\n            return\n        freed_space = 0\n        while freed_space < size and self.inbox:\n            email = self.inbox[0]\n            freed_space += email['size']\n            del self.inbox[0]",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.addr",
                        "self.inbox"
                    ],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_38",
        "skeleton": "import openpyxl\n\n\nclass ExcelProcessor:\n    \"\"\"\n    This is a class for processing excel files, including readring and writing excel data, as well as processing specific operations and saving as a new excel file.\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        \"\"\"\n        Reading data from Excel files\n        :param file_name:str, Excel file name to read\n        :return:list of data, Data in Excel\n        \"\"\"\n\n\n    def write_excel(self, data, file_name):\n        \"\"\"\n        Write data to the specified Excel file\n        :param data: list, Data to be written\n        :param file_name: str, Excel file name to write to\n        :return: 0 or 1, 1 represents successful writing, 0 represents failed writing\n        >>> processor = ExcelProcessor()\n        >>> new_data = [\n        >>>     ('Name', 'Age', 'Country'),\n        >>>     ('John', 25, 'USA'),\n        >>>     ('Alice', 30, 'Canada'),\n        >>>     ('Bob', 35, 'Australia'),\n        >>>     ('Julia', 28, 'Germany')\n        >>> ]\n        >>> data = processor.write_excel(new_data, 'test_data.xlsx')\n        \"\"\"\n\n\n    def process_excel_data(self, N, save_file_name):\n        \"\"\"\n        Change the specified column in the Excel file to uppercase\n        :param N: int, The serial number of the column that want to change\n        :param save_file_name: str, source file name\n        :return:(int, str), The former is the return value of write_excel, while the latter is the saved file name of the processed data\n        >>> processor = ExcelProcessor()\n        >>> success, output_file = processor.process_excel_data(1, 'test_data.xlsx')\n        \"\"\"",
        "test": "import unittest\nimport os\n\n\nclass ExcelProcessorTestReadExcel(unittest.TestCase):\n    def test_read_excel_1(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age', 'Country'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'Canada'],\n                ['Bob', 35, 'Australia']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        data = processor.read_excel(self.test_file_name)\n        expected_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA'),\n            ('Alice', 30, 'Canada'),\n            ('Bob', 35, 'Australia')\n        ]\n        self.assertEqual(data, expected_data)\n\n    def test_read_excel_2(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age'],\n                ['John', 25],\n                ['Alice', 30],\n                ['Bob', 35]]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        data = processor.read_excel(self.test_file_name)\n        expected_data = [\n            ('Name', 'Age'),\n            ('John', 25),\n            ('Alice', 30),\n            ('Bob', 35)\n        ]\n        self.assertEqual(data, expected_data)\n\n    def test_read_excel_3(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name'],\n                ['John'],\n                ['Alice'],\n                ['Bob']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        data = processor.read_excel(self.test_file_name)\n        expected_data = [\n            ('Name',),\n            ('John',),\n            ('Alice',),\n            ('Bob',)\n        ]\n        self.assertEqual(data, expected_data)\n\n    def test_read_excel_4(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Country'],\n                ['John', 'USA'],\n                ['Alice', 'Canada'],\n                ['Bob', 'Australia']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        data = processor.read_excel(self.test_file_name)\n        expected_data = [\n            ('Name', 'Country'),\n            ('John', 'USA'),\n            ('Alice', 'Canada'),\n            ('Bob', 'Australia')\n        ]\n        self.assertEqual(data, expected_data)\n\n    def test_read_excel_5(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Country'],\n                ['John', 'USA']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        data = processor.read_excel(self.test_file_name)\n        expected_data = [\n            ('Name', 'Country'),\n            ('John', 'USA')\n        ]\n        self.assertEqual(data, expected_data)\n\n    def test_read_excel_6(self):\n        self.test_file_name = ''\n        processor = ExcelProcessor()\n        res = processor.read_excel(self.test_file_name)\n        self.assertEqual(res, None)\n\n\nclass ExcelProcessorTestWriteExcel(unittest.TestCase):\n    def test_write_excel_1(self):\n        processor = ExcelProcessor()\n        new_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA'),\n            ('Alice', 30, 'Canada'),\n            ('Bob', 35, 'Australia'),\n            ('Julia', 28, 'Germany')\n        ]\n        save_file_name = 'test_output.xlsx'\n        success = processor.write_excel(new_data, save_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(save_file_name))\n        saved_data = processor.read_excel(save_file_name)\n        self.assertEqual(saved_data, new_data)\n        os.remove(save_file_name)\n\n    def test_write_excel_2(self):\n        processor = ExcelProcessor()\n        new_data = [\n            ('Name', 'Age'),\n            ('John', 25),\n            ('Alice', 30),\n            ('Bob', 35),\n            ('Julia', 28)\n        ]\n        save_file_name = 'test_output.xlsx'\n        success = processor.write_excel(new_data, save_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(save_file_name))\n        saved_data = processor.read_excel(save_file_name)\n        self.assertEqual(saved_data, new_data)\n        os.remove(save_file_name)\n\n    def test_write_excel_3(self):\n        processor = ExcelProcessor()\n        new_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA'),\n            ('Alice', 30, 'Canada'),\n            ('Bob', 35, 'Australia')\n        ]\n        save_file_name = 'test_output.xlsx'\n        success = processor.write_excel(new_data, save_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(save_file_name))\n        saved_data = processor.read_excel(save_file_name)\n        self.assertEqual(saved_data, new_data)\n        os.remove(save_file_name)\n\n    def test_write_excel_4(self):\n        processor = ExcelProcessor()\n        new_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA'),\n            ('Alice', 30, 'Canada')\n        ]\n        save_file_name = 'test_output.xlsx'\n        success = processor.write_excel(new_data, save_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(save_file_name))\n        saved_data = processor.read_excel(save_file_name)\n        self.assertEqual(saved_data, new_data)\n        os.remove(save_file_name)\n\n    def test_write_excel_5(self):\n        processor = ExcelProcessor()\n        new_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA')\n        ]\n        save_file_name = 'test_output.xlsx'\n        success = processor.write_excel(new_data, save_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(save_file_name))\n        saved_data = processor.read_excel(save_file_name)\n        self.assertEqual(saved_data, new_data)\n        os.remove(save_file_name)\n\n    def test_write_excel_6(self):\n        processor = ExcelProcessor()\n        new_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA')\n        ]\n        save_file_name = ''\n        success = processor.write_excel(new_data, save_file_name)\n        self.assertEqual(success, 0)\n\n\nclass ExcelProcessorTestProcessExcelData(unittest.TestCase):\n    def test_process_excel_data_1(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age', 'Country'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'Canada'],\n                ['Bob', 35, 'Australia']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        N = 1\n        success, output_file = processor.process_excel_data(N, self.test_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.isfile(output_file))\n        processed_data = processor.read_excel(output_file)\n        expected_processed_data = [\n            ('Name', 'Age', 'Country', 'AGE'),\n            ('John', 25, 'USA', 25),\n            ('Alice', 30, 'Canada', 30),\n            ('Bob', 35, 'Australia', 35)\n        ]\n        self.assertEqual(processed_data, expected_processed_data)\n        os.remove(output_file)\n\n    def test_process_excel_data_2(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age', 'Country'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'Canada'],\n                ['Bob', 35, 'Australia']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        N = 0\n        success, output_file = processor.process_excel_data(N, self.test_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.isfile(output_file))\n        processed_data = processor.read_excel(output_file)\n        expected_processed_data = [\n            ('Name', 'Age', 'Country', 'NAME'),\n            ('John', 25, 'USA', 'JOHN'),\n            ('Alice', 30, 'Canada', 'ALICE'),\n            ('Bob', 35, 'Australia', 'BOB')\n        ]\n        self.assertEqual(processed_data, expected_processed_data)\n        os.remove(output_file)\n\n    def test_process_excel_data_3(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age', 'Country'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'Canada'],\n                ['Bob', 35, 'Australia']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        N = 2\n        success, output_file = processor.process_excel_data(N, self.test_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.isfile(output_file))\n        processed_data = processor.read_excel(output_file)\n        expected_processed_data = [\n            ('Name', 'Age', 'Country', 'COUNTRY'),\n            ('John', 25, 'USA', 'USA'),\n            ('Alice', 30, 'Canada', 'CANADA'),\n            ('Bob', 35, 'Australia', 'AUSTRALIA')\n        ]\n        self.assertEqual(processed_data, expected_processed_data)\n        os.remove(output_file)\n\n    def test_process_excel_data_4(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age', 'COUNTRY'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'CANADA'],\n                ['Bob', 35, 'AUSTRALIA']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        N = 2\n        success, output_file = processor.process_excel_data(N, self.test_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.isfile(output_file))\n        processed_data = processor.read_excel(output_file)\n        expected_processed_data = [\n            ('Name', 'Age', 'COUNTRY', 'COUNTRY'),\n            ('John', 25, 'USA', 'USA'),\n            ('Alice', 30, 'CANADA', 'CANADA'),\n            ('Bob', 35, 'AUSTRALIA', 'AUSTRALIA')\n        ]\n        self.assertEqual(processed_data, expected_processed_data)\n        os.remove(output_file)\n\n    def test_process_excel_data_5(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'AGE', 'COUNTRY'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'CANADA'],\n                ['Bob', 35, 'AUSTRALIA']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        N = 1\n        success, output_file = processor.process_excel_data(N, self.test_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.isfile(output_file))\n        processed_data = processor.read_excel(output_file)\n        expected_processed_data = [\n            ('Name', 'AGE', 'COUNTRY', 'AGE'),\n            ('John', 25, 'USA', 25),\n            ('Alice', 30, 'CANADA', 30),\n            ('Bob', 35, 'AUSTRALIA', 35)\n        ]\n        self.assertEqual(processed_data, expected_processed_data)\n        os.remove(output_file)\n\n    def test_process_excel_data_6(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'AGE', 'COUNTRY'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'CANADA'],\n                ['Bob', 35, 'AUSTRALIA']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        res = processor.process_excel_data(100, self.test_file_name)\n        self.assertEqual(res, 0)\n\n\nclass ExcelProcessorTest(unittest.TestCase):\n    def test_ExcelProcessor(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age', 'Country'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'Canada'],\n                ['Bob', 35, 'Australia']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        data = processor.read_excel(self.test_file_name)\n        expected_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA'),\n            ('Alice', 30, 'Canada'),\n            ('Bob', 35, 'Australia')\n        ]\n        self.assertEqual(data, expected_data)\n\n        processor = ExcelProcessor()\n        new_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA'),\n            ('Alice', 30, 'Canada'),\n            ('Bob', 35, 'Australia'),\n            ('Julia', 28, 'Germany')\n        ]\n        save_file_name = 'test_output.xlsx'\n        success = processor.write_excel(new_data, save_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(save_file_name))\n        saved_data = processor.read_excel(save_file_name)\n        self.assertEqual(saved_data, new_data)\n        os.remove(save_file_name)\n\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age', 'Country'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'Canada'],\n                ['Bob', 35, 'Australia']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        N = 1\n        success, output_file = processor.process_excel_data(N, self.test_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.isfile(output_file))\n        processed_data = processor.read_excel(output_file)\n        expected_processed_data = [\n            ('Name', 'Age', 'Country', 'AGE'),\n            ('John', 25, 'USA', 25),\n            ('Alice', 30, 'Canada', 30),\n            ('Bob', 35, 'Australia', 35)\n        ]\n        self.assertEqual(processed_data, expected_processed_data)\n        os.remove(output_file)",
        "solution_code": "import openpyxl\n\n\nclass ExcelProcessor:\n    def __init__(self):\n        pass\n\n    def read_excel(self, file_name):\n        data = []\n        try:\n            workbook = openpyxl.load_workbook(file_name)\n            sheet = workbook.active\n            for row in sheet.iter_rows(values_only=True):\n                data.append(row)\n            workbook.close()\n            return data\n        except:\n            return None\n\n    def write_excel(self, data, file_name):\n        try:\n            workbook = openpyxl.Workbook()\n            sheet = workbook.active\n            for row in data:\n                sheet.append(row)\n            workbook.save(file_name)\n            workbook.close()\n            return 1\n        except:\n            return 0\n\n    def process_excel_data(self, N, save_file_name):\n        data = self.read_excel(save_file_name)\n        if data is None or N >= len(data[0]):\n            return 0\n        new_data = []\n        for row in data:\n            new_row = list(row[:])\n            if not str(row[N]).isdigit():\n                new_row.append(str(row[N]).upper())\n            else:\n                new_row.append(row[N])\n            new_data.append(new_row)\n        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'\n        success = self.write_excel(new_data, new_file_name)\n        return success, new_file_name",
        "import_statement": [
            "import openpyxl"
        ],
        "class_description": "    \"\"\"\n    This is a class for processing excel files, including readring and writing excel data, as well as processing specific operations and saving as a new excel file.\n    \"\"\"\n",
        "class_name": "ExcelProcessor",
        "test_classes": [
            "ExcelProcessorTestReadExcel",
            "ExcelProcessorTestWriteExcel",
            "ExcelProcessorTestProcessExcelData",
            "ExcelProcessorTest"
        ],
        "class_constructor": "class ExcelProcessor: \n    def __init__(self):\n        pass\n\n",
        "fields": [],
        "methods_info": [
            {
                "method_name": "read_excel",
                "method_description": "def read_excel(self, file_name):\n        \"\"\"\n        Reading data from Excel files\n        :param file_name:str, Excel file name to read\n        :return:list of data, Data in Excel\n        \"\"\"",
                "test_class": "ExcelProcessorTestReadExcel",
                "test_code": "class ExcelProcessorTestReadExcel(unittest.TestCase):\n    def test_read_excel_1(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age', 'Country'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'Canada'],\n                ['Bob', 35, 'Australia']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        data = processor.read_excel(self.test_file_name)\n        expected_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA'),\n            ('Alice', 30, 'Canada'),\n            ('Bob', 35, 'Australia')\n        ]\n        self.assertEqual(data, expected_data)\n\n    def test_read_excel_2(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age'],\n                ['John', 25],\n                ['Alice', 30],\n                ['Bob', 35]]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        data = processor.read_excel(self.test_file_name)\n        expected_data = [\n            ('Name', 'Age'),\n            ('John', 25),\n            ('Alice', 30),\n            ('Bob', 35)\n        ]\n        self.assertEqual(data, expected_data)\n\n    def test_read_excel_3(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name'],\n                ['John'],\n                ['Alice'],\n                ['Bob']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        data = processor.read_excel(self.test_file_name)\n        expected_data = [\n            ('Name',),\n            ('John',),\n            ('Alice',),\n            ('Bob',)\n        ]\n        self.assertEqual(data, expected_data)\n\n    def test_read_excel_4(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Country'],\n                ['John', 'USA'],\n                ['Alice', 'Canada'],\n                ['Bob', 'Australia']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        data = processor.read_excel(self.test_file_name)\n        expected_data = [\n            ('Name', 'Country'),\n            ('John', 'USA'),\n            ('Alice', 'Canada'),\n            ('Bob', 'Australia')\n        ]\n        self.assertEqual(data, expected_data)\n\n    def test_read_excel_5(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Country'],\n                ['John', 'USA']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        data = processor.read_excel(self.test_file_name)\n        expected_data = [\n            ('Name', 'Country'),\n            ('John', 'USA')\n        ]\n        self.assertEqual(data, expected_data)\n\n    def test_read_excel_6(self):\n        self.test_file_name = ''\n        processor = ExcelProcessor()\n        res = processor.read_excel(self.test_file_name)\n        self.assertEqual(res, None)",
                "solution_code": "def read_excel(self, file_name):\n        data = []\n        try:\n            workbook = openpyxl.load_workbook(file_name)\n            sheet = workbook.active\n            for row in sheet.iter_rows(values_only=True):\n                data.append(row)\n            workbook.close()\n            return data\n        except:\n            return None",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "openpyxl"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "write_excel",
                "method_description": "def write_excel(self, data, file_name):\n        \"\"\"\n        Write data to the specified Excel file\n        :param data: list, Data to be written\n        :param file_name: str, Excel file name to write to\n        :return: 0 or 1, 1 represents successful writing, 0 represents failed writing\n        >>> processor = ExcelProcessor()\n        >>> new_data = [\n        >>>     ('Name', 'Age', 'Country'),\n        >>>     ('John', 25, 'USA'),\n        >>>     ('Alice', 30, 'Canada'),\n        >>>     ('Bob', 35, 'Australia'),\n        >>>     ('Julia', 28, 'Germany')\n        >>> ]\n        >>> data = processor.write_excel(new_data, 'test_data.xlsx')\n        \"\"\"",
                "test_class": "ExcelProcessorTestWriteExcel",
                "test_code": "class ExcelProcessorTestWriteExcel(unittest.TestCase):\n    def test_write_excel_1(self):\n        processor = ExcelProcessor()\n        new_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA'),\n            ('Alice', 30, 'Canada'),\n            ('Bob', 35, 'Australia'),\n            ('Julia', 28, 'Germany')\n        ]\n        save_file_name = 'test_output.xlsx'\n        success = processor.write_excel(new_data, save_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(save_file_name))\n        saved_data = processor.read_excel(save_file_name)\n        self.assertEqual(saved_data, new_data)\n        os.remove(save_file_name)\n\n    def test_write_excel_2(self):\n        processor = ExcelProcessor()\n        new_data = [\n            ('Name', 'Age'),\n            ('John', 25),\n            ('Alice', 30),\n            ('Bob', 35),\n            ('Julia', 28)\n        ]\n        save_file_name = 'test_output.xlsx'\n        success = processor.write_excel(new_data, save_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(save_file_name))\n        saved_data = processor.read_excel(save_file_name)\n        self.assertEqual(saved_data, new_data)\n        os.remove(save_file_name)\n\n    def test_write_excel_3(self):\n        processor = ExcelProcessor()\n        new_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA'),\n            ('Alice', 30, 'Canada'),\n            ('Bob', 35, 'Australia')\n        ]\n        save_file_name = 'test_output.xlsx'\n        success = processor.write_excel(new_data, save_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(save_file_name))\n        saved_data = processor.read_excel(save_file_name)\n        self.assertEqual(saved_data, new_data)\n        os.remove(save_file_name)\n\n    def test_write_excel_4(self):\n        processor = ExcelProcessor()\n        new_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA'),\n            ('Alice', 30, 'Canada')\n        ]\n        save_file_name = 'test_output.xlsx'\n        success = processor.write_excel(new_data, save_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(save_file_name))\n        saved_data = processor.read_excel(save_file_name)\n        self.assertEqual(saved_data, new_data)\n        os.remove(save_file_name)\n\n    def test_write_excel_5(self):\n        processor = ExcelProcessor()\n        new_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA')\n        ]\n        save_file_name = 'test_output.xlsx'\n        success = processor.write_excel(new_data, save_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(save_file_name))\n        saved_data = processor.read_excel(save_file_name)\n        self.assertEqual(saved_data, new_data)\n        os.remove(save_file_name)\n\n    def test_write_excel_6(self):\n        processor = ExcelProcessor()\n        new_data = [\n            ('Name', 'Age', 'Country'),\n            ('John', 25, 'USA')\n        ]\n        save_file_name = ''\n        success = processor.write_excel(new_data, save_file_name)\n        self.assertEqual(success, 0)",
                "solution_code": "def write_excel(self, data, file_name):\n        try:\n            workbook = openpyxl.Workbook()\n            sheet = workbook.active\n            for row in data:\n                sheet.append(row)\n            workbook.save(file_name)\n            workbook.close()\n            return 1\n        except:\n            return 0",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "openpyxl"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "process_excel_data",
                "method_description": "def process_excel_data(self, N, save_file_name):\n        \"\"\"\n        Change the specified column in the Excel file to uppercase\n        :param N: int, The serial number of the column that want to change\n        :param save_file_name: str, source file name\n        :return:(int, str), The former is the return value of write_excel, while the latter is the saved file name of the processed data\n        >>> processor = ExcelProcessor()\n        >>> success, output_file = processor.process_excel_data(1, 'test_data.xlsx')\n        \"\"\"",
                "test_class": "ExcelProcessorTestProcessExcelData",
                "test_code": "class ExcelProcessorTestProcessExcelData(unittest.TestCase):\n    def test_process_excel_data_1(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age', 'Country'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'Canada'],\n                ['Bob', 35, 'Australia']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        N = 1\n        success, output_file = processor.process_excel_data(N, self.test_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.isfile(output_file))\n        processed_data = processor.read_excel(output_file)\n        expected_processed_data = [\n            ('Name', 'Age', 'Country', 'AGE'),\n            ('John', 25, 'USA', 25),\n            ('Alice', 30, 'Canada', 30),\n            ('Bob', 35, 'Australia', 35)\n        ]\n        self.assertEqual(processed_data, expected_processed_data)\n        os.remove(output_file)\n\n    def test_process_excel_data_2(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age', 'Country'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'Canada'],\n                ['Bob', 35, 'Australia']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        N = 0\n        success, output_file = processor.process_excel_data(N, self.test_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.isfile(output_file))\n        processed_data = processor.read_excel(output_file)\n        expected_processed_data = [\n            ('Name', 'Age', 'Country', 'NAME'),\n            ('John', 25, 'USA', 'JOHN'),\n            ('Alice', 30, 'Canada', 'ALICE'),\n            ('Bob', 35, 'Australia', 'BOB')\n        ]\n        self.assertEqual(processed_data, expected_processed_data)\n        os.remove(output_file)\n\n    def test_process_excel_data_3(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age', 'Country'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'Canada'],\n                ['Bob', 35, 'Australia']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        N = 2\n        success, output_file = processor.process_excel_data(N, self.test_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.isfile(output_file))\n        processed_data = processor.read_excel(output_file)\n        expected_processed_data = [\n            ('Name', 'Age', 'Country', 'COUNTRY'),\n            ('John', 25, 'USA', 'USA'),\n            ('Alice', 30, 'Canada', 'CANADA'),\n            ('Bob', 35, 'Australia', 'AUSTRALIA')\n        ]\n        self.assertEqual(processed_data, expected_processed_data)\n        os.remove(output_file)\n\n    def test_process_excel_data_4(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'Age', 'COUNTRY'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'CANADA'],\n                ['Bob', 35, 'AUSTRALIA']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        N = 2\n        success, output_file = processor.process_excel_data(N, self.test_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.isfile(output_file))\n        processed_data = processor.read_excel(output_file)\n        expected_processed_data = [\n            ('Name', 'Age', 'COUNTRY', 'COUNTRY'),\n            ('John', 25, 'USA', 'USA'),\n            ('Alice', 30, 'CANADA', 'CANADA'),\n            ('Bob', 35, 'AUSTRALIA', 'AUSTRALIA')\n        ]\n        self.assertEqual(processed_data, expected_processed_data)\n        os.remove(output_file)\n\n    def test_process_excel_data_5(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'AGE', 'COUNTRY'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'CANADA'],\n                ['Bob', 35, 'AUSTRALIA']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        N = 1\n        success, output_file = processor.process_excel_data(N, self.test_file_name)\n        self.assertTrue(success)\n        self.assertTrue(os.path.isfile(output_file))\n        processed_data = processor.read_excel(output_file)\n        expected_processed_data = [\n            ('Name', 'AGE', 'COUNTRY', 'AGE'),\n            ('John', 25, 'USA', 25),\n            ('Alice', 30, 'CANADA', 30),\n            ('Bob', 35, 'AUSTRALIA', 35)\n        ]\n        self.assertEqual(processed_data, expected_processed_data)\n        os.remove(output_file)\n\n    def test_process_excel_data_6(self):\n        self.test_file_name = 'test_data.xlsx'\n        data = [['Name', 'AGE', 'COUNTRY'],\n                ['John', 25, 'USA'],\n                ['Alice', 30, 'CANADA'],\n                ['Bob', 35, 'AUSTRALIA']]\n        workbook = openpyxl.Workbook()\n        sheet = workbook.active\n        for row in data:\n            sheet.append(row)\n        workbook.save(self.test_file_name)\n        workbook.close()\n\n        processor = ExcelProcessor()\n        res = processor.process_excel_data(100, self.test_file_name)\n        self.assertEqual(res, 0)",
                "solution_code": "def process_excel_data(self, N, save_file_name):\n        data = self.read_excel(save_file_name)\n        if data is None or N >= len(data[0]):\n            return 0\n        new_data = []\n        for row in data:\n            new_row = list(row[:])\n            if not str(row[N]).isdigit():\n                new_row.append(str(row[N]).upper())\n            else:\n                new_row.append(row[N])\n            new_data.append(new_row)\n        new_file_name = save_file_name.split('.')[0] + '_process.xlsx'\n        success = self.write_excel(new_data, new_file_name)\n        return success, new_file_name",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "read_excel",
                        "write_excel"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_39",
        "skeleton": "class ExpressionCalculator:\n    \"\"\"\n    This is a class in Python that can perform calculations with basic arithmetic operations, including addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n    def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given postfix expression\n        :param expression: string, the postfix expression to be calculated\n        :return: float, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.calculate(\"2 + 3 * 4\")\n        14.0\n\n        \"\"\"\n\n\n    def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation\n        :param expression: string, the infix expression to be prepared\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.prepare(\"2+3*4\")\n\n        expression_calculator.postfix_stack = ['2', '3', '4', '*', '+']\n        \"\"\"\n\n\n    @staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.is_operator(\"+\")\n        True\n\n        \"\"\"\n\n\n    def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.compare(\"+\", \"-\")\n        True\n\n        \"\"\"\n\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator\n        :param first_value: string, the first operand\n        :param second_value: string, the second operand\n        :param current_op: string, the operator\n        :return: decimal.Decimal, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator._calculate(\"2\", \"3\", \"+\")\n        5.0\n\n        \"\"\"\n\n\n    @staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.transform(\"2 + 3 * 4\")\n        \"2+3*4\"\n\n        \"\"\"",
        "test": "import unittest\n\n\nclass ExpressionCalculatorTestCalculate(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_calculate_1(self):\n        result = self.expression_calculator.calculate(\"2 + 3 * 4\")\n        self.assertEqual(result, 14.0)\n\n    def test_calculate_2(self):\n        result = self.expression_calculator.calculate(\"2 + 3 + 4\")\n        self.assertEqual(result, 9.0)\n\n    def test_calculate_3(self):\n        result = self.expression_calculator.calculate(\"2 * 3 * 4\")\n        self.assertEqual(result, 24.0)\n\n    def test_calculate_4(self):\n        result = self.expression_calculator.calculate(\"2 + 4 / 4\")\n        self.assertEqual(result, 3.0)\n\n    def test_calculate_5(self):\n        result = self.expression_calculator.calculate(\"(2 + 3) * 4\")\n        self.assertEqual(result, 20.0)\n\n\nclass ExpressionCalculatorTestPrepare(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_prepare_1(self):\n        self.expression_calculator.prepare(\"2+3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '*', '+']))\n\n    def test_prepare_2(self):\n        self.expression_calculator.prepare(\"2+3/4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '/', '+']))\n\n    def test_prepare_3(self):\n        self.expression_calculator.prepare(\"2-3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '*', '-']))\n\n    def test_prepare_4(self):\n        self.expression_calculator.prepare(\"1+3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['1', '3', '4', '*', '+']))\n\n    def test_prepare_5(self):\n        self.expression_calculator.prepare(\"(2+3)*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '+', '4', '*']))\n\n    def test_prepare_6(self):\n        self.expression_calculator.prepare(\"\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque([]))\n\n\nclass ExpressionCalculatorTestIsOperator(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_is_operator_1(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"+\"))\n\n    def test_is_operator_2(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"-\"))\n\n    def test_is_operator_3(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"*\"))\n\n    def test_is_operator_4(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"/\"))\n\n    def test_is_operator_5(self):\n        self.assertFalse(self.expression_calculator.is_operator(\"5\"))\n\n\nclass ExpressionCalculatorTestCompare(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_compare_1(self):\n        result = self.expression_calculator.compare(\"+\", \"-\")\n        self.assertTrue(result)\n\n    def test_compare_2(self):\n        result = self.expression_calculator.compare(\"*\", \"/\")\n        self.assertTrue(result)\n\n    def test_compare_3(self):\n        result = self.expression_calculator.compare(\"+\", \"*\")\n        self.assertTrue(result)\n\n    def test_compare_4(self):\n        result = self.expression_calculator.compare(\"*\", \"+\")\n        self.assertFalse(result)\n\n    def test_compare_5(self):\n        result = self.expression_calculator.compare(\"/\", \"+\")\n        self.assertFalse(result)\n\n    def test_compare_6(self):\n        result = self.expression_calculator.compare(\"%\", \"+\")\n        self.assertFalse(result)\n\n    def test_compare_7(self):\n        result = self.expression_calculator.compare(\"+\", \"%\")\n        self.assertTrue(result)\n\n\nclass ExpressionCalculatorTestCalculateMethod(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_calculate_method_1(self):\n        result = self.expression_calculator._calculate(\"2\", \"3\", \"+\")\n        self.assertEqual(result, Decimal(5.0))\n\n    def test_calculate_method_2(self):\n        result = self.expression_calculator._calculate(\"3\", \"2\", \"-\")\n        self.assertEqual(result, Decimal(1.0))\n\n    def test_calculate_method_3(self):\n        result = self.expression_calculator._calculate(\"2\", \"3\", \"*\")\n        self.assertEqual(result, Decimal(6.0))\n\n    def test_calculate_method_4(self):\n        result = self.expression_calculator._calculate(\"3\", \"3\", \"/\")\n        self.assertEqual(result, Decimal(1.0))\n\n    def test_calculate_method_5(self):\n        result = self.expression_calculator._calculate(\"6\", \"2\", \"/\")\n        self.assertEqual(result, Decimal(3.0))\n\n    def test_calculate_method_6(self):\n        result = self.expression_calculator._calculate(\"6\", \"2\", \"%\")\n        self.assertEqual(result, Decimal(0.0))\n\n    def test_calculate_method_7(self):\n        try:\n            self.expression_calculator._calculate(\"6\", \"2\", \"??\")\n        except:\n            pass\n\n\nclass ExpressionCalculatorTestTransform(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_transform_1(self):\n        result = self.expression_calculator.transform(\"2 + 3 * 4\")\n        self.assertEqual(result, \"2+3*4\")\n\n    def test_transform_2(self):\n        result = self.expression_calculator.transform(\"2 + 3 / 4\")\n        self.assertEqual(result, \"2+3/4\")\n\n    def test_transform_3(self):\n        result = self.expression_calculator.transform(\"2 - 3 * 4\")\n        self.assertEqual(result, \"2-3*4\")\n\n    def test_transform_4(self):\n        result = self.expression_calculator.transform(\"1 + 3 * 4\")\n        self.assertEqual(result, \"1+3*4\")\n\n    def test_transform_5(self):\n        result = self.expression_calculator.transform(\"-2 + (-3) * 4\")\n        self.assertEqual(result, \"~2+(~3)*4\")\n\n    def test_transform_6(self):\n        result = self.expression_calculator.transform(\"~(1 + 1)\")\n        self.assertEqual(result, \"0-(1+1)\")\n\n\nclass ExpressionCalculatorTest(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_ExpressionCalculator(self):\n        result = self.expression_calculator.calculate(\"2 + 3 * 4\")\n        self.assertEqual(result, 14.0)\n\n        self.expression_calculator.prepare(\"2+3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '*', '+']))\n\n        self.assertTrue(self.expression_calculator.is_operator(\"+\"))\n\n        result = self.expression_calculator.compare(\"+\", \"-\")\n        self.assertTrue(result)\n\n        result = self.expression_calculator._calculate(\"2\", \"3\", \"+\")\n        self.assertEqual(result, Decimal(5.0))\n\n        result = self.expression_calculator.transform(\"2 + 3 * 4\")\n        self.assertEqual(result, \"2+3*4\")",
        "solution_code": "import re\nfrom collections import deque\nfrom decimal import Decimal\n\n\nclass ExpressionCalculator:\n    def __init__(self):\n        self.postfix_stack = deque()\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n    def calculate(self, expression):\n        self.prepare(self.transform(expression))\n\n        result_stack = deque()\n        self.postfix_stack.reverse()\n\n        while self.postfix_stack:\n            current_op = self.postfix_stack.pop()\n            if not self.is_operator(current_op):\n                current_op = current_op.replace(\"~\", \"-\")\n                result_stack.append(current_op)\n            else:\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n\n                first_value = first_value.replace(\"~\", \"-\")\n                second_value = second_value.replace(\"~\", \"-\")\n\n                temp_result = self._calculate(first_value, second_value, current_op)\n                result_stack.append(str(temp_result))\n\n        return float(eval(\"*\".join(result_stack)))\n\n    def prepare(self, expression):\n        op_stack = deque([','])\n        arr = list(expression)\n        current_index = 0\n        count = 0\n\n        for i, current_op in enumerate(arr):\n            if self.is_operator(current_op):\n                if count > 0:\n                    self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n                peek_op = op_stack[-1]\n                if current_op == ')':\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(str(op_stack.pop()))\n                    op_stack.pop()\n                else:\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(str(op_stack.pop()))\n                        peek_op = op_stack[-1]\n                    op_stack.append(current_op)\n\n                count = 0\n                current_index = i + 1\n            else:\n                count += 1\n\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):\n            self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(str(op_stack.pop()))\n\n    @staticmethod\n    def is_operator(c):\n        return c in {'+', '-', '*', '/', '(', ')', '%'}\n\n    def compare(self, cur, peek):\n        if cur == '%':\n            cur = '/'\n        if peek == '%':\n            peek = '/'\n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]\n\n    @staticmethod\n    def _calculate(first_value, second_value, current_op):\n        if current_op == '+':\n            return Decimal(first_value) + Decimal(second_value)\n        elif current_op == '-':\n            return Decimal(first_value) - Decimal(second_value)\n        elif current_op == '*':\n            return Decimal(first_value) * Decimal(second_value)\n        elif current_op == '/':\n            return Decimal(first_value) / Decimal(second_value)\n        elif current_op == '%':\n            return Decimal(first_value) % Decimal(second_value)\n        else:\n            raise ValueError(\"Unexpected operator: {}\".format(current_op))\n\n    @staticmethod\n    def transform(expression):\n        expression = re.sub(r\"\\s+\", \"\", expression)\n        expression = re.sub(r\"=$\", \"\", expression)\n        arr = list(expression)\n\n        for i, c in enumerate(arr):\n            if c == '-':\n                if i == 0:\n                    arr[i] = '~'\n                else:\n                    prev_c = arr[i - 1]\n                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:\n                        arr[i] = '~'\n\n        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):\n            arr[0] = '-'\n            return \"0\" + \"\".join(arr)\n        else:\n            return \"\".join(arr)",
        "import_statement": [
            "import re",
            "from collections import deque",
            "from decimal import Decimal"
        ],
        "class_description": "    \"\"\"\n    This is a class in Python that can perform calculations with basic arithmetic operations, including addition, subtraction, multiplication, division, and modulo.\n    \"\"\"\n",
        "class_name": "ExpressionCalculator",
        "test_classes": [
            "ExpressionCalculatorTestCalculate",
            "ExpressionCalculatorTestPrepare",
            "ExpressionCalculatorTestIsOperator",
            "ExpressionCalculatorTestCompare",
            "ExpressionCalculatorTestCalculateMethod",
            "ExpressionCalculatorTestTransform",
            "ExpressionCalculatorTest"
        ],
        "class_constructor": "class ExpressionCalculator: \n    def __init__(self):\n        \"\"\"\n        Initialize the expression calculator\n        \"\"\"\n        self.postfix_stack = deque()\n        self.operat_priority = [0, 3, 2, 1, -1, 1, 0, 2]\n\n",
        "fields": [
            "self.operat_priority",
            "self.postfix_stack"
        ],
        "methods_info": [
            {
                "method_name": "calculate",
                "method_description": "def calculate(self, expression):\n        \"\"\"\n        Calculate the result of the given postfix expression\n        :param expression: string, the postfix expression to be calculated\n        :return: float, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.calculate(\"2 + 3 * 4\")\n        14.0\n\n        \"\"\"",
                "test_class": "ExpressionCalculatorTestCalculate",
                "test_code": "class ExpressionCalculatorTestCalculate(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_calculate_1(self):\n        result = self.expression_calculator.calculate(\"2 + 3 * 4\")\n        self.assertEqual(result, 14.0)\n\n    def test_calculate_2(self):\n        result = self.expression_calculator.calculate(\"2 + 3 + 4\")\n        self.assertEqual(result, 9.0)\n\n    def test_calculate_3(self):\n        result = self.expression_calculator.calculate(\"2 * 3 * 4\")\n        self.assertEqual(result, 24.0)\n\n    def test_calculate_4(self):\n        result = self.expression_calculator.calculate(\"2 + 4 / 4\")\n        self.assertEqual(result, 3.0)\n\n    def test_calculate_5(self):\n        result = self.expression_calculator.calculate(\"(2 + 3) * 4\")\n        self.assertEqual(result, 20.0)",
                "solution_code": "def calculate(self, expression):\n        self.prepare(self.transform(expression))\n\n        result_stack = deque()\n        self.postfix_stack.reverse()\n\n        while self.postfix_stack:\n            current_op = self.postfix_stack.pop()\n            if not self.is_operator(current_op):\n                current_op = current_op.replace(\"~\", \"-\")\n                result_stack.append(current_op)\n            else:\n                second_value = result_stack.pop()\n                first_value = result_stack.pop()\n\n                first_value = first_value.replace(\"~\", \"-\")\n                second_value = second_value.replace(\"~\", \"-\")\n\n                temp_result = self._calculate(first_value, second_value, current_op)\n                result_stack.append(str(temp_result))\n\n        return float(eval(\"*\".join(result_stack)))",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "re",
                        "deque"
                    ],
                    "field_dependencies": [
                        "self.postfix_stack"
                    ],
                    "method_dependencies": [
                        "prepare",
                        "is_operator",
                        "_calculate",
                        "transform"
                    ]
                }
            },
            {
                "method_name": "prepare",
                "method_description": "def prepare(self, expression):\n        \"\"\"\n        Prepare the infix expression for conversion to postfix notation\n        :param expression: string, the infix expression to be prepared\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.prepare(\"2+3*4\")\n\n        expression_calculator.postfix_stack = ['2', '3', '4', '*', '+']\n        \"\"\"",
                "test_class": "ExpressionCalculatorTestPrepare",
                "test_code": "class ExpressionCalculatorTestPrepare(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_prepare_1(self):\n        self.expression_calculator.prepare(\"2+3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '*', '+']))\n\n    def test_prepare_2(self):\n        self.expression_calculator.prepare(\"2+3/4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '/', '+']))\n\n    def test_prepare_3(self):\n        self.expression_calculator.prepare(\"2-3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '4', '*', '-']))\n\n    def test_prepare_4(self):\n        self.expression_calculator.prepare(\"1+3*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['1', '3', '4', '*', '+']))\n\n    def test_prepare_5(self):\n        self.expression_calculator.prepare(\"(2+3)*4\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque(['2', '3', '+', '4', '*']))\n\n    def test_prepare_6(self):\n        self.expression_calculator.prepare(\"\")\n        self.assertEqual(self.expression_calculator.postfix_stack, deque([]))",
                "solution_code": "def prepare(self, expression):\n        op_stack = deque([','])\n        arr = list(expression)\n        current_index = 0\n        count = 0\n\n        for i, current_op in enumerate(arr):\n            if self.is_operator(current_op):\n                if count > 0:\n                    self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n                peek_op = op_stack[-1]\n                if current_op == ')':\n                    while op_stack[-1] != '(':\n                        self.postfix_stack.append(str(op_stack.pop()))\n                    op_stack.pop()\n                else:\n                    while current_op != '(' and peek_op != ',' and self.compare(current_op, peek_op):\n                        self.postfix_stack.append(str(op_stack.pop()))\n                        peek_op = op_stack[-1]\n                    op_stack.append(current_op)\n\n                count = 0\n                current_index = i + 1\n            else:\n                count += 1\n\n        if count > 1 or (count == 1 and not self.is_operator(arr[current_index])):\n            self.postfix_stack.append(\"\".join(arr[current_index: current_index + count]))\n\n        while op_stack[-1] != ',':\n            self.postfix_stack.append(str(op_stack.pop()))",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "re",
                        "deque"
                    ],
                    "field_dependencies": [
                        "self.postfix_stack"
                    ],
                    "method_dependencies": [
                        "is_operator",
                        "compare"
                    ]
                }
            },
            {
                "method_name": "is_operator",
                "method_description": "@staticmethod\n    def is_operator(c):\n        \"\"\"\n        Check if a character is an operator in {'+', '-', '*', '/', '(', ')', '%'}\n        :param c: string, the character to be checked\n        :return: bool, True if the character is an operator, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.is_operator(\"+\")\n        True\n\n        \"\"\"",
                "test_class": "ExpressionCalculatorTestIsOperator",
                "test_code": "class ExpressionCalculatorTestIsOperator(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_is_operator_1(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"+\"))\n\n    def test_is_operator_2(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"-\"))\n\n    def test_is_operator_3(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"*\"))\n\n    def test_is_operator_4(self):\n        self.assertTrue(self.expression_calculator.is_operator(\"/\"))\n\n    def test_is_operator_5(self):\n        self.assertFalse(self.expression_calculator.is_operator(\"5\"))",
                "solution_code": "@staticmethod\n    def is_operator(c):\n        return c in {'+', '-', '*', '/', '(', ')', '%'}",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "compare",
                "method_description": "def compare(self, cur, peek):\n        \"\"\"\n        Compare the precedence of two operators\n        :param cur: string, the current operator\n        :param peek: string, the operator at the top of the operator stack\n        :return: bool, True if the current operator has higher or equal precedence, False otherwise\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.compare(\"+\", \"-\")\n        True\n\n        \"\"\"",
                "test_class": "ExpressionCalculatorTestCompare",
                "test_code": "class ExpressionCalculatorTestCompare(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_compare_1(self):\n        result = self.expression_calculator.compare(\"+\", \"-\")\n        self.assertTrue(result)\n\n    def test_compare_2(self):\n        result = self.expression_calculator.compare(\"*\", \"/\")\n        self.assertTrue(result)\n\n    def test_compare_3(self):\n        result = self.expression_calculator.compare(\"+\", \"*\")\n        self.assertTrue(result)\n\n    def test_compare_4(self):\n        result = self.expression_calculator.compare(\"*\", \"+\")\n        self.assertFalse(result)\n\n    def test_compare_5(self):\n        result = self.expression_calculator.compare(\"/\", \"+\")\n        self.assertFalse(result)\n\n    def test_compare_6(self):\n        result = self.expression_calculator.compare(\"%\", \"+\")\n        self.assertFalse(result)\n\n    def test_compare_7(self):\n        result = self.expression_calculator.compare(\"+\", \"%\")\n        self.assertTrue(result)",
                "solution_code": "def compare(self, cur, peek):\n        if cur == '%':\n            cur = '/'\n        if peek == '%':\n            peek = '/'\n        return self.operat_priority[ord(peek) - 40] >= self.operat_priority[ord(cur) - 40]",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.operat_priority"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "_calculate",
                "method_description": "@staticmethod\n    def _calculate(first_value, second_value, current_op):\n        \"\"\"\n        Perform the mathematical calculation based on the given operands and operator\n        :param first_value: string, the first operand\n        :param second_value: string, the second operand\n        :param current_op: string, the operator\n        :return: decimal.Decimal, the calculated result\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator._calculate(\"2\", \"3\", \"+\")\n        5.0\n\n        \"\"\"",
                "test_class": "ExpressionCalculatorTestCalculateMethod",
                "test_code": "class ExpressionCalculatorTestCalculateMethod(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_calculate_method_1(self):\n        result = self.expression_calculator._calculate(\"2\", \"3\", \"+\")\n        self.assertEqual(result, Decimal(5.0))\n\n    def test_calculate_method_2(self):\n        result = self.expression_calculator._calculate(\"3\", \"2\", \"-\")\n        self.assertEqual(result, Decimal(1.0))\n\n    def test_calculate_method_3(self):\n        result = self.expression_calculator._calculate(\"2\", \"3\", \"*\")\n        self.assertEqual(result, Decimal(6.0))\n\n    def test_calculate_method_4(self):\n        result = self.expression_calculator._calculate(\"3\", \"3\", \"/\")\n        self.assertEqual(result, Decimal(1.0))\n\n    def test_calculate_method_5(self):\n        result = self.expression_calculator._calculate(\"6\", \"2\", \"/\")\n        self.assertEqual(result, Decimal(3.0))\n\n    def test_calculate_method_6(self):\n        result = self.expression_calculator._calculate(\"6\", \"2\", \"%\")\n        self.assertEqual(result, Decimal(0.0))\n\n    def test_calculate_method_7(self):\n        try:\n            self.expression_calculator._calculate(\"6\", \"2\", \"??\")\n        except:\n            pass",
                "solution_code": "@staticmethod\n    def _calculate(first_value, second_value, current_op):\n        if current_op == '+':\n            return Decimal(first_value) + Decimal(second_value)\n        elif current_op == '-':\n            return Decimal(first_value) - Decimal(second_value)\n        elif current_op == '*':\n            return Decimal(first_value) * Decimal(second_value)\n        elif current_op == '/':\n            return Decimal(first_value) / Decimal(second_value)\n        elif current_op == '%':\n            return Decimal(first_value) % Decimal(second_value)\n        else:\n            raise ValueError(\"Unexpected operator: {}\".format(current_op))",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "Decimal"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "transform",
                "method_description": "@staticmethod\n    def transform(expression):\n        \"\"\"\n        Transform the infix expression to a format suitable for conversion\n        :param expression: string, the infix expression to be transformed\n        :return: string, the transformed expression\n        >>> expression_calculator = ExpressionCalculator()\n        >>> expression_calculator.transform(\"2 + 3 * 4\")\n        \"2+3*4\"\n\n        \"\"\"",
                "test_class": "ExpressionCalculatorTestTransform",
                "test_code": "class ExpressionCalculatorTestTransform(unittest.TestCase):\n    def setUp(self):\n        self.expression_calculator = ExpressionCalculator()\n\n    def test_transform_1(self):\n        result = self.expression_calculator.transform(\"2 + 3 * 4\")\n        self.assertEqual(result, \"2+3*4\")\n\n    def test_transform_2(self):\n        result = self.expression_calculator.transform(\"2 + 3 / 4\")\n        self.assertEqual(result, \"2+3/4\")\n\n    def test_transform_3(self):\n        result = self.expression_calculator.transform(\"2 - 3 * 4\")\n        self.assertEqual(result, \"2-3*4\")\n\n    def test_transform_4(self):\n        result = self.expression_calculator.transform(\"1 + 3 * 4\")\n        self.assertEqual(result, \"1+3*4\")\n\n    def test_transform_5(self):\n        result = self.expression_calculator.transform(\"-2 + (-3) * 4\")\n        self.assertEqual(result, \"~2+(~3)*4\")\n\n    def test_transform_6(self):\n        result = self.expression_calculator.transform(\"~(1 + 1)\")\n        self.assertEqual(result, \"0-(1+1)\")",
                "solution_code": "@staticmethod\n    def transform(expression):\n        expression = re.sub(r\"\\s+\", \"\", expression)\n        expression = re.sub(r\"=$\", \"\", expression)\n        arr = list(expression)\n\n        for i, c in enumerate(arr):\n            if c == '-':\n                if i == 0:\n                    arr[i] = '~'\n                else:\n                    prev_c = arr[i - 1]\n                    if prev_c in {'+', '-', '*', '/', '(', 'E', 'e'}:\n                        arr[i] = '~'\n\n        if arr[0] == '~' and (len(arr) > 1 and arr[1] == '('):\n            arr[0] = '-'\n            return \"0\" + \"\".join(arr)\n        else:\n            return \"\".join(arr)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "re"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_44",
        "skeleton": "import re\nimport string\nimport gensim\nfrom bs4 import BeautifulSoup\n\nclass HtmlUtil:\n    \"\"\"\n    This is a class as util for html, supporting for formatting and extracting code from HTML text, including cleaning up the text and converting certain elements into specific marks.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a series of labels\n        \"\"\"\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        \"\"\"\n        Replace consecutive line breaks with a single line break\n        :param text: string with consecutive line breaks\n        :return:string, replaced text with single line break\n        \"\"\"\n\n    def format_line_html_text(self, html_text):\n        \"\"\"\n        get the html text without the code, and add the code tag -CODE- where the code is\n        :param html_text:string\n        :return:string\n        >>>htmlutil = HtmlUtil()\n        >>>htmlutil.format_line_html_text(<html>\n        >>> <body>\n        >>>    <h1>Title</h1>\n        >>>    <p>This is a paragraph.</p>\n        >>>    <pre>print('Hello, world!')</pre>\n        >>>    <p>Another paragraph.</p>\n        >>>    <pre><code>for i in range(5):\n        >>>    print(i)</code></pre>\n        >>>    </body>\n        >>>    </html>)\n        Title\n        This is a paragraph.\n        -CODE-\n        Another paragraph.\n        -CODE-\n        \"\"\"\n\n    def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        extract codes from the html body\n        :param html_text: string, html text\n        :return: the list of code\n        >>>htmlutil = HtmlUtil()\n        >>>htmlutil.extract_code_from_html_text(<html>\n        >>> <body>\n        >>>    <h1>Title</h1>\n        >>>    <p>This is a paragraph.</p>\n        >>>    <pre>print('Hello, world!')</pre>\n        >>>    <p>Another paragraph.</p>\n        >>>    <pre><code>for i in range(5):\n        >>>    print(i)</code></pre>\n        >>>    </body>\n        >>>    </html>)\n        [\"print('Hello, world!')\", 'for i in range(5):\\n                print(i)']\n        \"\"\"",
        "test": "import unittest\nimport sys\n\nclass HtmlUtilTestFormatLineFeed(unittest.TestCase):\n    def test_format_line_feed_1(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed('aaa\\n\\n\\n'), 'aaa\\n')\n\n    def test_format_line_feed_2(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed('aaa\\n\\n\\n\\n'), 'aaa\\n')\n\n    def test_format_line_feed_3(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed('aaa\\n\\n\\nbbb\\n\\n'), 'aaa\\nbbb\\n')\n\n    def test_format_line_feed_4(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed('ccc\\n\\n\\n'), 'ccc\\n')\n\n    def test_format_line_feed_5(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed(''), '')\n\n\nclass HtmlUtilTestFormatLineHtmlText(unittest.TestCase):\n    def test_format_line_html_text_1(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n\n    def test_format_line_html_text_2(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title2</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle2\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n\n    def test_format_line_html_text_3(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title3</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle3\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n\n    def test_format_line_html_text_4(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title4</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle4\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n\n    def test_format_line_html_text_5(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title5</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle5\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n    def test_format_line_html_text_6(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('')\n        self.assertEqual(res, '')\n\n    def test_format_line_html_text_7(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<ul><li>Item 1!</li></ul>''')\n        self.assertEqual(res, '''[-]Item 1!''')\n\n    def test_format_line_html_text_8(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<ul><li></li></ul>''')\n        self.assertEqual(res, '')\n\n    def test_format_line_html_text_9(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<p>Some sentence here.</p>''')\n        self.assertEqual(res, 'Some sentence here.')\n\n    def test_format_line_html_text_10(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<p>Some paragraph here</p><code>Code block</code>''')\n        self.assertEqual(res, '''Some paragraph here.Code block''')\n\n    def test_format_line_html_text_11(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<p>Some paragraph here</p><div>Some text here</div>''')\n        self.assertEqual(res, '''Some paragraph here.Some text here''')\n\n    def test_format_line_html_text_12(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<ul><li>Item 1</li></ul>''')\n        self.assertEqual(res, '''[-]Item 1.''')\n\n\nclass HtmlUtilTestExtractCodeFromHtmlText(unittest.TestCase):\n    def test_extract_code_from_html_text_1(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another paragraph.</p>\n                <pre><code>for i in range(5):\n                print(i)</code></pre>\n                </body>\n                </html>\n                ''')\n        self.assertEqual(res, [\"print('Hello, world!')\", 'for i in range(5):\\n                print(i)'])\n\n    def test_extract_code_from_html_text_2(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another paragraph.</p>\n                <pre><code>for i in range(4):\n                print(i)</code></pre>\n                </body>\n                </html>\n                ''')\n        self.assertEqual(res, [\"print('Hello, world!')\", 'for i in range(4):\\n                print(i)'])\n\n    def test_extract_code_from_html_text_3(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another paragraph.</p>\n                <pre><code>for i in range(3):\n                print(i)</code></pre>\n                </body>\n                </html>\n                ''')\n        self.assertEqual(res, [\"print('Hello, world!')\", 'for i in range(3):\\n                print(i)'])\n\n    def test_extract_code_from_html_text_4(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another paragraph.</p>\n                <pre><code>for i in range(2):\n                print(i)</code></pre>\n                </body>\n                </html>\n                ''')\n        self.assertEqual(res, [\"print('Hello, world!')\", 'for i in range(2):\\n                print(i)'])\n\n    def test_extract_code_from_html_text_5(self):\n        htmlutil = HtmlUtil()\n        htmlutil.CODE_MARK = 'abcdefg'\n        res = htmlutil.extract_code_from_html_text(\"\")\n        self.assertEqual(res, [])\n\n\nclass HtmlUtilTest(unittest.TestCase):\n    def test_htmlutil(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another paragraph.</p>\n                <pre><code>for i in range(5):\n                print(i)</code></pre>\n                </body>\n                </html>\n                ''')\n        self.assertEqual(res, [\"print('Hello, world!')\", 'for i in range(5):\\n                print(i)'])\n\nif __name__ == '__main__':\n    unittest.main()",
        "solution_code": "import re\nimport string\nimport gensim\nfrom bs4 import BeautifulSoup\n\n\nclass HtmlUtil:\n\n    def __init__(self):\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n\n    @staticmethod\n    def __format_line_feed(text):\n        return re.sub(re.compile(r'\\n+'), '\\n', text)\n\n    def format_line_html_text(self, html_text):\n        if html_text is None or len(html_text) == 0:\n            return ''\n        soup = BeautifulSoup(html_text, 'lxml')\n\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        for tag in code_tag:\n            tag.string = self.CODE_MARK\n\n        ul_ol_group = soup.find_all(name=['ul', 'ol'])\n        for ul_ol_item in ul_ol_group:\n            li_group = ul_ol_item.find_all('li')\n            for li_item in li_group:\n                li_item_text = li_item.get_text().strip()\n                if len(li_item_text) == 0:\n                    continue\n                if li_item_text[-1] in string.punctuation:\n                    li_item.string = '[{0}]{1}'.format('-', li_item_text)\n                    continue\n                li_item.string = '[{0}]{1}.'.format('-', li_item_text)\n\n        p_group = soup.find_all(name=['p'])\n        for p_item in p_group:\n            p_item_text = p_item.get_text().strip()\n            if p_item_text:\n                if p_item_text[-1] in string.punctuation:\n                    p_item.string = p_item_text\n                    continue\n                next_sibling = p_item.find_next_sibling()\n                if next_sibling and self.CODE_MARK in next_sibling.get_text():\n                    p_item.string = p_item_text + ':'\n                    continue\n                p_item.string = p_item_text + '.'\n\n        clean_text = gensim.utils.decode_htmlentities(soup.get_text())\n        return self.__format_line_feed(clean_text)\n\n    def extract_code_from_html_text(self, html_text):\n        text_with_code_tag = self.format_line_html_text(html_text)\n\n        if self.CODE_MARK not in text_with_code_tag:\n            return []\n\n        code_index_start = 0\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        code_count = text_with_code_tag.count(self.CODE_MARK)\n        code_list = []\n        for code_index in range(code_index_start, code_index_start + code_count):\n            code = code_tag[code_index].get_text()\n            if code:\n                code_list.append(code)\n        return code_list",
        "import_statement": [
            "import re",
            "import string",
            "import gensim",
            "from bs4 import BeautifulSoup"
        ],
        "class_description": "    \"\"\"\n    This is a class as util for html, supporting for formatting and extracting code from HTML text, including cleaning up the text and converting certain elements into specific marks.\n    \"\"\"\n",
        "class_name": "HtmlUtil",
        "test_classes": [
            "HtmlUtilTestFormatLineFeed",
            "HtmlUtilTestFormatLineHtmlText",
            "HtmlUtilTestExtractCodeFromHtmlText",
            "HtmlUtilTest"
        ],
        "class_constructor": "class HtmlUtil: \n    def __init__(self):\n        \"\"\"\n        Initialize a series of labels\n        \"\"\"\n        self.SPACE_MARK = '-SPACE-'\n        self.JSON_MARK = '-JSON-'\n        self.MARKUP_LANGUAGE_MARK = '-MARKUP_LANGUAGE-'\n        self.URL_MARK = '-URL-'\n        self.NUMBER_MARK = '-NUMBER-'\n        self.TRACE_MARK = '-TRACE-'\n        self.COMMAND_MARK = '-COMMAND-'\n        self.COMMENT_MARK = '-COMMENT-'\n        self.CODE_MARK = '-CODE-'\n",
        "fields": [
            "self.CODE_MARK",
            "self.COMMAND_MARK",
            "self.COMMENT_MARK",
            "self.JSON_MARK",
            "self.MARKUP_LANGUAGE_MARK",
            "self.NUMBER_MARK",
            "self.SPACE_MARK",
            "self.TRACE_MARK",
            "self.URL_MARK"
        ],
        "methods_info": [
            {
                "method_name": "__format_line_feed",
                "method_description": "def __format_line_feed(text):\n        \"\"\"\n        Replace consecutive line breaks with a single line break\n        :param text: string with consecutive line breaks\n        :return:string, replaced text with single line break\n        \"\"\"",
                "test_class": "HtmlUtilTestFormatLineFeed",
                "test_code": "class HtmlUtilTestFormatLineFeed(unittest.TestCase):\n    def test_format_line_feed_1(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed('aaa\\n\\n\\n'), 'aaa\\n')\n\n    def test_format_line_feed_2(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed('aaa\\n\\n\\n\\n'), 'aaa\\n')\n\n    def test_format_line_feed_3(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed('aaa\\n\\n\\nbbb\\n\\n'), 'aaa\\nbbb\\n')\n\n    def test_format_line_feed_4(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed('ccc\\n\\n\\n'), 'ccc\\n')\n\n    def test_format_line_feed_5(self):\n        self.assertEqual(HtmlUtil._HtmlUtil__format_line_feed(''), '')",
                "solution_code": "def __format_line_feed(text):\n        return re.sub(re.compile(r'\\n+'), '\\n', text)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "re"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "format_line_html_text",
                "method_description": "def format_line_html_text(self, html_text):\n        \"\"\"\n        get the html text without the code, and add the code tag -CODE- where the code is\n        :param html_text:string\n        :return:string\n        >>>htmlutil = HtmlUtil()\n        >>>htmlutil.format_line_html_text(<html>\n        >>> <body>\n        >>>    <h1>Title</h1>\n        >>>    <p>This is a paragraph.</p>\n        >>>    <pre>print('Hello, world!')</pre>\n        >>>    <p>Another paragraph.</p>\n        >>>    <pre><code>for i in range(5):\n        >>>    print(i)</code></pre>\n        >>>    </body>\n        >>>    </html>)\n        Title\n        This is a paragraph.\n        -CODE-\n        Another paragraph.\n        -CODE-\n        \"\"\"",
                "test_class": "HtmlUtilTestFormatLineHtmlText",
                "test_code": "class HtmlUtilTestFormatLineHtmlText(unittest.TestCase):\n    def test_format_line_html_text_1(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n\n    def test_format_line_html_text_2(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title2</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle2\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n\n    def test_format_line_html_text_3(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title3</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle3\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n\n    def test_format_line_html_text_4(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title4</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle4\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n\n    def test_format_line_html_text_5(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''\n        <html>\n        <body>\n        <h1>Title5</h1>\n        <p>This is a paragraph.</p>\n        <pre>print('Hello, world!')</pre>\n        <p>Another paragraph.</p>\n        <pre><code>for i in range(5):\n        print(i)</code></pre>\n        </body>\n        </html>\n        ''')\n        self.assertEqual(res, '''\nTitle5\nThis is a paragraph.\n-CODE-\nAnother paragraph.\n-CODE-\n''')\n    def test_format_line_html_text_6(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('')\n        self.assertEqual(res, '')\n\n    def test_format_line_html_text_7(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<ul><li>Item 1!</li></ul>''')\n        self.assertEqual(res, '''[-]Item 1!''')\n\n    def test_format_line_html_text_8(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<ul><li></li></ul>''')\n        self.assertEqual(res, '')\n\n    def test_format_line_html_text_9(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<p>Some sentence here.</p>''')\n        self.assertEqual(res, 'Some sentence here.')\n\n    def test_format_line_html_text_10(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<p>Some paragraph here</p><code>Code block</code>''')\n        self.assertEqual(res, '''Some paragraph here.Code block''')\n\n    def test_format_line_html_text_11(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<p>Some paragraph here</p><div>Some text here</div>''')\n        self.assertEqual(res, '''Some paragraph here.Some text here''')\n\n    def test_format_line_html_text_12(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.format_line_html_text('''<ul><li>Item 1</li></ul>''')\n        self.assertEqual(res, '''[-]Item 1.''')",
                "solution_code": "def format_line_html_text(self, html_text):\n        if html_text is None or len(html_text) == 0:\n            return ''\n        soup = BeautifulSoup(html_text, 'lxml')\n\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        for tag in code_tag:\n            tag.string = self.CODE_MARK\n\n        ul_ol_group = soup.find_all(name=['ul', 'ol'])\n        for ul_ol_item in ul_ol_group:\n            li_group = ul_ol_item.find_all('li')\n            for li_item in li_group:\n                li_item_text = li_item.get_text().strip()\n                if len(li_item_text) == 0:\n                    continue\n                if li_item_text[-1] in string.punctuation:\n                    li_item.string = '[{0}]{1}'.format('-', li_item_text)\n                    continue\n                li_item.string = '[{0}]{1}.'.format('-', li_item_text)\n\n        p_group = soup.find_all(name=['p'])\n        for p_item in p_group:\n            p_item_text = p_item.get_text().strip()\n            if p_item_text:\n                if p_item_text[-1] in string.punctuation:\n                    p_item.string = p_item_text\n                    continue\n                next_sibling = p_item.find_next_sibling()\n                if next_sibling and self.CODE_MARK in next_sibling.get_text():\n                    p_item.string = p_item_text + ':'\n                    continue\n                p_item.string = p_item_text + '.'\n\n        clean_text = gensim.utils.decode_htmlentities(soup.get_text())\n        return self.__format_line_feed(clean_text)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "string",
                        "gensim",
                        "BeautifulSoup"
                    ],
                    "field_dependencies": [
                        "self.CODE_MARK"
                    ],
                    "method_dependencies": [
                        "__format_line_feed"
                    ]
                }
            },
            {
                "method_name": "extract_code_from_html_text",
                "method_description": "def extract_code_from_html_text(self, html_text):\n        \"\"\"\n        extract codes from the html body\n        :param html_text: string, html text\n        :return: the list of code\n        >>>htmlutil = HtmlUtil()\n        >>>htmlutil.extract_code_from_html_text(<html>\n        >>> <body>\n        >>>    <h1>Title</h1>\n        >>>    <p>This is a paragraph.</p>\n        >>>    <pre>print('Hello, world!')</pre>\n        >>>    <p>Another paragraph.</p>\n        >>>    <pre><code>for i in range(5):\n        >>>    print(i)</code></pre>\n        >>>    </body>\n        >>>    </html>)\n        [\"print('Hello, world!')\", 'for i in range(5):\\n                print(i)']\n        \"\"\"",
                "test_class": "HtmlUtilTestExtractCodeFromHtmlText",
                "test_code": "class HtmlUtilTestExtractCodeFromHtmlText(unittest.TestCase):\n    def test_extract_code_from_html_text_1(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another paragraph.</p>\n                <pre><code>for i in range(5):\n                print(i)</code></pre>\n                </body>\n                </html>\n                ''')\n        self.assertEqual(res, [\"print('Hello, world!')\", 'for i in range(5):\\n                print(i)'])\n\n    def test_extract_code_from_html_text_2(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another paragraph.</p>\n                <pre><code>for i in range(4):\n                print(i)</code></pre>\n                </body>\n                </html>\n                ''')\n        self.assertEqual(res, [\"print('Hello, world!')\", 'for i in range(4):\\n                print(i)'])\n\n    def test_extract_code_from_html_text_3(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another paragraph.</p>\n                <pre><code>for i in range(3):\n                print(i)</code></pre>\n                </body>\n                </html>\n                ''')\n        self.assertEqual(res, [\"print('Hello, world!')\", 'for i in range(3):\\n                print(i)'])\n\n    def test_extract_code_from_html_text_4(self):\n        htmlutil = HtmlUtil()\n        res = htmlutil.extract_code_from_html_text('''\n                <html>\n                <body>\n                <h1>Title</h1>\n                <p>This is a paragraph.</p>\n                <pre>print('Hello, world!')</pre>\n                <p>Another paragraph.</p>\n                <pre><code>for i in range(2):\n                print(i)</code></pre>\n                </body>\n                </html>\n                ''')\n        self.assertEqual(res, [\"print('Hello, world!')\", 'for i in range(2):\\n                print(i)'])\n\n    def test_extract_code_from_html_text_5(self):\n        htmlutil = HtmlUtil()\n        htmlutil.CODE_MARK = 'abcdefg'\n        res = htmlutil.extract_code_from_html_text(\"\")\n        self.assertEqual(res, [])",
                "solution_code": "def extract_code_from_html_text(self, html_text):\n        text_with_code_tag = self.format_line_html_text(html_text)\n\n        if self.CODE_MARK not in text_with_code_tag:\n            return []\n\n        code_index_start = 0\n        soup = BeautifulSoup(html_text, 'lxml')\n        code_tag = soup.find_all(name=['pre', 'blockquote'])\n        code_count = text_with_code_tag.count(self.CODE_MARK)\n        code_list = []\n        for code_index in range(code_index_start, code_index_start + code_count):\n            code = code_tag[code_index].get_text()\n            if code:\n                code_list.append(code)\n        return code_list",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "BeautifulSoup"
                    ],
                    "field_dependencies": [
                        "self.CODE_MARK"
                    ],
                    "method_dependencies": [
                        "format_line_html_text"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_48",
        "skeleton": "import socket\nimport netifaces\n\n\nclass IpUtil:\n    \"\"\"\n    This is a class as tool for ip that can be used to obtain the local IP address, validate its validity, and also provides the functionality to retrieve the corresponding hostname.\n    \"\"\"\n\n\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv4 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv4('192.168.0.123')\n        True\n        >>> IpUtil.is_valid_ipv4('256.0.0.0')\n        False\n\n        \"\"\"\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv6 address.\n        :param ip_address:string, the IP address to check\n        :return:bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        True\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')\n        False\n\n        \"\"\"\n\n\n    @staticmethod\n    def get_hostname(ip_address):\n        \"\"\"\n        Get the hostname associated with the given IP address.\n        :param ip_address:string, the IP address to get the hostname for\n        :return: string, the hostname associated with the IP address\n        >>> IpUtil.get_hostname('110.242.68.3')\n        'www.baidu.com'\n        >>> IpUtil.get_hostname('10.0.0.1')\n\n        \"\"\"",
        "test": "import unittest\n\n\nclass IpUtilTestIsValidIpv4(unittest.TestCase):\n    def test_is_valid_ipv4_1(self):\n        result = IpUtil.is_valid_ipv4('192.168.0.123')\n        self.assertEqual(result, True)\n\n    def test_is_valid_ipv4_2(self):\n        result = IpUtil.is_valid_ipv4('10.10.10.10')\n        self.assertEqual(result, True)\n\n    def test_is_valid_ipv4_3(self):\n        result = IpUtil.is_valid_ipv4('0.0.0.0')\n        self.assertEqual(result, True)\n\n    def test_is_valid_ipv4_4(self):\n        result = IpUtil.is_valid_ipv4('abc.168.0.123')\n        self.assertEqual(result, False)\n\n    def test_is_valid_ipv4_5(self):\n        result = IpUtil.is_valid_ipv4('256.0.0.0')\n        self.assertEqual(result, False)\n\n\nclass IpUtilTestIsValidIpv6(unittest.TestCase):\n    def test_is_valid_ipv6_1(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        self.assertEqual(result, True)\n\n    def test_is_valid_ipv6_2(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')\n        self.assertEqual(result, False)\n\n    def test_is_valid_ipv6_3(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:2001:llll:8a2e:0370:7334')\n        self.assertEqual(result, False)\n\n    def test_is_valid_ipv6_4(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:llll:llll:8a2e:0370:7334')\n        self.assertEqual(result, False)\n\n    def test_is_valid_ipv6_5(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3::llll:8a2e:0370:7334')\n        self.assertEqual(result, False)\n\n\nclass IpUtilTestGetHostname(unittest.TestCase):\n    def test_get_hostname_1(self):\n        result = IpUtil.get_hostname('110.242.68.3')\n        self.assertEqual(result, None)\n\n    def test_get_hostname_2(self):\n        result = IpUtil.get_hostname('10.0.0.1')\n        self.assertEqual(result, None)\n\n    def test_get_hostname_3(self):\n        result = IpUtil.get_hostname('0.0.0.0')\n        self.assertEqual(result, 'LAPTOP-2CS86KUM')\n\n    def test_get_hostname_4(self):\n        result = IpUtil.get_hostname('0.0.0.1')\n        self.assertEqual(result, None)\n\n    def test_get_hostname_5(self):\n        result = IpUtil.get_hostname('0.0.0.2')\n        self.assertEqual(result, None)\n\n\nclass IpUtilTest(unittest.TestCase):\n    def test_IpUtil(self):\n        result = IpUtil.is_valid_ipv4('192.168.0.123')\n        self.assertEqual(result, True)\n\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        self.assertEqual(result, True)\n\n        result = IpUtil.get_hostname('110.242.68.3')\n        self.assertEqual(result, None)",
        "solution_code": "import socket\n\n\nclass IpUtil:\n\n    @staticmethod\n    def is_valid_ipv4(ip_address):\n        try:\n            socket.inet_pton(socket.AF_INET, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def is_valid_ipv6(ip_address):\n        try:\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            return False\n\n    @staticmethod\n    def get_hostname(ip_address):\n        try:\n            hostname = socket.gethostbyaddr(ip_address)[0]\n            return hostname\n        except socket.herror:\n            return None",
        "import_statement": [
            "import socket"
        ],
        "class_description": "    \"\"\"\n    This is a class as tool for ip that can be used to obtain the local IP address, validate its validity, and also provides the functionality to retrieve the corresponding hostname.\n    \"\"\"\n",
        "class_name": "IpUtil",
        "test_classes": [
            "IpUtilTestIsValidIpv4",
            "IpUtilTestIsValidIpv6",
            "IpUtilTestGetHostname",
            "IpUtilTest"
        ],
        "class_constructor": "class IpUtil: \n",
        "fields": [],
        "methods_info": [
            {
                "method_name": "is_valid_ipv4",
                "method_description": "def is_valid_ipv4(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv4 address.\n        :param ip_address: string, the IP address to check\n        :return: bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv4('192.168.0.123')\n        True\n        >>> IpUtil.is_valid_ipv4('256.0.0.0')\n        False\n\n        \"\"\"",
                "test_class": "IpUtilTestIsValidIpv4",
                "test_code": "class IpUtilTestIsValidIpv4(unittest.TestCase):\n    def test_is_valid_ipv4_1(self):\n        result = IpUtil.is_valid_ipv4('192.168.0.123')\n        self.assertEqual(result, True)\n\n    def test_is_valid_ipv4_2(self):\n        result = IpUtil.is_valid_ipv4('10.10.10.10')\n        self.assertEqual(result, True)\n\n    def test_is_valid_ipv4_3(self):\n        result = IpUtil.is_valid_ipv4('0.0.0.0')\n        self.assertEqual(result, True)\n\n    def test_is_valid_ipv4_4(self):\n        result = IpUtil.is_valid_ipv4('abc.168.0.123')\n        self.assertEqual(result, False)\n\n    def test_is_valid_ipv4_5(self):\n        result = IpUtil.is_valid_ipv4('256.0.0.0')\n        self.assertEqual(result, False)",
                "solution_code": "def is_valid_ipv4(ip_address):\n        try:\n            socket.inet_pton(socket.AF_INET, ip_address)\n            return True\n        except socket.error:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "socket"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "is_valid_ipv6",
                "method_description": "@staticmethod\n    def is_valid_ipv6(ip_address):\n        \"\"\"\n        Check if the given IP address is a valid IPv6 address.\n        :param ip_address:string, the IP address to check\n        :return:bool, True if the IP address is valid, False otherwise\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        True\n        >>> IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')\n        False\n\n        \"\"\"",
                "test_class": "IpUtilTestIsValidIpv6",
                "test_code": "class IpUtilTestIsValidIpv6(unittest.TestCase):\n    def test_is_valid_ipv6_1(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:0000:0000:8a2e:0370:7334')\n        self.assertEqual(result, True)\n\n    def test_is_valid_ipv6_2(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:::8a2e:0370:7334')\n        self.assertEqual(result, False)\n\n    def test_is_valid_ipv6_3(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:2001:llll:8a2e:0370:7334')\n        self.assertEqual(result, False)\n\n    def test_is_valid_ipv6_4(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3:llll:llll:8a2e:0370:7334')\n        self.assertEqual(result, False)\n\n    def test_is_valid_ipv6_5(self):\n        result = IpUtil.is_valid_ipv6('2001:0db8:85a3::llll:8a2e:0370:7334')\n        self.assertEqual(result, False)",
                "solution_code": "@staticmethod\n    def is_valid_ipv6(ip_address):\n        try:\n            socket.inet_pton(socket.AF_INET6, ip_address)\n            return True\n        except socket.error:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "socket"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "get_hostname",
                "method_description": "@staticmethod\n    def get_hostname(ip_address):\n        \"\"\"\n        Get the hostname associated with the given IP address.\n        :param ip_address:string, the IP address to get the hostname for\n        :return: string, the hostname associated with the IP address\n        >>> IpUtil.get_hostname('110.242.68.3')\n        'www.baidu.com'\n        >>> IpUtil.get_hostname('10.0.0.1')\n\n        \"\"\"",
                "test_class": "IpUtilTestGetHostname",
                "test_code": "class IpUtilTestGetHostname(unittest.TestCase):\n    def test_get_hostname_1(self):\n        result = IpUtil.get_hostname('110.242.68.3')\n        self.assertEqual(result, None)\n\n    def test_get_hostname_2(self):\n        result = IpUtil.get_hostname('10.0.0.1')\n        self.assertEqual(result, None)\n\n    def test_get_hostname_3(self):\n        result = IpUtil.get_hostname('0.0.0.0')\n        self.assertEqual(result, 'LAPTOP-2CS86KUM')\n\n    def test_get_hostname_4(self):\n        result = IpUtil.get_hostname('0.0.0.1')\n        self.assertEqual(result, None)\n\n    def test_get_hostname_5(self):\n        result = IpUtil.get_hostname('0.0.0.2')\n        self.assertEqual(result, None)",
                "solution_code": "@staticmethod\n    def get_hostname(ip_address):\n        try:\n            hostname = socket.gethostbyaddr(ip_address)[0]\n            return hostname\n        except socket.herror:\n            return None",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "socket"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_50",
        "skeleton": "import json\nimport os\n\nclass JSONProcessor:\n    \"\"\"\n    This is a class to process JSON file, including reading and writing JSON files, as well as processing JSON data by removing a specified key from the JSON object.\n    \"\"\"\n\n    def read_json(self, file_path):\n        \"\"\"\n        Read a JSON file and return the data.\n        :param file_path: str, the path of the JSON file.\n        :return: dict, the data from the JSON file if read successfully, or return -1 if an error occurs during the reading process.\n                    return 0 if the file does not exist.\n        >>> json.read_json('test.json')\n        {'name': 'test', 'age': 14}\n        \"\"\"\n\n    def write_json(self, data, file_path):\n        \"\"\"\n        Write data to a JSON file and save it to the given path.\n\n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: 1 if the writing process is successful, or -1, if an error occurs during the writing process.\n        >>> json.write_json({'key1': 'value1', 'key2': 'value2'}, 'test.json')\n        1\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        \"\"\"\n\n    def process_json(self, file_path, remove_key):\n        \"\"\"\n        read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.\n\n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: 1, if the specified key is successfully removed and the data is written back.\n                    0, if the file does not exist or the specified key does not exist in the data.\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        >>> json.process_json('test.json', 'key1')\n        1\n        >>> json.read_json('test.json')\n        {'key2': 'value2'}\n        \"\"\"",
        "test": "import os\nimport stat\nimport json\nimport unittest\n\n\nclass JSONProcessorTestReadJson(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    # file exists\n    def test_read_json_1(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, self.test_data)\n\n    # file not exists\n    def test_read_json_2(self):\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, 0)\n\n    # invalid json file\n    def test_read_json_3(self):\n        with open(self.file_path, 'w') as file:\n            file.write(\"Invalid JSON\")\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, -1)\n\n    def test_read_json_4(self):\n        result = self.processor.read_json('wrong')\n        self.assertEqual(result, 0)\n\n    def test_read_json_5(self):\n        result = self.processor.read_json('abcd')\n        self.assertEqual(result, 0)\n\n\nclass JSONProcessorTestWriteJson(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n        # create a read only file\n        self.file_path_only_read = 'test_only_read.json'\n        with open(self.file_path_only_read, 'w') as f:\n            f.write('{\"key1\": \"value1\"}')\n\n        # set file only read mode\n        os.chmod(self.file_path_only_read, stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH)\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n        if os.path.exists(self.file_path_only_read):\n            # unset file only read mode and remove the file\n            os.chmod(self.file_path_only_read,\n                     stat.S_IWUSR + stat.S_IRUSR + stat.S_IWGRP + stat.S_IRGRP + stat.S_IWOTH + stat.S_IROTH)\n            os.remove(self.file_path_only_read)\n\n    def test_write_json_1(self):\n        result = self.processor.write_json(self.test_data, self.file_path)\n        self.assertEqual(result, 1)\n        with open(self.file_path, 'r') as file:\n            written_data = json.load(file)\n        self.assertEqual(written_data, self.test_data)\n\n    def test_write_json_2(self):\n        # Provide a read-only file path to simulate an exception\n        result = self.processor.write_json(self.test_data, self.file_path_only_read)\n        self.assertEqual(result, -1)\n\n    def test_write_json_3(self):\n        result = self.processor.write_json([], self.file_path_only_read)\n        self.assertEqual(result, -1)\n\n    def test_write_json_4(self):\n        result = self.processor.write_json(self.test_data, '')\n        self.assertEqual(result, -1)\n\n    def test_write_json_5(self):\n        result = self.processor.write_json([], '')\n        self.assertEqual(result, -1)\n\n\nclass JSONProcessorTestProcessJsonExistingKey(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    # key exists\n    def test_process_json_1(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"key2\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        expected_data = {\n            \"key1\": \"value1\",\n            \"key3\": \"value3\"\n        }\n        self.assertEqual(processed_data, expected_data)\n\n    # key not exists\n    def test_process_json_2(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"nonexistent_key\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        self.assertEqual(processed_data, self.test_data)\n\n    # file is empty\n    def test_process_json_3(self):\n        # Create an empty JSON file\n        with open(self.file_path, 'w') as file:\n            pass\n        remove_key = \"key1\"\n        self.assertEqual(self.processor.process_json(self.file_path, remove_key), 0)\n\n    def test_process_json_4(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"aaa\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        self.assertEqual(processed_data, self.test_data)\n\n    def test_process_json_5(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"bbb\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        self.assertEqual(processed_data, self.test_data)\n\n\nclass JSONProcessorTestMain(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    def test_main(self):\n        # write first\n        result = self.processor.write_json(self.test_data, self.file_path)\n        self.assertEqual(result, 1)\n        with open(self.file_path, 'r') as file:\n            written_data = json.load(file)\n        self.assertEqual(written_data, self.test_data)\n\n        # read\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, self.test_data)\n\n        # process\n        remove_key = \"key2\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        expected_data = {\n            \"key1\": \"value1\",\n            \"key3\": \"value3\"\n        }\n        self.assertEqual(processed_data, expected_data)",
        "solution_code": "import json\nimport os\n\n\nclass JSONProcessor:\n    def read_json(self, file_path):\n        if not os.path.exists(file_path):\n            return 0\n        try:\n            with open(file_path, 'r') as file:\n                data = json.load(file)\n            return data\n        except:\n            return -1\n\n    def write_json(self, data, file_path):\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file)\n            return 1\n        except:\n            return -1\n\n    def process_json(self, file_path, remove_key):\n        data = self.read_json(file_path)\n        if data == 0 or data == -1:\n            return 0\n        if remove_key in data:\n            del data[remove_key]\n            self.write_json(data, file_path)\n            return 1\n        else:\n            return 0",
        "import_statement": [
            "import json",
            "import os"
        ],
        "class_description": "    \"\"\"\n    This is a class to process JSON file, including reading and writing JSON files, as well as processing JSON data by removing a specified key from the JSON object.\n    \"\"\"\n",
        "class_name": "JSONProcessor",
        "test_classes": [
            "JSONProcessorTestReadJson",
            "JSONProcessorTestWriteJson",
            "JSONProcessorTestProcessJsonExistingKey",
            "JSONProcessorTestMain"
        ],
        "class_constructor": "class JSONProcessor: \n",
        "fields": [],
        "methods_info": [
            {
                "method_name": "read_json",
                "method_description": "def read_json(self, file_path):\n        \"\"\"\n        Read a JSON file and return the data.\n        :param file_path: str, the path of the JSON file.\n        :return: dict, the data from the JSON file if read successfully, or return -1 if an error occurs during the reading process.\n                    return 0 if the file does not exist.\n        >>> json.read_json('test.json')\n        {'name': 'test', 'age': 14}\n        \"\"\"",
                "test_class": "JSONProcessorTestReadJson",
                "test_code": "class JSONProcessorTestReadJson(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    # file exists\n    def test_read_json_1(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, self.test_data)\n\n    # file not exists\n    def test_read_json_2(self):\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, 0)\n\n    # invalid json file\n    def test_read_json_3(self):\n        with open(self.file_path, 'w') as file:\n            file.write(\"Invalid JSON\")\n        result = self.processor.read_json(self.file_path)\n        self.assertEqual(result, -1)\n\n    def test_read_json_4(self):\n        result = self.processor.read_json('wrong')\n        self.assertEqual(result, 0)\n\n    def test_read_json_5(self):\n        result = self.processor.read_json('abcd')\n        self.assertEqual(result, 0)",
                "solution_code": "def read_json(self, file_path):\n        if not os.path.exists(file_path):\n            return 0\n        try:\n            with open(file_path, 'r') as file:\n                data = json.load(file)\n            return data\n        except:\n            return -1",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "json",
                        "os"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "write_json",
                "method_description": "def write_json(self, data, file_path):\n        \"\"\"\n        Write data to a JSON file and save it to the given path.\n\n        :param data: dict, the data to be written to the JSON file.\n        :param file_path: str, the path of the JSON file.\n        :return: 1 if the writing process is successful, or -1, if an error occurs during the writing process.\n        >>> json.write_json({'key1': 'value1', 'key2': 'value2'}, 'test.json')\n        1\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        \"\"\"",
                "test_class": "JSONProcessorTestWriteJson",
                "test_code": "class JSONProcessorTestWriteJson(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n        # create a read only file\n        self.file_path_only_read = 'test_only_read.json'\n        with open(self.file_path_only_read, 'w') as f:\n            f.write('{\"key1\": \"value1\"}')\n\n        # set file only read mode\n        os.chmod(self.file_path_only_read, stat.S_IRUSR + stat.S_IRGRP + stat.S_IROTH)\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n        if os.path.exists(self.file_path_only_read):\n            # unset file only read mode and remove the file\n            os.chmod(self.file_path_only_read,\n                     stat.S_IWUSR + stat.S_IRUSR + stat.S_IWGRP + stat.S_IRGRP + stat.S_IWOTH + stat.S_IROTH)\n            os.remove(self.file_path_only_read)\n\n    def test_write_json_1(self):\n        result = self.processor.write_json(self.test_data, self.file_path)\n        self.assertEqual(result, 1)\n        with open(self.file_path, 'r') as file:\n            written_data = json.load(file)\n        self.assertEqual(written_data, self.test_data)\n\n    def test_write_json_2(self):\n        # Provide a read-only file path to simulate an exception\n        result = self.processor.write_json(self.test_data, self.file_path_only_read)\n        self.assertEqual(result, -1)\n\n    def test_write_json_3(self):\n        result = self.processor.write_json([], self.file_path_only_read)\n        self.assertEqual(result, -1)\n\n    def test_write_json_4(self):\n        result = self.processor.write_json(self.test_data, '')\n        self.assertEqual(result, -1)\n\n    def test_write_json_5(self):\n        result = self.processor.write_json([], '')\n        self.assertEqual(result, -1)",
                "solution_code": "def write_json(self, data, file_path):\n        try:\n            with open(file_path, 'w') as file:\n                json.dump(data, file)\n            return 1\n        except:\n            return -1",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "json"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "process_json",
                "method_description": "def process_json(self, file_path, remove_key):\n        \"\"\"\n        read a JSON file and process the data by removing a specified key and rewrite the modified data back to the file.\n\n        :param file_path: str, the path of the JSON file.\n        :param remove_key: str, the key to be removed.\n        :return: 1, if the specified key is successfully removed and the data is written back.\n                    0, if the file does not exist or the specified key does not exist in the data.\n        >>> json.read_json('test.json')\n        {'key1': 'value1', 'key2': 'value2'}\n        >>> json.process_json('test.json', 'key1')\n        1\n        >>> json.read_json('test.json')\n        {'key2': 'value2'}\n        \"\"\"",
                "test_class": "JSONProcessorTestProcessJsonExistingKey",
                "test_code": "class JSONProcessorTestProcessJsonExistingKey(unittest.TestCase):\n    def setUp(self):\n        self.processor = JSONProcessor()\n        self.test_data = {\n            \"key1\": \"value1\",\n            \"key2\": \"value2\",\n            \"key3\": \"value3\"\n        }\n        self.file_path = \"test.json\"\n\n    def tearDown(self):\n        if os.path.exists(self.file_path):\n            os.remove(self.file_path)\n\n    # key exists\n    def test_process_json_1(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"key2\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        expected_data = {\n            \"key1\": \"value1\",\n            \"key3\": \"value3\"\n        }\n        self.assertEqual(processed_data, expected_data)\n\n    # key not exists\n    def test_process_json_2(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"nonexistent_key\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        self.assertEqual(processed_data, self.test_data)\n\n    # file is empty\n    def test_process_json_3(self):\n        # Create an empty JSON file\n        with open(self.file_path, 'w') as file:\n            pass\n        remove_key = \"key1\"\n        self.assertEqual(self.processor.process_json(self.file_path, remove_key), 0)\n\n    def test_process_json_4(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"aaa\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        self.assertEqual(processed_data, self.test_data)\n\n    def test_process_json_5(self):\n        with open(self.file_path, 'w') as file:\n            json.dump(self.test_data, file)\n        remove_key = \"bbb\"\n        self.processor.process_json(self.file_path, remove_key)\n        with open(self.file_path, 'r') as file:\n            processed_data = json.load(file)\n        self.assertEqual(processed_data, self.test_data)",
                "solution_code": "def process_json(self, file_path, remove_key):\n        data = self.read_json(file_path)\n        if data == 0 or data == -1:\n            return 0\n        if remove_key in data:\n            del data[remove_key]\n            self.write_json(data, file_path)\n            return 1\n        else:\n            return 0",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "json"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "read_json",
                        "write_json"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_52",
        "skeleton": "import nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\n\n\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\nclass Lemmatization:\n    \"\"\"\n    This is a class about Lemmatization, which utilizes the nltk library to perform lemmatization and part-of-speech tagging on sentences, as well as remove punctuation.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        creates a WordNetLemmatizer object and stores it in the self.lemmatizer member variable.\n        \"\"\"\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word,\n        lemmatizes the words with different parameters based on their parts of speech, and stores in a list.\n        :param sentence: a sentence str\n        :return: a list of words which have been lemmatized.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.lemmatize_sentence(\"I am running in a race.\")\n        ['I', 'be', 'run', 'in', 'a', 'race']\n\n        \"\"\"\n\n    def get_pos_tag(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word.\n        :param sentence: a sentence str\n        :return: list, part of speech tag of each word in the sentence.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.get_pos_tag(\"I am running in a race.\")\n        ['PRP', 'VBP', 'VBG', 'IN', 'DT', 'NN']\n\n        \"\"\"\n\n    def remove_punctuation(self, sentence):\n        \"\"\"\n        Removes punctuation from the input text.\n        :param sentence: a sentence str\n        :return: str, sentence without any punctuation\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.remove_punctuation(\"I am running in a race.\")\n        'I am running in a race'\n\n        \"\"\"",
        "test": "import unittest\n\nclass LemmatizationTestLemmatizeSentence(unittest.TestCase):\n    def test_lemmatize_sentence_1(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"I am running in a race.\")\n        expected = ['I', 'be', 'run', 'in', 'a', 'race']\n        self.assertEqual(result, expected)\n\n    def test_lemmatize_sentence_2(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"Until the beating, Cantanco's eyesight had been weak, but adequate.\")\n        expected = ['Until', 'the', 'beating', 'Cantancos', 'eyesight', 'have', 'be', 'weak', 'but', 'adequate']\n        self.assertEqual(result, expected)\n\n    def test_lammatize_sentence_3(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"The dog's barked at the mailman.\")\n        expected = ['The', 'dog', 'bark', 'at', 'the', 'mailman']\n        self.assertEqual(result, expected)\n\n    def test_lemmatize_sentence_4(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"He was running and eating at same time. \")\n        expected = ['He', 'be', 'run', 'and', 'eat', 'at', 'same', 'time']\n        self.assertEqual(result, expected)\n\n    def test_lemmatize_sentence_5(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"I was taking a ride in the car.\")\n        expected = ['I', 'be', 'take', 'a', 'ride', 'in', 'the', 'car']\n        self.assertEqual(result, expected)\n\nclass LemmatizationTestGetPosTag(unittest.TestCase):\n    def test_get_pos_tag_1(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"I am running in a race.\")\n        expected = ['PRP', 'VBP', 'VBG', 'IN', 'DT', 'NN']\n        self.assertEqual(result, expected)\n\n    def test_get_pos_tag_2(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"Cantanco's eyesight had been weak, but adequate.\")\n        expected = ['NNP', 'NN', 'VBD', 'VBN', 'JJ', 'CC', 'JJ']\n        self.assertEqual(result, expected)\n\n    def test_get_pos_tag_3(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"The dog's barked at the mailman.\")\n        expected = ['DT', 'NNS', 'VBD', 'IN', 'DT', 'NN']\n        self.assertEqual(result, expected)\n\n    def test_get_pos_tag_4(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"He was running and eating at same time. \")\n        expected = ['PRP', 'VBD', 'VBG', 'CC', 'VBG', 'IN', 'JJ', 'NN']\n        self.assertEqual(result, expected)\n\n    def test_get_pos_tag_5(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"I was taking a ride in the car.\")\n        expected = ['PRP', 'VBD', 'VBG', 'DT', 'NN', 'IN', 'DT', 'NN']\n        self.assertEqual(result, expected)\n\n\nclass LemmatizationTestRemovePunctuation(unittest.TestCase):\n    def test_remove_punctuation_1(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"I am running in a race.\")\n        expected = \"I am running in a race\"\n        self.assertEqual(result, expected)\n\n    def test_remove_punctuation_2(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"Until the beating, Cantanco's eyesight had been weak, but adequate.\")\n        expected = 'Until the beating Cantancos eyesight had been weak but adequate'\n        self.assertEqual(result, expected)\n\n    def test_remove_punctuation_3(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"The dog's barked at the mailman!!!\")\n        expected = 'The dogs barked at the mailman'\n        self.assertEqual(result, expected)\n\n    def test_remove_punctuation_4(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"He was running and eating at same time... \")\n        expected = 'He was running and eating at same time '\n        self.assertEqual(result, expected)\n\n    def test_remove_punctuation_5(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"Is this a test? I hope it is...\")\n        expected = 'Is this a test I hope it is'\n        self.assertEqual(result, expected)\n\nclass LemmatizationTestMain(unittest.TestCase):\n    def test_main(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"Until the beating, Cantanco's eyesight had been weak, but adequate.\")\n        expected = ['Until', 'the', 'beating', 'Cantancos', 'eyesight', 'have', 'be', 'weak', 'but', 'adequate']\n        self.assertEqual(result, expected)\n\n        result = lemmatization.get_pos_tag(\"Cantanco's eyesight had been weak, but adequate.\")\n        expected = ['NNP', 'NN', 'VBD', 'VBN', 'JJ', 'CC', 'JJ']\n        self.assertEqual(result, expected)",
        "solution_code": "import nltk\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk import pos_tag, word_tokenize\nimport string\n\nnltk.download('averaged_perceptron_tagger')\nnltk.download('punkt')\nnltk.download('wordnet')\n\n\nclass Lemmatization:\n    def __init__(self):\n        self.lemmatizer = WordNetLemmatizer()\n\n    def lemmatize_sentence(self, sentence):\n        lemmatized_words = []\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        for word, tag in tagged_words:\n            if tag.startswith('V'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')\n            elif tag.startswith('J'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')\n            elif tag.startswith('R'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')\n            else:\n                lemmatized_word = self.lemmatizer.lemmatize(word)\n            lemmatized_words.append(lemmatized_word)\n        return lemmatized_words\n\n    def get_pos_tag(self, sentence):\n        pos_tags = []\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        for tagged_word in tagged_words:\n            pos_tags.append(tagged_word[1])\n        return pos_tags\n\n    def remove_punctuation(self, sentence):\n        return sentence.translate(str.maketrans('', '', string.punctuation))",
        "import_statement": [
            "import nltk",
            "from nltk.stem import WordNetLemmatizer",
            "from nltk import pos_tag, word_tokenize",
            "import string"
        ],
        "class_description": "    \"\"\"\n    This is a class about Lemmatization, which utilizes the nltk library to perform lemmatization and part-of-speech tagging on sentences, as well as remove punctuation.\n    \"\"\"\n",
        "class_name": "Lemmatization",
        "test_classes": [
            "LemmatizationTestLemmatizeSentence",
            "LemmatizationTestGetPosTag",
            "LemmatizationTestRemovePunctuation",
            "LemmatizationTestMain"
        ],
        "class_constructor": "class Lemmatization: \n    def __init__(self):\n        \"\"\"\n        creates a WordNetLemmatizer object and stores it in the self.lemmatizer member variable.\n        \"\"\"\n        self.lemmatizer = WordNetLemmatizer()\n\n",
        "fields": [
            "self.lemmatizer"
        ],
        "methods_info": [
            {
                "method_name": "lemmatize_sentence",
                "method_description": "def lemmatize_sentence(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word,\n        lemmatizes the words with different parameters based on their parts of speech, and stores in a list.\n        :param sentence: a sentence str\n        :return: a list of words which have been lemmatized.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.lemmatize_sentence(\"I am running in a race.\")\n        ['I', 'be', 'run', 'in', 'a', 'race']\n\n        \"\"\"",
                "test_class": "LemmatizationTestLemmatizeSentence",
                "test_code": "class LemmatizationTestLemmatizeSentence(unittest.TestCase):\n    def test_lemmatize_sentence_1(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"I am running in a race.\")\n        expected = ['I', 'be', 'run', 'in', 'a', 'race']\n        self.assertEqual(result, expected)\n\n    def test_lemmatize_sentence_2(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"Until the beating, Cantanco's eyesight had been weak, but adequate.\")\n        expected = ['Until', 'the', 'beating', 'Cantancos', 'eyesight', 'have', 'be', 'weak', 'but', 'adequate']\n        self.assertEqual(result, expected)\n\n    def test_lammatize_sentence_3(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"The dog's barked at the mailman.\")\n        expected = ['The', 'dog', 'bark', 'at', 'the', 'mailman']\n        self.assertEqual(result, expected)\n\n    def test_lemmatize_sentence_4(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"He was running and eating at same time. \")\n        expected = ['He', 'be', 'run', 'and', 'eat', 'at', 'same', 'time']\n        self.assertEqual(result, expected)\n\n    def test_lemmatize_sentence_5(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.lemmatize_sentence(\"I was taking a ride in the car.\")\n        expected = ['I', 'be', 'take', 'a', 'ride', 'in', 'the', 'car']\n        self.assertEqual(result, expected)",
                "solution_code": "def lemmatize_sentence(self, sentence):\n        lemmatized_words = []\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        for word, tag in tagged_words:\n            if tag.startswith('V'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='v')\n            elif tag.startswith('J'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='a')\n            elif tag.startswith('R'):\n                lemmatized_word = self.lemmatizer.lemmatize(word, pos='r')\n            else:\n                lemmatized_word = self.lemmatizer.lemmatize(word)\n            lemmatized_words.append(lemmatized_word)\n        return lemmatized_words",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.lemmatizer"
                    ],
                    "method_dependencies": [
                        "remove_punctuation"
                    ]
                }
            },
            {
                "method_name": "get_pos_tag",
                "method_description": "def get_pos_tag(self, sentence):\n        \"\"\"\n        Remove punctuations of the sentence and tokenizes the input sentence, mark the part of speech tag of each word.\n        :param sentence: a sentence str\n        :return: list, part of speech tag of each word in the sentence.\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.get_pos_tag(\"I am running in a race.\")\n        ['PRP', 'VBP', 'VBG', 'IN', 'DT', 'NN']\n\n        \"\"\"",
                "test_class": "LemmatizationTestGetPosTag",
                "test_code": "class LemmatizationTestGetPosTag(unittest.TestCase):\n    def test_get_pos_tag_1(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"I am running in a race.\")\n        expected = ['PRP', 'VBP', 'VBG', 'IN', 'DT', 'NN']\n        self.assertEqual(result, expected)\n\n    def test_get_pos_tag_2(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"Cantanco's eyesight had been weak, but adequate.\")\n        expected = ['NNP', 'NN', 'VBD', 'VBN', 'JJ', 'CC', 'JJ']\n        self.assertEqual(result, expected)\n\n    def test_get_pos_tag_3(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"The dog's barked at the mailman.\")\n        expected = ['DT', 'NNS', 'VBD', 'IN', 'DT', 'NN']\n        self.assertEqual(result, expected)\n\n    def test_get_pos_tag_4(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"He was running and eating at same time. \")\n        expected = ['PRP', 'VBD', 'VBG', 'CC', 'VBG', 'IN', 'JJ', 'NN']\n        self.assertEqual(result, expected)\n\n    def test_get_pos_tag_5(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.get_pos_tag(\"I was taking a ride in the car.\")\n        expected = ['PRP', 'VBD', 'VBG', 'DT', 'NN', 'IN', 'DT', 'NN']\n        self.assertEqual(result, expected)",
                "solution_code": "def get_pos_tag(self, sentence):\n        pos_tags = []\n        sentence = self.remove_punctuation(sentence)\n        words = word_tokenize(sentence)\n        tagged_words = pos_tag(words)\n        for tagged_word in tagged_words:\n            pos_tags.append(tagged_word[1])\n        return pos_tags",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "remove_punctuation"
                    ]
                }
            },
            {
                "method_name": "remove_punctuation",
                "method_description": "def remove_punctuation(self, sentence):\n        \"\"\"\n        Removes punctuation from the input text.\n        :param sentence: a sentence str\n        :return: str, sentence without any punctuation\n        >>> lemmatization = Lemmatization()\n        >>> lemmatization.remove_punctuation(\"I am running in a race.\")\n        'I am running in a race'\n\n        \"\"\"",
                "test_class": "LemmatizationTestRemovePunctuation",
                "test_code": "class LemmatizationTestRemovePunctuation(unittest.TestCase):\n    def test_remove_punctuation_1(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"I am running in a race.\")\n        expected = \"I am running in a race\"\n        self.assertEqual(result, expected)\n\n    def test_remove_punctuation_2(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"Until the beating, Cantanco's eyesight had been weak, but adequate.\")\n        expected = 'Until the beating Cantancos eyesight had been weak but adequate'\n        self.assertEqual(result, expected)\n\n    def test_remove_punctuation_3(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"The dog's barked at the mailman!!!\")\n        expected = 'The dogs barked at the mailman'\n        self.assertEqual(result, expected)\n\n    def test_remove_punctuation_4(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"He was running and eating at same time... \")\n        expected = 'He was running and eating at same time '\n        self.assertEqual(result, expected)\n\n    def test_remove_punctuation_5(self):\n        lemmatization = Lemmatization()\n        result = lemmatization.remove_punctuation(\"Is this a test? I hope it is...\")\n        expected = 'Is this a test I hope it is'\n        self.assertEqual(result, expected)",
                "solution_code": "def remove_punctuation(self, sentence):\n        return sentence.translate(str.maketrans('', '', string.punctuation))",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "string"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_53",
        "skeleton": "import re\nimport string\n\nclass LongestWord:\n    \"\"\"\n    This is a class allows to add words to a list and find the longest word in a given sentence by comparing the words with the ones in the word list.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize a list of word.\n        \"\"\"\n        self.word_list = []\n\n    def add_word(self, word):\n        \"\"\"\n        append the input word into self.word_list\n        :param word: str, input word\n        \"\"\"\n\n    def find_longest_word(self, sentence):\n        \"\"\"\n        Remove punctuation marks and split a sentence into a list of word. Find the longest splited word that is in the self.word_list.\n        Words are strictly case sensitive.\n        :param sentence: a sentence str\n        :return str: longest splited word that is in the self.word_list. return '' if self.word_list is empty.\n        >>> longestWord = LongestWord()\n        >>> longestWord.add_word('A')\n        >>> longestWord.add_word('aM')\n        >>> longestWord.find_longest_word('I am a student.')\n        'a'\n        \"\"\"",
        "test": "import unittest\n\nclass LongestWordTestAddWord(unittest.TestCase):\n    def test_add_word_1(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        self.assertEqual(['hello'], longestWord.word_list)\n\n    def test_add_word_2(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        self.assertEqual(['hello', 'world'], longestWord.word_list)\n\n    def test_add_word_3(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        longestWord.add_word(\"!\")\n        self.assertEqual(['hello', 'world', '!'], longestWord.word_list)\n\n    def test_add_word_4(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        longestWord.add_word(\"!\")\n        longestWord.add_word(\"!\")\n        self.assertEqual(['hello', 'world', '!', '!'], longestWord.word_list)\n\n    def test_add_word_5(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        longestWord.add_word(\"!\")\n        longestWord.add_word(\"!\")\n        longestWord.add_word(\"!\")\n        self.assertEqual(['hello', 'world', '!', '!', '!'], longestWord.word_list)\n\n\nclass LongestWordTestFindLongestWord(unittest.TestCase):\n    def test_find_longest_word_1(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"a\")\n        sentence = 'I am a student.'\n        self.assertEqual('a', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_2(self):\n        longestWord = LongestWord()\n        sentence = 'I am a student.'\n        self.assertEqual('', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_3(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"student\")\n        sentence = 'I am a student.'\n        self.assertEqual('student', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_4(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"apple\")\n        sentence = 'Apple is red.'\n        self.assertEqual('apple', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_5(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"apple\")\n        longestWord.add_word(\"red\")\n        sentence = 'Apple is red.'\n        self.assertEqual('apple', longestWord.find_longest_word(sentence))",
        "solution_code": "import re\nimport string\n\n\nclass LongestWord:\n\n    def __init__(self):\n        self.word_list = []\n\n    def add_word(self, word):\n        self.word_list.append(word)\n\n    def find_longest_word(self, sentence):\n        longest_word = \"\"\n        sentence = sentence.lower()\n        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)\n        sentence = re.split(' ', sentence)\n        for word in sentence:\n            if word in self.word_list and len(word) > len(longest_word):\n                longest_word = word\n        return longest_word",
        "import_statement": [
            "import re",
            "import string"
        ],
        "class_description": "    \"\"\"\n    This is a class allows to add words to a list and find the longest word in a given sentence by comparing the words with the ones in the word list.\n    \"\"\"\n",
        "class_name": "LongestWord",
        "test_classes": [
            "LongestWordTestAddWord",
            "LongestWordTestFindLongestWord"
        ],
        "class_constructor": "class LongestWord: \n    def __init__(self):\n        \"\"\"\n        Initialize a list of word.\n        \"\"\"\n        self.word_list = []\n\n",
        "fields": [
            "self.word_list"
        ],
        "methods_info": [
            {
                "method_name": "add_word",
                "method_description": "def add_word(self, word):\n        \"\"\"\n        append the input word into self.word_list\n        :param word: str, input word\n        \"\"\"",
                "test_class": "LongestWordTestAddWord",
                "test_code": "class LongestWordTestAddWord(unittest.TestCase):\n    def test_add_word_1(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        self.assertEqual(['hello'], longestWord.word_list)\n\n    def test_add_word_2(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        self.assertEqual(['hello', 'world'], longestWord.word_list)\n\n    def test_add_word_3(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        longestWord.add_word(\"!\")\n        self.assertEqual(['hello', 'world', '!'], longestWord.word_list)\n\n    def test_add_word_4(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        longestWord.add_word(\"!\")\n        longestWord.add_word(\"!\")\n        self.assertEqual(['hello', 'world', '!', '!'], longestWord.word_list)\n\n    def test_add_word_5(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"hello\")\n        longestWord.add_word(\"world\")\n        longestWord.add_word(\"!\")\n        longestWord.add_word(\"!\")\n        longestWord.add_word(\"!\")\n        self.assertEqual(['hello', 'world', '!', '!', '!'], longestWord.word_list)",
                "solution_code": "def add_word(self, word):\n        self.word_list.append(word)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.word_list"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "find_longest_word",
                "method_description": "def find_longest_word(self, sentence):\n        \"\"\"\n        Remove punctuation marks and split a sentence into a list of word. Find the longest splited word that is in the self.word_list.\n        Words are strictly case sensitive.\n        :param sentence: a sentence str\n        :return str: longest splited word that is in the self.word_list. return '' if self.word_list is empty.\n        >>> longestWord = LongestWord()\n        >>> longestWord.add_word('A')\n        >>> longestWord.add_word('aM')\n        >>> longestWord.find_longest_word('I am a student.')\n        'a'\n        \"\"\"",
                "test_class": "LongestWordTestFindLongestWord",
                "test_code": "class LongestWordTestFindLongestWord(unittest.TestCase):\n    def test_find_longest_word_1(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"a\")\n        sentence = 'I am a student.'\n        self.assertEqual('a', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_2(self):\n        longestWord = LongestWord()\n        sentence = 'I am a student.'\n        self.assertEqual('', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_3(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"student\")\n        sentence = 'I am a student.'\n        self.assertEqual('student', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_4(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"apple\")\n        sentence = 'Apple is red.'\n        self.assertEqual('apple', longestWord.find_longest_word(sentence))\n\n    def test_find_longest_word_5(self):\n        longestWord = LongestWord()\n        longestWord.add_word(\"apple\")\n        longestWord.add_word(\"red\")\n        sentence = 'Apple is red.'\n        self.assertEqual('apple', longestWord.find_longest_word(sentence))",
                "solution_code": "def find_longest_word(self, sentence):\n        longest_word = \"\"\n        sentence = sentence.lower()\n        sentence = re.sub('[%s]' % re.escape(string.punctuation), '', sentence)\n        sentence = re.split(' ', sentence)\n        for word in sentence:\n            if word in self.word_list and len(word) > len(longest_word):\n                longest_word = word\n        return longest_word",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "re",
                        "string"
                    ],
                    "field_dependencies": [
                        "self.word_list"
                    ],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_54",
        "skeleton": "import random\n\nclass MahjongConnect:\n    \"\"\"\n    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game is over.\n    \"\"\"\n\n    def __init__(self, BOARD_SIZE, ICONS):\n        \"\"\"\n        initialize the board size and the icon list, create the game board\n        :param BOARD_SIZE: list of two integer numbers, representing the number of rows and columns of the game board\n        :param ICONS: list of string, representing the icons\n        >>>mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.BOARD_SIZE = [4, 4]\n        mc.ICONS = ['a', 'b', 'c']\n        mc.board = mc.create_board()\n        \"\"\"\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n        self.board = self.create_board()\n\n    def create_board(self):\n        \"\"\"\n        create the game board with the given board size and icons\n        :return: 2-dimensional list, the game board\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        >>> mc.create_board()\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        \"\"\"\n\n    def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        check if the move of two icons is valid (i.e. positions are within the game board range, the two positions are not the same, the two positions have the same icon, and there is a valid path between the two positions)\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return:True or False ,representing whether the move of two icons is valid\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.is_valid_move((0, 0), (1, 0))\n        True\n        \"\"\"\n\n\n    def has_path(self, pos1, pos2):\n        \"\"\"\n        check if there is a path between two icons\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return: True or False ,representing whether there is a path between two icons\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.is_valid_move((0, 0), (1, 0))\n        True\n        \"\"\"\n\n\n    def remove_icons(self, pos1, pos2):\n        \"\"\"\n        remove the connected icons on the game board\n        :param pos1: position tuple(x, y) of the first icon to be removed\n        :param pos2: position tuple(x, y) of the second icon to be removed\n        :return: None\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.remove_icons((0, 0), (1, 0))\n        mc.board = [[' ', 'b', 'c', 'a'],\n                    [' ', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        \"\"\"\n\n\n    def is_game_over(self):\n        \"\"\"\n        Check if the game is over (i.e., if there are no more icons on the game board)\n        :return: True or False ,representing whether the game is over\n        >>> mc = MahjongConnect([4, 4] ['a', 'b', 'c'])\n        >>> mc.board = [[' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' ']]\n        >>> mc.is_game_over()\n        True\n        \"\"\"",
        "test": "import unittest\n\n\nclass MahjongConnectTestCreateBoard(unittest.TestCase):\n    def test_create_board_1(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        self.assertEqual(mc.BOARD_SIZE, [4, 4])\n        self.assertEqual(mc.ICONS, ['a', 'b', 'c'])\n        for row in mc.board:\n            for icon in row:\n                self.assertIn(icon, mc.ICONS)\n\n    def test_create_board_2(self):\n        mc = MahjongConnect([2, 2], ['a', 'b', 'c'])\n        self.assertEqual(mc.BOARD_SIZE, [2, 2])\n        self.assertEqual(mc.ICONS, ['a', 'b', 'c'])\n        for row in mc.board:\n            for icon in row:\n                self.assertIn(icon, mc.ICONS)\n\n    def test_create_board_3(self):\n        mc = MahjongConnect([3, 3], ['a', 'b', 'c'])\n        self.assertEqual(mc.BOARD_SIZE, [3, 3])\n        self.assertEqual(mc.ICONS, ['a', 'b', 'c'])\n        for row in mc.board:\n            for icon in row:\n                self.assertIn(icon, mc.ICONS)\n\n    def test_create_board_4(self):\n        mc = MahjongConnect([1, 1], ['a', 'b', 'c'])\n        self.assertEqual(mc.BOARD_SIZE, [1, 1])\n        self.assertEqual(mc.ICONS, ['a', 'b', 'c'])\n        for row in mc.board:\n            for icon in row:\n                self.assertIn(icon, mc.ICONS)\n\n    def test_create_board_5(self):\n        mc = MahjongConnect([5, 5], ['a', 'b', 'c'])\n        self.assertEqual(mc.BOARD_SIZE, [5, 5])\n        self.assertEqual(mc.ICONS, ['a', 'b', 'c'])\n        for row in mc.board:\n            for icon in row:\n                self.assertIn(icon, mc.ICONS)\n\n\nclass MahjongConnectTestIsValidMove(unittest.TestCase):\n    def test_is_valid_move_1(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.is_valid_move((0, 0), (1, 0))\n        self.assertEqual(res, True)\n\n    def test_is_valid_move_2(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.is_valid_move((0, 0), (0, 1))\n        self.assertEqual(res, False)\n\n    def test_is_valid_move_3(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.is_valid_move((-1, 0), (0, 1))\n        self.assertEqual(res, False)\n\n    def test_is_valid_move_4(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.is_valid_move((0, 0), (0, 0))\n        self.assertEqual(res, False)\n\n    def test_is_valid_move_5(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.is_valid_move((300, 0), (0, 0))\n        self.assertEqual(res, False)\n\n    def test_is_valid_move_6(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'a', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.is_valid_move((0, 2), (0, 0))\n        self.assertEqual(res, False)\n\n\nclass MahjongConnectTestHasPath(unittest.TestCase):\n    def test_has_path_1(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.has_path((0, 0), (1, 0))\n        self.assertEqual(res, True)\n\n    def test_has_path_2(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.has_path((0, 0), (0, 0))\n        self.assertEqual(res, True)\n\n    def test_has_path_3(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.has_path((0, 0), (3, 0))\n        self.assertEqual(res, True)\n\n    def test_has_path_4(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.has_path((0, 0), (1, 1))\n        self.assertEqual(res, False)\n\n    def test_has_path_5(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.has_path((300, 0), (1, 1))\n        self.assertEqual(res, False)\n\n    def test_has_path_6(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'a', 'a', 'a'],\n                    ['a', 'a', 'a', 'a'],\n                    ['a', 'a', 'a', 'a'],\n                    ['a', 'a', 'a', 'a']]\n        res = mc.has_path((0, 0), (3, 3))\n        self.assertEqual(res, True)\n\n\nclass MahjongConnectTestRemoveIcons(unittest.TestCase):\n    def test_remove_icons_1(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        mc.remove_icons((0, 0), (1, 0))\n        self.assertEqual(mc.board, [[' ', 'b', 'c', 'a'],\n                                    [' ', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a']])\n\n    def test_remove_icons_2(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        mc.remove_icons((2, 0), (1, 0))\n        self.assertEqual(mc.board, [['a', 'b', 'c', 'a'],\n                                    [' ', 'b', 'c', 'a'],\n                                    [' ', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a']])\n\n    def test_remove_icons_3(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        mc.remove_icons((1, 1), (0, 1))\n        self.assertEqual(mc.board, [['a', ' ', 'c', 'a'],\n                                    ['a', ' ', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a']])\n\n    def test_remove_icons_4(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        mc.remove_icons((3, 0), (2, 0))\n        self.assertEqual(mc.board, [['a', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a'],\n                                    [' ', 'b', 'c', 'a'],\n                                    [' ', 'b', 'c', 'a']])\n\n    def test_remove_icons_5(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        mc.remove_icons((3, 3), (2, 3))\n        self.assertEqual(mc.board, [['a', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', ' '],\n                                    ['a', 'b', 'c', ' ']])\n\n\nclass MahjongConnectTestIsGameOver(unittest.TestCase):\n    def test_is_game_over_1(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [[' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' ']]\n        res = mc.is_game_over()\n        self.assertEqual(res, True)\n\n    def test_is_game_over_2(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', ' ', ' ', ' '],\n                    ['a', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' ']]\n        res = mc.is_game_over()\n        self.assertEqual(res, False)\n\n    def test_is_game_over_3(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [[' ', ' ', ' ', ' '],\n                    ['a', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' ']]\n        res = mc.is_game_over()\n        self.assertEqual(res, False)\n\n    def test_is_game_over_4(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['1', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' ']]\n        res = mc.is_game_over()\n        self.assertEqual(res, False)\n\n    def test_is_game_over_5(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' ']]\n        res = mc.is_game_over()\n        self.assertEqual(res, False)\n\n\nclass MahjongConnectTest(unittest.TestCase):\n    def test_mahjongconnect(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        self.assertEqual(mc.BOARD_SIZE, [4, 4])\n        self.assertEqual(mc.ICONS, ['a', 'b', 'c'])\n        for row in mc.board:\n            for icon in row:\n                self.assertIn(icon, mc.ICONS)\n\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.is_valid_move((0, 0), (1, 0))\n        self.assertEqual(res, True)\n\n        res = mc.has_path((0, 0), (1, 0))\n        self.assertEqual(res, True)\n\n        mc.remove_icons((0, 0), (1, 0))\n        self.assertEqual(mc.board, [[' ', 'b', 'c', 'a'],\n                                    [' ', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a']])\n\n        mc.board = [[' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' ']]\n        res = mc.is_game_over()\n        self.assertEqual(res, True)",
        "solution_code": "import random\n\n\nclass MahjongConnect:\n    def __init__(self, BOARD_SIZE, ICONS):\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n        self.board = self.create_board()\n\n    def create_board(self):\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        return board\n\n    def is_valid_move(self, pos1, pos2):\n        x1, y1 = pos1\n        x2, y2 = pos2\n\n        # Check if positions are within the game board range\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[\n            0] and 0 <= y2 <\n                self.BOARD_SIZE[1]):\n            return False\n\n        # Check if the two positions are the same\n        if pos1 == pos2:\n            return False\n\n        # Check if the two positions have the same icon\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n\n        # Check if there is a valid path between the two positions\n        if not self.has_path(pos1, pos2):\n            return False\n\n        return True\n\n    def has_path(self, pos1, pos2):\n        visited = set()\n        stack = [pos1]\n\n        while stack:\n            current_pos = stack.pop()\n            if current_pos == pos2:\n                return True\n\n            if current_pos in visited:\n                continue\n\n            visited.add(current_pos)\n            x, y = current_pos\n\n            # Check adjacent positions (up, down, left, right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\n                        stack.append((new_x, new_y))\n\n        return False\n\n    def remove_icons(self, pos1, pos2):\n        x1, y1 = pos1\n        x2, y2 = pos2\n        self.board[x1][y1] = ' '\n        self.board[x2][y2] = ' '\n\n    def is_game_over(self):\n        for row in self.board:\n            if any(icon != ' ' for icon in row):\n                return False\n        return True",
        "import_statement": [
            "import random"
        ],
        "class_description": "    \"\"\"\n    MahjongConnect is a class representing a game board for Mahjong Connect with features like creating the board, checking valid moves, finding paths, removing icons, and checking if the game is over.\n    \"\"\"\n",
        "class_name": "MahjongConnect",
        "test_classes": [
            "MahjongConnectTestCreateBoard",
            "MahjongConnectTestIsValidMove",
            "MahjongConnectTestHasPath",
            "MahjongConnectTestRemoveIcons",
            "MahjongConnectTestIsGameOver",
            "MahjongConnectTest"
        ],
        "class_constructor": "class MahjongConnect: \n    def __init__(self, BOARD_SIZE, ICONS):\n        \"\"\"\n        initialize the board size and the icon list, create the game board\n        :param BOARD_SIZE: list of two integer numbers, representing the number of rows and columns of the game board\n        :param ICONS: list of string, representing the icons\n        >>>mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.BOARD_SIZE = [4, 4]\n        mc.ICONS = ['a', 'b', 'c']\n        mc.board = mc.create_board()\n        \"\"\"\n        self.BOARD_SIZE = BOARD_SIZE\n        self.ICONS = ICONS\n        self.board = self.create_board()\n\n",
        "fields": [
            "self.BOARD_SIZE",
            "self.ICONS",
            "self.board"
        ],
        "methods_info": [
            {
                "method_name": "create_board",
                "method_description": "def create_board(self):\n        \"\"\"\n        create the game board with the given board size and icons\n        :return: 2-dimensional list, the game board\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        >>> mc.create_board()\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        \"\"\"",
                "test_class": "MahjongConnectTestCreateBoard",
                "test_code": "class MahjongConnectTestCreateBoard(unittest.TestCase):\n    def test_create_board_1(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        self.assertEqual(mc.BOARD_SIZE, [4, 4])\n        self.assertEqual(mc.ICONS, ['a', 'b', 'c'])\n        for row in mc.board:\n            for icon in row:\n                self.assertIn(icon, mc.ICONS)\n\n    def test_create_board_2(self):\n        mc = MahjongConnect([2, 2], ['a', 'b', 'c'])\n        self.assertEqual(mc.BOARD_SIZE, [2, 2])\n        self.assertEqual(mc.ICONS, ['a', 'b', 'c'])\n        for row in mc.board:\n            for icon in row:\n                self.assertIn(icon, mc.ICONS)\n\n    def test_create_board_3(self):\n        mc = MahjongConnect([3, 3], ['a', 'b', 'c'])\n        self.assertEqual(mc.BOARD_SIZE, [3, 3])\n        self.assertEqual(mc.ICONS, ['a', 'b', 'c'])\n        for row in mc.board:\n            for icon in row:\n                self.assertIn(icon, mc.ICONS)\n\n    def test_create_board_4(self):\n        mc = MahjongConnect([1, 1], ['a', 'b', 'c'])\n        self.assertEqual(mc.BOARD_SIZE, [1, 1])\n        self.assertEqual(mc.ICONS, ['a', 'b', 'c'])\n        for row in mc.board:\n            for icon in row:\n                self.assertIn(icon, mc.ICONS)\n\n    def test_create_board_5(self):\n        mc = MahjongConnect([5, 5], ['a', 'b', 'c'])\n        self.assertEqual(mc.BOARD_SIZE, [5, 5])\n        self.assertEqual(mc.ICONS, ['a', 'b', 'c'])\n        for row in mc.board:\n            for icon in row:\n                self.assertIn(icon, mc.ICONS)",
                "solution_code": "def create_board(self):\n        board = [[random.choice(self.ICONS) for _ in range(self.BOARD_SIZE[1])] for _ in range(self.BOARD_SIZE[0])]\n        return board",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "random"
                    ],
                    "field_dependencies": [
                        "self.BOARD_SIZE",
                        "self.ICONS"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "is_valid_move",
                "method_description": "def is_valid_move(self, pos1, pos2):\n        \"\"\"\n        check if the move of two icons is valid (i.e. positions are within the game board range, the two positions are not the same, the two positions have the same icon, and there is a valid path between the two positions)\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return:True or False ,representing whether the move of two icons is valid\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.is_valid_move((0, 0), (1, 0))\n        True\n        \"\"\"",
                "test_class": "MahjongConnectTestIsValidMove",
                "test_code": "class MahjongConnectTestIsValidMove(unittest.TestCase):\n    def test_is_valid_move_1(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.is_valid_move((0, 0), (1, 0))\n        self.assertEqual(res, True)\n\n    def test_is_valid_move_2(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.is_valid_move((0, 0), (0, 1))\n        self.assertEqual(res, False)\n\n    def test_is_valid_move_3(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.is_valid_move((-1, 0), (0, 1))\n        self.assertEqual(res, False)\n\n    def test_is_valid_move_4(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.is_valid_move((0, 0), (0, 0))\n        self.assertEqual(res, False)\n\n    def test_is_valid_move_5(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.is_valid_move((300, 0), (0, 0))\n        self.assertEqual(res, False)\n\n    def test_is_valid_move_6(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'a', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.is_valid_move((0, 2), (0, 0))\n        self.assertEqual(res, False)",
                "solution_code": "def is_valid_move(self, pos1, pos2):\n        x1, y1 = pos1\n        x2, y2 = pos2\n\n        # Check if positions are within the game board range\n        if not (0 <= x1 < self.BOARD_SIZE[0] and 0 <= y1 < self.BOARD_SIZE[1] and 0 <= x2 < self.BOARD_SIZE[\n            0] and 0 <= y2 <\n                self.BOARD_SIZE[1]):\n            return False\n\n        # Check if the two positions are the same\n        if pos1 == pos2:\n            return False\n\n        # Check if the two positions have the same icon\n        if self.board[x1][y1] != self.board[x2][y2]:\n            return False\n\n        # Check if there is a valid path between the two positions\n        if not self.has_path(pos1, pos2):\n            return False\n\n        return True",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.BOARD_SIZE",
                        "self.board"
                    ],
                    "method_dependencies": [
                        "has_path"
                    ]
                }
            },
            {
                "method_name": "has_path",
                "method_description": "def has_path(self, pos1, pos2):\n        \"\"\"\n        check if there is a path between two icons\n        :param pos1: position tuple(x, y) of the first icon\n        :param pos2: position tuple(x, y) of the second icon\n        :return: True or False ,representing whether there is a path between two icons\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.is_valid_move((0, 0), (1, 0))\n        True\n        \"\"\"",
                "test_class": "MahjongConnectTestHasPath",
                "test_code": "class MahjongConnectTestHasPath(unittest.TestCase):\n    def test_has_path_1(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.has_path((0, 0), (1, 0))\n        self.assertEqual(res, True)\n\n    def test_has_path_2(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.has_path((0, 0), (0, 0))\n        self.assertEqual(res, True)\n\n    def test_has_path_3(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.has_path((0, 0), (3, 0))\n        self.assertEqual(res, True)\n\n    def test_has_path_4(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.has_path((0, 0), (1, 1))\n        self.assertEqual(res, False)\n\n    def test_has_path_5(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        res = mc.has_path((300, 0), (1, 1))\n        self.assertEqual(res, False)\n\n    def test_has_path_6(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'a', 'a', 'a'],\n                    ['a', 'a', 'a', 'a'],\n                    ['a', 'a', 'a', 'a'],\n                    ['a', 'a', 'a', 'a']]\n        res = mc.has_path((0, 0), (3, 3))\n        self.assertEqual(res, True)",
                "solution_code": "def has_path(self, pos1, pos2):\n        visited = set()\n        stack = [pos1]\n\n        while stack:\n            current_pos = stack.pop()\n            if current_pos == pos2:\n                return True\n\n            if current_pos in visited:\n                continue\n\n            visited.add(current_pos)\n            x, y = current_pos\n\n            # Check adjacent positions (up, down, left, right)\n            for dx, dy in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_x, new_y = x + dx, y + dy\n                if 0 <= new_x < self.BOARD_SIZE[0] and 0 <= new_y < self.BOARD_SIZE[1]:\n                    if (new_x, new_y) not in visited and self.board[new_x][new_y] == self.board[x][y]:\n                        stack.append((new_x, new_y))\n\n        return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.BOARD_SIZE",
                        "self.board"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "remove_icons",
                "method_description": "def remove_icons(self, pos1, pos2):\n        \"\"\"\n        remove the connected icons on the game board\n        :param pos1: position tuple(x, y) of the first icon to be removed\n        :param pos2: position tuple(x, y) of the second icon to be removed\n        :return: None\n        >>> mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        >>> mc.remove_icons((0, 0), (1, 0))\n        mc.board = [[' ', 'b', 'c', 'a'],\n                    [' ', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        \"\"\"",
                "test_class": "MahjongConnectTestRemoveIcons",
                "test_code": "class MahjongConnectTestRemoveIcons(unittest.TestCase):\n    def test_remove_icons_1(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        mc.remove_icons((0, 0), (1, 0))\n        self.assertEqual(mc.board, [[' ', 'b', 'c', 'a'],\n                                    [' ', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a']])\n\n    def test_remove_icons_2(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        mc.remove_icons((2, 0), (1, 0))\n        self.assertEqual(mc.board, [['a', 'b', 'c', 'a'],\n                                    [' ', 'b', 'c', 'a'],\n                                    [' ', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a']])\n\n    def test_remove_icons_3(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        mc.remove_icons((1, 1), (0, 1))\n        self.assertEqual(mc.board, [['a', ' ', 'c', 'a'],\n                                    ['a', ' ', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a']])\n\n    def test_remove_icons_4(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        mc.remove_icons((3, 0), (2, 0))\n        self.assertEqual(mc.board, [['a', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a'],\n                                    [' ', 'b', 'c', 'a'],\n                                    [' ', 'b', 'c', 'a']])\n\n    def test_remove_icons_5(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a'],\n                    ['a', 'b', 'c', 'a']]\n        mc.remove_icons((3, 3), (2, 3))\n        self.assertEqual(mc.board, [['a', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', 'a'],\n                                    ['a', 'b', 'c', ' '],\n                                    ['a', 'b', 'c', ' ']])",
                "solution_code": "def remove_icons(self, pos1, pos2):\n        x1, y1 = pos1\n        x2, y2 = pos2\n        self.board[x1][y1] = ' '\n        self.board[x2][y2] = ' '",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.board"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "is_game_over",
                "method_description": "def is_game_over(self):\n        \"\"\"\n        Check if the game is over (i.e., if there are no more icons on the game board)\n        :return: True or False ,representing whether the game is over\n        >>> mc = MahjongConnect([4, 4] ['a', 'b', 'c'])\n        >>> mc.board = [[' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' '],\n        >>>         [' ', ' ', ' ', ' ']]\n        >>> mc.is_game_over()\n        True\n        \"\"\"",
                "test_class": "MahjongConnectTestIsGameOver",
                "test_code": "class MahjongConnectTestIsGameOver(unittest.TestCase):\n    def test_is_game_over_1(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [[' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' ']]\n        res = mc.is_game_over()\n        self.assertEqual(res, True)\n\n    def test_is_game_over_2(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', ' ', ' ', ' '],\n                    ['a', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' ']]\n        res = mc.is_game_over()\n        self.assertEqual(res, False)\n\n    def test_is_game_over_3(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [[' ', ' ', ' ', ' '],\n                    ['a', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' ']]\n        res = mc.is_game_over()\n        self.assertEqual(res, False)\n\n    def test_is_game_over_4(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['1', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' ']]\n        res = mc.is_game_over()\n        self.assertEqual(res, False)\n\n    def test_is_game_over_5(self):\n        mc = MahjongConnect([4, 4], ['a', 'b', 'c'])\n        mc.board = [['a', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' '],\n                    [' ', ' ', ' ', ' ']]\n        res = mc.is_game_over()\n        self.assertEqual(res, False)",
                "solution_code": "def is_game_over(self):\n        for row in self.board:\n            if any(icon != ' ' for icon in row):\n                return False\n        return True",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.board"
                    ],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_58",
        "skeleton": "import random\n\nclass MinesweeperGame:\n    \"\"\"\n    This is a class that implements mine sweeping games including minesweeping and winning judgment.\n    \"\"\"\n\n    def __init__(self, n, k) -> None:\n        \"\"\"\n        Initializes the MinesweeperGame class with the size of the board and the number of mines.\n        :param n: The size of the board, int.\n        :param k: The number of mines, int.\n        \"\"\"\n        self.n = n\n        self.k = k\n        self.minesweeper_map = self.generate_mine_sweeper_map()\n        self.player_map = self.generate_playerMap()\n        self.score = 0\n\n    def generate_mine_sweeper_map(self):\n        \"\"\"\n        Generates a minesweeper map with the given size of the board and the number of mines,the given parameter n is the size of the board,the size of the board is n*n,the parameter k is the number of mines,'X' represents the mine,other numbers represent the number of mines around the position.\n        :return: The minesweeper map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.generate_mine_sweeper_map()\n        [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n\n        \"\"\"\n\n    def generate_playerMap(self):\n        \"\"\"\n        Generates a player map with the given size of the board, the given parameter n is the size of the board,the size of the board is n*n,the parameter k is the number of mines,'-' represents the unknown position.\n        :return: The player map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.generate_playerMap()\n        [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n\n        \"\"\"\n\n    def check_won(self,map):\n        \"\"\"\n        Checks whether the player has won the game,if there are just mines in the player map,return True,otherwise return False.\n        :return: True if the player has won the game, False otherwise.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        >>> minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        >>> minesweeper_game.check_won(minesweeper_game.player_map)\n        False\n\n        \"\"\"\n\n    def sweep(self, x, y):\n        \"\"\"\n        Sweeps the given position.\n        :param x: The x coordinate of the position, int.\n        :param y: The y coordinate of the position, int.\n        :return: True if the player has won the game, False otherwise,if the game still continues, return the player map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        >>> minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        >>> minesweeper_game.sweep(1, 1)\n        [['-', '-', '-'], ['-', 1, '-'], ['-', '-', '-']]\n\n        \"\"\"",
        "test": "import unittest\n\nclass MinesweeperGameTestGenerateMineSweeperMap(unittest.TestCase):\n    def test_generate_mine_sweeper_map(self):\n        minesweeper_game = MinesweeperGame(3, 2)\n        length = len(minesweeper_game.minesweeper_map)\n        mine_num = 0\n        for row in minesweeper_game.minesweeper_map:\n            for cell in row:\n                if cell == 'X':\n                    mine_num += 1\n        self.assertEqual(3, length)\n        self.assertEqual(2, mine_num)\n\n    def test_generate_mine_sweeper_map_2(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        length = len(minesweeper_game.minesweeper_map)\n        mine_num = 0\n        for row in minesweeper_game.minesweeper_map:\n            for cell in row:\n                if cell == 'X':\n                    mine_num += 1\n        self.assertEqual(3, length)\n        self.assertEqual(1, mine_num)\n\n    def test_generate_mine_sweeper_map_3(self):\n        minesweeper_game = MinesweeperGame(3, 0)\n        length = len(minesweeper_game.minesweeper_map)\n        mine_num = 0\n        for row in minesweeper_game.minesweeper_map:\n            for cell in row:\n                if cell == 'X':\n                    mine_num += 1\n        self.assertEqual(3, length)\n        self.assertEqual(0, mine_num)\n\n    def test_generate_mine_sweeper_map_4(self):\n        minesweeper_game = MinesweeperGame(5, 1)\n        length = len(minesweeper_game.minesweeper_map)\n        mine_num = 0\n        for row in minesweeper_game.minesweeper_map:\n            for cell in row:\n                if cell == 'X':\n                    mine_num += 1\n        self.assertEqual(length,5)\n        self.assertEqual(mine_num, 1)\n\n    def test_generate_mine_sweeper_map_5(self):\n        minesweeper_game = MinesweeperGame(4, 1)\n        length = len(minesweeper_game.minesweeper_map)\n        mine_num = 0\n        for row in minesweeper_game.minesweeper_map:\n            for cell in row:\n                if cell == 'X':\n                    mine_num += 1\n        self.assertEqual(length, 4)\n        self.assertEqual(mine_num, 1)\n\nclass MinesweeperGameTestGeneratePlayerMap(unittest.TestCase):\n    def test_generate_playerMap(self):\n        minesweeper_game = MinesweeperGame(3, 2)\n        self.assertEqual(minesweeper_game.generate_playerMap(), [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']])\n\n    def test_generate_playerMap_2(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        self.assertEqual(minesweeper_game.generate_playerMap(), [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']])\n\n    def test_generate_playerMap_3(self):\n        minesweeper_game = MinesweeperGame(4, 2)\n        self.assertEqual(minesweeper_game.generate_playerMap(),[['-', '-', '-', '-'],['-', '-', '-', '-'],['-', '-', '-', '-'],['-', '-', '-', '-']])\n\n    def test_generate_playerMap_4(self):\n        minesweeper_game = MinesweeperGame(1, 4)\n        self.assertEqual(minesweeper_game.generate_playerMap(), [['-']])\n\n    def test_generate_playerMap_5(self):\n        minesweeper_game = MinesweeperGame(2, 5)\n        self.assertEqual(minesweeper_game.generate_playerMap(), [['-', '-'], ['-', '-']])\n\nclass MinesweeperGameTestCheckWon(unittest.TestCase):\n    def test_check_won(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        self.assertEqual(minesweeper_game.check_won(minesweeper_game.player_map), False)\n\n    def test_check_won_2(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '-'], ['-', 1, '-'], ['-', '-', '-']]\n        self.assertEqual(minesweeper_game.check_won(minesweeper_game.player_map), False)\n\n    def test_check_won_3(self):\n        minesweeper_game = MinesweeperGame(3, 0)\n        minesweeper_game.minesweeper_map = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '-'], ['-', 1, '-'], ['-', '-', '-']]\n        self.assertEqual(minesweeper_game.check_won(minesweeper_game.player_map), False)\n\n    def test_check_won_4(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '1', '0'], ['1', 1, '0'], ['0', '0', '0']]\n        self.assertEqual(minesweeper_game.check_won(minesweeper_game.player_map), True)\n\n    def test_check_won_5(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['X', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        self.assertEqual(minesweeper_game.check_won(minesweeper_game.player_map), False)\n\nclass MinesweeperGameTestSweep(unittest.TestCase):\n    def test_sweep(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        self.assertEqual(minesweeper_game.sweep(1,1), [['-', '-', '-'], ['-', 1, '-'], ['-', '-', '-']])\n        self.assertEqual(minesweeper_game.score, 1)\n\n    def test_sweep_2(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        self.assertEqual(minesweeper_game.sweep(0,0), False)\n        self.assertEqual(minesweeper_game.score, 0)\n\n    def test_sweep_3(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '0'], ['1', '1', '0'], ['0', '0', '0']]\n        self.assertEqual(minesweeper_game.sweep(0,1), True)\n        self.assertEqual(minesweeper_game.score, 1)\n\n    def test_sweep_4(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '0'], ['0', '0', '0']]\n        self.assertEqual(minesweeper_game.sweep(0,2), [['-', '-', 0], ['-', '-', '0'], ['0', '0', '0']])\n        self.assertEqual(minesweeper_game.score, 1)\n\n    def test_sweep_5(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '0'], ['-', '1', '0'], ['0', '0', '0']]\n        self.assertEqual(minesweeper_game.sweep(1,0), [['-', '-', '0'], [1, '1', '0'], ['0', '0', '0']])\n        self.assertEqual(minesweeper_game.score, 1)\n\nclass MinesweeperGameTestMain(unittest.TestCase):\n    def test_minesweeper_main(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        length = len(minesweeper_game.minesweeper_map)\n        mine_num = 0\n        for row in minesweeper_game.minesweeper_map:\n            for cell in row:\n                if cell == 'X':\n                    mine_num += 1\n        self.assertEqual(3, length)\n        self.assertEqual(1, mine_num)\n        self.assertEqual(minesweeper_game.generate_playerMap(), [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']])\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        self.assertEqual(minesweeper_game.check_won(minesweeper_game.player_map), False)\n        self.assertEqual(minesweeper_game.sweep(1,1), [['-', '-', '-'], ['-', 1, '-'], ['-', '-', '-']])\n        self.assertEqual(minesweeper_game.score, 1)\n\n    def test_minesweeper_main_2(self):\n        minesweeper_game = MinesweeperGame(3, 2)\n        length = len(minesweeper_game.minesweeper_map)\n        mine_num = 0\n        for row in minesweeper_game.minesweeper_map:\n            for cell in row:\n                if cell == 'X':\n                    mine_num += 1\n        self.assertEqual(3, length)\n        self.assertEqual(2, mine_num)\n        self.assertEqual(minesweeper_game.generate_playerMap(), [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']])\n        minesweeper_game.minesweeper_map = [['X', 1, 1], [1, 'X', 1], [1, 1, 1]]\n        self.assertEqual(minesweeper_game.check_won(minesweeper_game.player_map), False)\n        self.assertEqual(minesweeper_game.sweep(0, 1), [['-', 1, '-'], ['-','-', '-'], ['-', '-', '-']])\n        self.assertEqual(minesweeper_game.score, 1)\n        self.assertEqual(minesweeper_game.sweep(0, 2), [['-', 1, 1], ['-', '-', '-'], ['-', '-', '-']])\n        self.assertEqual(minesweeper_game.score, 2)",
        "solution_code": "import random\n\nclass MinesweeperGame:\n    def __init__(self, n, k) -> None:\n        self.n = n\n        self.k = k\n        self.minesweeper_map = self.generate_mine_sweeper_map()\n        self.player_map = self.generate_playerMap()\n        self.score = 0\n\n    def generate_mine_sweeper_map(self):\n        arr = [[0 for row in range(self.n)] for column in range(self.n)]\n        for num in range(self.k):\n            x = random.randint(0, self.n-1)\n            y = random.randint(0, self.n-1)\n            arr[y][x] = 'X'\n            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):\n                if arr[y][x+1] != 'X':\n                    arr[y][x+1] += 1\n            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):\n                if arr[y][x-1] != 'X':\n                    arr[y][x-1] += 1\n            if (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x-1] != 'X':\n                    arr[y-1][x-1] += 1\n    \n            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x+1] != 'X':\n                    arr[y-1][x+1] += 1 \n            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x] != 'X':\n                    arr[y-1][x] += 1\n    \n            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x+1] != 'X':\n                    arr[y+1][x+1] += 1\n            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x-1] != 'X':\n                    arr[y+1][x-1] += 1\n            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x] != 'X':\n                    arr[y+1][x] += 1\n        return arr\n    \n    def generate_playerMap(self):\n        arr = [['-' for row in range(self.n)] for column in range(self.n)]\n        return arr\n\n    def check_won(self, map):\n        for i in range(self.n):\n            for j in range(self.n):\n                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n        return True\n    \n    def sweep(self, x, y):\n\n        if (self.minesweeper_map[x][y] == 'X'):\n            return False\n        else:\n            self.player_map[x][y] = self.minesweeper_map[x][y]\n            self.score += 1\n            if self.check_won(self.player_map) == True:\n                return True\n            return self.player_map",
        "import_statement": [
            "import random"
        ],
        "class_description": "    \"\"\"\n    This is a class that implements mine sweeping games including minesweeping and winning judgment.\n    \"\"\"\n",
        "class_name": "MinesweeperGame",
        "test_classes": [
            "MinesweeperGameTestGenerateMineSweeperMap",
            "MinesweeperGameTestGeneratePlayerMap",
            "MinesweeperGameTestCheckWon",
            "MinesweeperGameTestSweep",
            "MinesweeperGameTestMain"
        ],
        "class_constructor": "class MinesweeperGame: \n    def __init__(self, n, k) -> None:\n        \"\"\"\n        Initializes the MinesweeperGame class with the size of the board and the number of mines.\n        :param n: The size of the board, int.\n        :param k: The number of mines, int.\n        \"\"\"\n        self.n = n\n        self.k = k\n        self.minesweeper_map = self.generate_mine_sweeper_map()\n        self.player_map = self.generate_playerMap()\n        self.score = 0\n\n",
        "fields": [
            "self.k",
            "self.minesweeper_map",
            "self.n",
            "self.player_map",
            "self.score"
        ],
        "methods_info": [
            {
                "method_name": "generate_mine_sweeper_map",
                "method_description": "def generate_mine_sweeper_map(self):\n        \"\"\"\n        Generates a minesweeper map with the given size of the board and the number of mines,the given parameter n is the size of the board,the size of the board is n*n,the parameter k is the number of mines,'X' represents the mine,other numbers represent the number of mines around the position.\n        :return: The minesweeper map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.generate_mine_sweeper_map()\n        [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n\n        \"\"\"",
                "test_class": "MinesweeperGameTestGenerateMineSweeperMap",
                "test_code": "class MinesweeperGameTestGenerateMineSweeperMap(unittest.TestCase):\n    def test_generate_mine_sweeper_map(self):\n        minesweeper_game = MinesweeperGame(3, 2)\n        length = len(minesweeper_game.minesweeper_map)\n        mine_num = 0\n        for row in minesweeper_game.minesweeper_map:\n            for cell in row:\n                if cell == 'X':\n                    mine_num += 1\n        self.assertEqual(3, length)\n        self.assertEqual(2, mine_num)\n\n    def test_generate_mine_sweeper_map_2(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        length = len(minesweeper_game.minesweeper_map)\n        mine_num = 0\n        for row in minesweeper_game.minesweeper_map:\n            for cell in row:\n                if cell == 'X':\n                    mine_num += 1\n        self.assertEqual(3, length)\n        self.assertEqual(1, mine_num)\n\n    def test_generate_mine_sweeper_map_3(self):\n        minesweeper_game = MinesweeperGame(3, 0)\n        length = len(minesweeper_game.minesweeper_map)\n        mine_num = 0\n        for row in minesweeper_game.minesweeper_map:\n            for cell in row:\n                if cell == 'X':\n                    mine_num += 1\n        self.assertEqual(3, length)\n        self.assertEqual(0, mine_num)\n\n    def test_generate_mine_sweeper_map_4(self):\n        minesweeper_game = MinesweeperGame(5, 1)\n        length = len(minesweeper_game.minesweeper_map)\n        mine_num = 0\n        for row in minesweeper_game.minesweeper_map:\n            for cell in row:\n                if cell == 'X':\n                    mine_num += 1\n        self.assertEqual(length,5)\n        self.assertEqual(mine_num, 1)\n\n    def test_generate_mine_sweeper_map_5(self):\n        minesweeper_game = MinesweeperGame(4, 1)\n        length = len(minesweeper_game.minesweeper_map)\n        mine_num = 0\n        for row in minesweeper_game.minesweeper_map:\n            for cell in row:\n                if cell == 'X':\n                    mine_num += 1\n        self.assertEqual(length, 4)\n        self.assertEqual(mine_num, 1)",
                "solution_code": "def generate_mine_sweeper_map(self):\n        arr = [[0 for row in range(self.n)] for column in range(self.n)]\n        for num in range(self.k):\n            x = random.randint(0, self.n-1)\n            y = random.randint(0, self.n-1)\n            arr[y][x] = 'X'\n            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-1):\n                if arr[y][x+1] != 'X':\n                    arr[y][x+1] += 1\n            if (x >=1 and x <= self.n-1) and (y >= 0 and y <= self.n-1):\n                if arr[y][x-1] != 'X':\n                    arr[y][x-1] += 1\n            if (x >= 1 and x <= self.n-1) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x-1] != 'X':\n                    arr[y-1][x-1] += 1\n    \n            if (x >= 0 and x <= self.n-2) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x+1] != 'X':\n                    arr[y-1][x+1] += 1 \n            if (x >= 0 and x <= self.n-1) and (y >= 1 and y <= self.n-1):\n                if arr[y-1][x] != 'X':\n                    arr[y-1][x] += 1\n    \n            if (x >=0 and x <= self.n-2) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x+1] != 'X':\n                    arr[y+1][x+1] += 1\n            if (x >= 1 and x <= self.n-1) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x-1] != 'X':\n                    arr[y+1][x-1] += 1\n            if (x >= 0 and x <= self.n-1) and (y >= 0 and y <= self.n-2):\n                if arr[y+1][x] != 'X':\n                    arr[y+1][x] += 1\n        return arr",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "random"
                    ],
                    "field_dependencies": [
                        "self.k",
                        "self.n"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "generate_playerMap",
                "method_description": "def generate_playerMap(self):\n        \"\"\"\n        Generates a player map with the given size of the board, the given parameter n is the size of the board,the size of the board is n*n,the parameter k is the number of mines,'-' represents the unknown position.\n        :return: The player map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.generate_playerMap()\n        [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n\n        \"\"\"",
                "test_class": "MinesweeperGameTestGeneratePlayerMap",
                "test_code": "class MinesweeperGameTestGeneratePlayerMap(unittest.TestCase):\n    def test_generate_playerMap(self):\n        minesweeper_game = MinesweeperGame(3, 2)\n        self.assertEqual(minesweeper_game.generate_playerMap(), [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']])\n\n    def test_generate_playerMap_2(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        self.assertEqual(minesweeper_game.generate_playerMap(), [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']])\n\n    def test_generate_playerMap_3(self):\n        minesweeper_game = MinesweeperGame(4, 2)\n        self.assertEqual(minesweeper_game.generate_playerMap(),[['-', '-', '-', '-'],['-', '-', '-', '-'],['-', '-', '-', '-'],['-', '-', '-', '-']])\n\n    def test_generate_playerMap_4(self):\n        minesweeper_game = MinesweeperGame(1, 4)\n        self.assertEqual(minesweeper_game.generate_playerMap(), [['-']])\n\n    def test_generate_playerMap_5(self):\n        minesweeper_game = MinesweeperGame(2, 5)\n        self.assertEqual(minesweeper_game.generate_playerMap(), [['-', '-'], ['-', '-']])",
                "solution_code": "def generate_playerMap(self):\n        arr = [['-' for row in range(self.n)] for column in range(self.n)]\n        return arr",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.n"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "check_won",
                "method_description": "def check_won(self,map):\n        \"\"\"\n        Checks whether the player has won the game,if there are just mines in the player map,return True,otherwise return False.\n        :return: True if the player has won the game, False otherwise.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        >>> minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        >>> minesweeper_game.check_won(minesweeper_game.player_map)\n        False\n\n        \"\"\"",
                "test_class": "MinesweeperGameTestCheckWon",
                "test_code": "class MinesweeperGameTestCheckWon(unittest.TestCase):\n    def test_check_won(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        self.assertEqual(minesweeper_game.check_won(minesweeper_game.player_map), False)\n\n    def test_check_won_2(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '-'], ['-', 1, '-'], ['-', '-', '-']]\n        self.assertEqual(minesweeper_game.check_won(minesweeper_game.player_map), False)\n\n    def test_check_won_3(self):\n        minesweeper_game = MinesweeperGame(3, 0)\n        minesweeper_game.minesweeper_map = [[0, 0, 0], [0, 0, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '-'], ['-', 1, '-'], ['-', '-', '-']]\n        self.assertEqual(minesweeper_game.check_won(minesweeper_game.player_map), False)\n\n    def test_check_won_4(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '1', '0'], ['1', 1, '0'], ['0', '0', '0']]\n        self.assertEqual(minesweeper_game.check_won(minesweeper_game.player_map), True)\n\n    def test_check_won_5(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['X', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        self.assertEqual(minesweeper_game.check_won(minesweeper_game.player_map), False)",
                "solution_code": "def check_won(self, map):\n        for i in range(self.n):\n            for j in range(self.n):\n                if map[i][j] == '-' and self.minesweeper_map[i][j] != 'X':\n                    return False\n        return True",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.minesweeper_map",
                        "self.n"
                    ],
                    "method_dependencies": [
                        "sweep"
                    ]
                }
            },
            {
                "method_name": "sweep",
                "method_description": "def sweep(self, x, y):\n        \"\"\"\n        Sweeps the given position.\n        :param x: The x coordinate of the position, int.\n        :param y: The y coordinate of the position, int.\n        :return: True if the player has won the game, False otherwise,if the game still continues, return the player map, list.\n        >>> minesweeper_game = MinesweeperGame(3, 1)\n        >>> minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        >>> minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        >>> minesweeper_game.sweep(1, 1)\n        [['-', '-', '-'], ['-', 1, '-'], ['-', '-', '-']]\n\n        \"\"\"",
                "test_class": "MinesweeperGameTestSweep",
                "test_code": "class MinesweeperGameTestSweep(unittest.TestCase):\n    def test_sweep(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        self.assertEqual(minesweeper_game.sweep(1,1), [['-', '-', '-'], ['-', 1, '-'], ['-', '-', '-']])\n        self.assertEqual(minesweeper_game.score, 1)\n\n    def test_sweep_2(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '-'], ['-', '-', '-']]\n        self.assertEqual(minesweeper_game.sweep(0,0), False)\n        self.assertEqual(minesweeper_game.score, 0)\n\n    def test_sweep_3(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '0'], ['1', '1', '0'], ['0', '0', '0']]\n        self.assertEqual(minesweeper_game.sweep(0,1), True)\n        self.assertEqual(minesweeper_game.score, 1)\n\n    def test_sweep_4(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '-'], ['-', '-', '0'], ['0', '0', '0']]\n        self.assertEqual(minesweeper_game.sweep(0,2), [['-', '-', 0], ['-', '-', '0'], ['0', '0', '0']])\n        self.assertEqual(minesweeper_game.score, 1)\n\n    def test_sweep_5(self):\n        minesweeper_game = MinesweeperGame(3, 1)\n        minesweeper_game.minesweeper_map = [['X', 1, 0], [1, 1, 0], [0, 0, 0]]\n        minesweeper_game.player_map = [['-', '-', '0'], ['-', '1', '0'], ['0', '0', '0']]\n        self.assertEqual(minesweeper_game.sweep(1,0), [['-', '-', '0'], [1, '1', '0'], ['0', '0', '0']])\n        self.assertEqual(minesweeper_game.score, 1)",
                "solution_code": "def sweep(self, x, y):\n\n        if (self.minesweeper_map[x][y] == 'X'):\n            return False\n        else:\n            self.player_map[x][y] = self.minesweeper_map[x][y]\n            self.score += 1\n            if self.check_won(self.player_map) == True:\n                return True\n            return self.player_map",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.minesweeper_map",
                        "self.player_map",
                        "self.score"
                    ],
                    "method_dependencies": [
                        "check_won"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_59",
        "skeleton": "from datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n    \"\"\"\n    this is a class as movie booking system, which allows to add movies, book tickets and check the available movies within a given time range. \n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initialize movies contains the information about movies\n        >>> system.movies\n        [{'name': 'Batman', 'price': 49.9, 'start_time': datetime.datetime(1900, 1, 1, 17, 5), 'end_time': datetime.datetime(1900, 1, 1, 19, 25),\n        'seats': array([[0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]])}]\n        \"\"\"\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        \"\"\"\n        Add a new movie into self.movies\n        :param name: str, movie name\n        :param price: float, price for one ticket\n        :param start_time: str\n        :param end_time: str\n        :param n: int, the size of seats(n*n)\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.movies\n        [{'name': 'Batman', 'price': 49.9, 'start_time': datetime.datetime(1900, 1, 1, 17, 5), 'end_time': datetime.datetime(1900, 1, 1, 19, 25),\n        'seats': array([[0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]])}]\n        \"\"\"\n\n    def book_ticket(self, name, seats_to_book):\n        \"\"\"\n        Book tickets for a movie. Change the seats value in self.movies if book successfully.\n        :param name: str, movie name\n        :param seats_to_book: list of tuples, representing seats to book [(row1, col1), (row2, col2), ...]\n        :return: str, booking status message. \"Movie not found.\" for no such movie.\n                \"Booking success.\" for successfully booking, or \"Booking failed.\" otherwise\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.book_ticket('Batman', [(0, 0), (0, 1)])\n        'Booking success.'\n        >>> system.book_ticket('Batman', [(0, 0)])\n        'Booking failed.'\n        >>> system.book_ticket('batman', [(0, 0)])\n        'Movie not found.'\n        \"\"\"\n\n    def available_movies(self, start_time, end_time):\n        \"\"\"\n        Get a list of available movies within the specified time range\n        :param start_time: str, start time in HH:MM format\n        :param end_time: str, end time in HH:MM format\n        :return: list of str, names of available movies\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.available_movies('12:00', '22:00')\n        ['Batman']\n        \"\"\"",
        "test": "import unittest\n\n\nclass MovieBookingSystemTestAddMovie(unittest.TestCase):\n    def setUp(self):\n        self.system = MovieBookingSystem()\n\n    def tearDown(self):\n        self.system = None\n\n    def test_add_movie_1(self):\n        self.system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        self.assertEqual(len(self.system.movies), 1)\n        self.assertEqual(self.system.movies[0]['name'], 'Batman')\n        self.assertEqual(self.system.movies[0]['price'], 49.9)\n        self.assertEqual(self.system.movies[0]['start_time'], datetime.strptime('17:05', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['end_time'], datetime.strptime('19:25', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['seats'].shape, (3, 3))\n\n    def test_add_movie_2(self):\n        self.system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        self.system.add_movie('Superman', 49.9, '17:05', '19:25', 3)\n        self.assertEqual(len(self.system.movies), 2)\n        self.assertEqual(self.system.movies[0]['name'], 'Batman')\n        self.assertEqual(self.system.movies[1]['name'], 'Superman')\n\n    def test_add_movie_3(self):\n        self.system.add_movie('Batman', 39.9, '17:05', '19:25', 3)\n        self.assertEqual(len(self.system.movies), 1)\n        self.assertEqual(self.system.movies[0]['name'], 'Batman')\n        self.assertEqual(self.system.movies[0]['price'], 39.9)\n        self.assertEqual(self.system.movies[0]['start_time'], datetime.strptime('17:05', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['end_time'], datetime.strptime('19:25', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['seats'].shape, (3, 3))\n\n    def test_add_movie_4(self):\n        self.system.add_movie('Batman', 29.9, '17:05', '19:25', 3)\n        self.assertEqual(len(self.system.movies), 1)\n        self.assertEqual(self.system.movies[0]['name'], 'Batman')\n        self.assertEqual(self.system.movies[0]['price'], 29.9)\n        self.assertEqual(self.system.movies[0]['start_time'], datetime.strptime('17:05', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['end_time'], datetime.strptime('19:25', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['seats'].shape, (3, 3))\n\n    def test_add_movie_5(self):\n        self.system.add_movie('Batman', 19.9, '17:05', '19:25', 3)\n        self.assertEqual(len(self.system.movies), 1)\n        self.assertEqual(self.system.movies[0]['name'], 'Batman')\n        self.assertEqual(self.system.movies[0]['price'], 19.9)\n        self.assertEqual(self.system.movies[0]['start_time'], datetime.strptime('17:05', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['end_time'], datetime.strptime('19:25', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['seats'].shape, (3, 3))\n\n\nclass MovieBookingSystemTestBookTicket(unittest.TestCase):\n    def setUp(self):\n        self.system = MovieBookingSystem()\n        self.system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n\n    # book successfully\n    def test_book_ticket_1(self):\n        result = self.system.book_ticket('Batman', [(0, 0), (1, 1), (2, 2)])\n        self.assertEqual(result, 'Booking success.')\n        self.assertEqual(self.system.movies[0]['seats'][0][0], 1)\n        self.assertEqual(self.system.movies[0]['seats'][1][1], 1)\n        self.assertEqual(self.system.movies[0]['seats'][2][2], 1)\n\n    # seat is not available\n    def test_book_ticket_2(self):\n        self.system.book_ticket('Batman', [(0, 0)])\n        result = self.system.book_ticket('Batman', [(0, 0)])\n        self.assertEqual(result, 'Booking failed.')\n        self.assertEqual(self.system.movies[0]['seats'][0][0], 1)\n\n    def test_book_ticket_3(self):\n        result = self.system.book_ticket('batman', [(0, 0)])\n        self.assertEqual(result, 'Movie not found.')\n        self.assertEqual(self.system.movies[0]['seats'][0][0], 0)\n\n    def test_book_ticket_4(self):\n        result = self.system.book_ticket('Batman', [(0, 0), (1, 1)])\n        self.assertEqual(result, 'Booking success.')\n        self.assertEqual(self.system.movies[0]['seats'][0][0], 1)\n        self.assertEqual(self.system.movies[0]['seats'][1][1], 1)\n\n    def test_book_ticket_5(self):\n        result = self.system.book_ticket('Batman', [(0, 0)])\n        self.assertEqual(result, 'Booking success.')\n        self.assertEqual(self.system.movies[0]['seats'][0][0], 1)\n\n\nclass MovieBookingSystemTestAvailableMovies(unittest.TestCase):\n    def setUp(self):\n        self.system = MovieBookingSystem()\n        self.system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        self.system.add_movie('Spiderman', 59.9, '20:00', '22:30', 4)\n\n    def test_available_movies_1(self):\n        result = self.system.available_movies('16:00', '23:00')\n        self.assertEqual(result, ['Batman', 'Spiderman'])\n\n    def test_available_movies_2(self):\n        result = self.system.available_movies('23:00', '23:59')\n        self.assertEqual(result, [])\n\n    def test_available_movies_3(self):\n        result = self.system.available_movies('17:00', '20:00')\n        self.assertEqual(result, ['Batman'])\n\n    def test_available_movies_4(self):\n        result = self.system.available_movies('10:00', '23:00')\n        self.assertEqual(result, ['Batman', 'Spiderman'])\n\n    def test_available_movies_5(self):\n        result = self.system.available_movies('20:00', '23:00')\n        self.assertEqual(result, ['Spiderman'])\n\n\nclass MovieBookingSystemTestMain(unittest.TestCase):\n    def test_main(self):\n        system = MovieBookingSystem()\n        system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        self.assertEqual(len(system.movies), 1)\n        self.assertEqual(system.movies[0]['name'], 'Batman')\n        self.assertEqual(system.movies[0]['price'], 49.9)\n        self.assertEqual(system.movies[0]['start_time'], datetime.strptime('17:05', '%H:%M'))\n        self.assertEqual(system.movies[0]['end_time'], datetime.strptime('19:25', '%H:%M'))\n        self.assertEqual(system.movies[0]['seats'].shape, (3, 3))\n\n        result = system.book_ticket('Batman', [(0, 0), (1, 1), (2, 2)])\n        self.assertEqual(result, 'Booking success.')\n        self.assertEqual(system.movies[0]['seats'][0][0], 1)\n        self.assertEqual(system.movies[0]['seats'][1][1], 1)\n        self.assertEqual(system.movies[0]['seats'][2][2], 1)\n\n        result = system.available_movies('16:00', '23:00')\n        self.assertEqual(result, ['Batman'])",
        "solution_code": "from datetime import datetime\nimport numpy as np\n\nclass MovieBookingSystem:\n    def __init__(self):\n        self.movies = []\n\n    def add_movie(self, name, price, start_time, end_time, n):\n        movie = {\n            'name': name,\n            'price': price,\n            'start_time': datetime.strptime(start_time, '%H:%M'),\n            'end_time': datetime.strptime(end_time, '%H:%M'),\n            'seats': np.zeros((n, n))\n        }\n        self.movies.append(movie)\n\n    def book_ticket(self, name, seats_to_book):\n        for movie in self.movies:\n            if movie['name'] == name:\n                for seat in seats_to_book:\n                    if movie['seats'][seat[0]][seat[1]] == 0:\n                        movie['seats'][seat[0]][seat[1]] = 1\n                    else:\n                        return \"Booking failed.\"\n                return \"Booking success.\"\n        return \"Movie not found.\"\n\n\n    def available_movies(self, start_time, end_time):\n        start_time = datetime.strptime(start_time, '%H:%M')\n        end_time = datetime.strptime(end_time, '%H:%M')\n\n        available_movies = []\n        for movie in self.movies:\n            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:\n                available_movies.append(movie['name'])\n\n        return available_movies",
        "import_statement": [
            "from datetime import datetime",
            "import numpy as np"
        ],
        "class_description": "    \"\"\"\n    this is a class as movie booking system, which allows to add movies, book tickets and check the available movies within a given time range. \n    \"\"\"\n",
        "class_name": "MovieBookingSystem",
        "test_classes": [
            "MovieBookingSystemTestAddMovie",
            "MovieBookingSystemTestBookTicket",
            "MovieBookingSystemTestAvailableMovies",
            "MovieBookingSystemTestMain"
        ],
        "class_constructor": "class MovieBookingSystem: \n    def __init__(self):\n        \"\"\"\n        Initialize movies contains the information about movies\n        >>> system.movies\n        [{'name': 'Batman', 'price': 49.9, 'start_time': datetime.datetime(1900, 1, 1, 17, 5), 'end_time': datetime.datetime(1900, 1, 1, 19, 25),\n        'seats': array([[0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]])}]\n        \"\"\"\n        self.movies = []\n\n",
        "fields": [
            "self.movies"
        ],
        "methods_info": [
            {
                "method_name": "add_movie",
                "method_description": "def add_movie(self, name, price, start_time, end_time, n):\n        \"\"\"\n        Add a new movie into self.movies\n        :param name: str, movie name\n        :param price: float, price for one ticket\n        :param start_time: str\n        :param end_time: str\n        :param n: int, the size of seats(n*n)\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.movies\n        [{'name': 'Batman', 'price': 49.9, 'start_time': datetime.datetime(1900, 1, 1, 17, 5), 'end_time': datetime.datetime(1900, 1, 1, 19, 25),\n        'seats': array([[0., 0., 0.],\n            [0., 0., 0.],\n            [0., 0., 0.]])}]\n        \"\"\"",
                "test_class": "MovieBookingSystemTestAddMovie",
                "test_code": "class MovieBookingSystemTestAddMovie(unittest.TestCase):\n    def setUp(self):\n        self.system = MovieBookingSystem()\n\n    def tearDown(self):\n        self.system = None\n\n    def test_add_movie_1(self):\n        self.system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        self.assertEqual(len(self.system.movies), 1)\n        self.assertEqual(self.system.movies[0]['name'], 'Batman')\n        self.assertEqual(self.system.movies[0]['price'], 49.9)\n        self.assertEqual(self.system.movies[0]['start_time'], datetime.strptime('17:05', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['end_time'], datetime.strptime('19:25', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['seats'].shape, (3, 3))\n\n    def test_add_movie_2(self):\n        self.system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        self.system.add_movie('Superman', 49.9, '17:05', '19:25', 3)\n        self.assertEqual(len(self.system.movies), 2)\n        self.assertEqual(self.system.movies[0]['name'], 'Batman')\n        self.assertEqual(self.system.movies[1]['name'], 'Superman')\n\n    def test_add_movie_3(self):\n        self.system.add_movie('Batman', 39.9, '17:05', '19:25', 3)\n        self.assertEqual(len(self.system.movies), 1)\n        self.assertEqual(self.system.movies[0]['name'], 'Batman')\n        self.assertEqual(self.system.movies[0]['price'], 39.9)\n        self.assertEqual(self.system.movies[0]['start_time'], datetime.strptime('17:05', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['end_time'], datetime.strptime('19:25', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['seats'].shape, (3, 3))\n\n    def test_add_movie_4(self):\n        self.system.add_movie('Batman', 29.9, '17:05', '19:25', 3)\n        self.assertEqual(len(self.system.movies), 1)\n        self.assertEqual(self.system.movies[0]['name'], 'Batman')\n        self.assertEqual(self.system.movies[0]['price'], 29.9)\n        self.assertEqual(self.system.movies[0]['start_time'], datetime.strptime('17:05', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['end_time'], datetime.strptime('19:25', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['seats'].shape, (3, 3))\n\n    def test_add_movie_5(self):\n        self.system.add_movie('Batman', 19.9, '17:05', '19:25', 3)\n        self.assertEqual(len(self.system.movies), 1)\n        self.assertEqual(self.system.movies[0]['name'], 'Batman')\n        self.assertEqual(self.system.movies[0]['price'], 19.9)\n        self.assertEqual(self.system.movies[0]['start_time'], datetime.strptime('17:05', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['end_time'], datetime.strptime('19:25', '%H:%M'))\n        self.assertEqual(self.system.movies[0]['seats'].shape, (3, 3))",
                "solution_code": "def add_movie(self, name, price, start_time, end_time, n):\n        movie = {\n            'name': name,\n            'price': price,\n            'start_time': datetime.strptime(start_time, '%H:%M'),\n            'end_time': datetime.strptime(end_time, '%H:%M'),\n            'seats': np.zeros((n, n))\n        }\n        self.movies.append(movie)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime"
                    ],
                    "field_dependencies": [
                        "self.movies"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "book_ticket",
                "method_description": "def book_ticket(self, name, seats_to_book):\n        \"\"\"\n        Book tickets for a movie. Change the seats value in self.movies if book successfully.\n        :param name: str, movie name\n        :param seats_to_book: list of tuples, representing seats to book [(row1, col1), (row2, col2), ...]\n        :return: str, booking status message. \"Movie not found.\" for no such movie.\n                \"Booking success.\" for successfully booking, or \"Booking failed.\" otherwise\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.book_ticket('Batman', [(0, 0), (0, 1)])\n        'Booking success.'\n        >>> system.book_ticket('Batman', [(0, 0)])\n        'Booking failed.'\n        >>> system.book_ticket('batman', [(0, 0)])\n        'Movie not found.'\n        \"\"\"",
                "test_class": "MovieBookingSystemTestBookTicket",
                "test_code": "class MovieBookingSystemTestBookTicket(unittest.TestCase):\n    def setUp(self):\n        self.system = MovieBookingSystem()\n        self.system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n\n    # book successfully\n    def test_book_ticket_1(self):\n        result = self.system.book_ticket('Batman', [(0, 0), (1, 1), (2, 2)])\n        self.assertEqual(result, 'Booking success.')\n        self.assertEqual(self.system.movies[0]['seats'][0][0], 1)\n        self.assertEqual(self.system.movies[0]['seats'][1][1], 1)\n        self.assertEqual(self.system.movies[0]['seats'][2][2], 1)\n\n    # seat is not available\n    def test_book_ticket_2(self):\n        self.system.book_ticket('Batman', [(0, 0)])\n        result = self.system.book_ticket('Batman', [(0, 0)])\n        self.assertEqual(result, 'Booking failed.')\n        self.assertEqual(self.system.movies[0]['seats'][0][0], 1)\n\n    def test_book_ticket_3(self):\n        result = self.system.book_ticket('batman', [(0, 0)])\n        self.assertEqual(result, 'Movie not found.')\n        self.assertEqual(self.system.movies[0]['seats'][0][0], 0)\n\n    def test_book_ticket_4(self):\n        result = self.system.book_ticket('Batman', [(0, 0), (1, 1)])\n        self.assertEqual(result, 'Booking success.')\n        self.assertEqual(self.system.movies[0]['seats'][0][0], 1)\n        self.assertEqual(self.system.movies[0]['seats'][1][1], 1)\n\n    def test_book_ticket_5(self):\n        result = self.system.book_ticket('Batman', [(0, 0)])\n        self.assertEqual(result, 'Booking success.')\n        self.assertEqual(self.system.movies[0]['seats'][0][0], 1)",
                "solution_code": "def book_ticket(self, name, seats_to_book):\n        for movie in self.movies:\n            if movie['name'] == name:\n                for seat in seats_to_book:\n                    if movie['seats'][seat[0]][seat[1]] == 0:\n                        movie['seats'][seat[0]][seat[1]] = 1\n                    else:\n                        return \"Booking failed.\"\n                return \"Booking success.\"\n        return \"Movie not found.\"",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.movies"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "available_movies",
                "method_description": "def available_movies(self, start_time, end_time):\n        \"\"\"\n        Get a list of available movies within the specified time range\n        :param start_time: str, start time in HH:MM format\n        :param end_time: str, end time in HH:MM format\n        :return: list of str, names of available movies\n        >>> system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        >>> system.available_movies('12:00', '22:00')\n        ['Batman']\n        \"\"\"",
                "test_class": "MovieBookingSystemTestAvailableMovies",
                "test_code": "class MovieBookingSystemTestAvailableMovies(unittest.TestCase):\n    def setUp(self):\n        self.system = MovieBookingSystem()\n        self.system.add_movie('Batman', 49.9, '17:05', '19:25', 3)\n        self.system.add_movie('Spiderman', 59.9, '20:00', '22:30', 4)\n\n    def test_available_movies_1(self):\n        result = self.system.available_movies('16:00', '23:00')\n        self.assertEqual(result, ['Batman', 'Spiderman'])\n\n    def test_available_movies_2(self):\n        result = self.system.available_movies('23:00', '23:59')\n        self.assertEqual(result, [])\n\n    def test_available_movies_3(self):\n        result = self.system.available_movies('17:00', '20:00')\n        self.assertEqual(result, ['Batman'])\n\n    def test_available_movies_4(self):\n        result = self.system.available_movies('10:00', '23:00')\n        self.assertEqual(result, ['Batman', 'Spiderman'])\n\n    def test_available_movies_5(self):\n        result = self.system.available_movies('20:00', '23:00')\n        self.assertEqual(result, ['Spiderman'])",
                "solution_code": "def available_movies(self, start_time, end_time):\n        start_time = datetime.strptime(start_time, '%H:%M')\n        end_time = datetime.strptime(end_time, '%H:%M')\n\n        available_movies = []\n        for movie in self.movies:\n            if start_time <= movie['start_time'] and movie['end_time'] <= end_time:\n                available_movies.append(movie['name'])\n\n        return available_movies",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime"
                    ],
                    "field_dependencies": [
                        "self.movies"
                    ],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_61",
        "skeleton": "class MusicPlayer:\n    \"\"\"\n    This is a class as a music player that provides to play, stop, add songs, remove songs, set volume, shuffle, and switch to the next or previous song.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        self.playlist = []\n        self.current_song = None\n        self.volume = 50\n\n    def add_song(self, song):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist, str.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.add_song(\"song1\")\n        >>> musicPlayer.playlist\n        ['song1']\n\n        \"\"\"\n\n    def remove_song(self, song):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist, str.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.remove_song(\"song1\")\n        >>> musicPlayer.playlist\n        ['song2']\n\n        \"\"\"\n\n    def play(self):\n        \"\"\"\n        Plays the current song in the playlist.\n        :return: The current song in the playlist, or False if there is no current song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.play()\n        'song1'\n\n        \"\"\"\n\n    def stop(self):\n        \"\"\"\n        Stops the current song in the playlist.\n        :return: True if the current song was stopped, False if there was no current song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.stop()\n        True\n\n        \"\"\"\n\n    def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if the next song was switched to, False if there was no next song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.switch_song()\n        True\n\n        \"\"\"\n\n    def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if the previous song was switched to, False if there was no previous song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song2\"\n        >>> musicPlayer.previous_song()\n        True\n\n        \"\"\"\n\n    def set_volume(self, volume):\n        \"\"\"\n        Sets the volume of the music player,ifthe volume is between 0 and 100 is valid.\n        :param volume: The volume to set the music player to,int.\n        :return: True if the volume was set, False if the volume was invalid.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.set_volume(50)\n        >>> musicPlayer.volume\n        50\n\n        \"\"\"\n\n    def shuffle(self):\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False if the playlist was empty.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.shuffle()\n        True\n\n        \"\"\"",
        "test": "import unittest\n\n\nclass MusicPlayerTestAddSong(unittest.TestCase):\n    def test_add_song(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.add_song(\"song1\")\n        self.assertEqual(musicPlayer.playlist, [\"song1\"])\n\n    def test_add_song2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.add_song(\"song1\")\n        musicPlayer.add_song(\"song2\")\n        self.assertEqual(musicPlayer.playlist, [\"song1\", \"song2\"])\n\n    def test_add_song3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.add_song(\"song1\")\n        musicPlayer.add_song(\"song2\")\n        musicPlayer.add_song(\"song3\")\n        self.assertEqual(musicPlayer.playlist, [\"song1\", \"song2\", \"song3\"])\n\n    def test_add_song4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.add_song(\"song1\")\n        musicPlayer.add_song(\"song2\")\n        musicPlayer.add_song(\"song3\")\n        musicPlayer.add_song(\"song4\")\n        self.assertEqual(musicPlayer.playlist, [\"song1\", \"song2\", \"song3\", \"song4\"])\n\n    def test_add_song5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.add_song(\"song1\")\n        musicPlayer.add_song(\"song2\")\n        musicPlayer.add_song(\"song3\")\n        musicPlayer.add_song(\"song4\")\n        musicPlayer.add_song(\"song5\")\n        self.assertEqual(musicPlayer.playlist, [\"song1\", \"song2\", \"song3\", \"song4\", \"song5\"])\n\nclass MusicPlayerTestRemoveSong(unittest.TestCase):\n    def test_remove_song(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.remove_song(\"song1\")\n        self.assertEqual(musicPlayer.playlist, [\"song2\"])\n\n    def test_remove_song2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.current_song = \"song1\"\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\"]\n        musicPlayer.remove_song(\"song1\")\n        self.assertEqual(musicPlayer.playlist, [\"song2\", \"song3\"])\n\n    def test_remove_song3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.current_song = \"song1\"\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\", \"song4\"]\n        musicPlayer.remove_song(\"song1\")\n        self.assertEqual(musicPlayer.playlist, [\"song2\", \"song3\", \"song4\"])\n\n    def test_remove_song4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\", \"song4\", \"song5\"]\n        musicPlayer.remove_song(\"song1\")\n        self.assertEqual(musicPlayer.playlist, [\"song2\", \"song3\", \"song4\", \"song5\"])\n\n    def test_remove_song5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\", \"song4\", \"song5\"]\n        musicPlayer.remove_song(\"song1\")\n        musicPlayer.remove_song(\"song2\")\n        self.assertEqual(musicPlayer.playlist, [\"song3\", \"song4\", \"song5\"])\n\n    def test_remove_song6(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = []\n        musicPlayer.remove_song(\"song1\")\n        self.assertEqual(musicPlayer.playlist, [])\n\n\nclass MusicPlayerTestPlay(unittest.TestCase):\n    def test_play(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.play(), \"song1\")\n\n    def test_play_2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = []\n        musicPlayer.current_song = \"song2\"\n        self.assertEqual(musicPlayer.play(), None)\n\n    def test_play_3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        self.assertEqual(musicPlayer.play(),False)\n\n    def test_play_4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song3\"\n        self.assertEqual(musicPlayer.play(), \"song1\")\n\n    def test_play_5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.play(), \"song1\")\n\nclass MusicPlayerTestStop(unittest.TestCase):\n    def test_stop(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.stop(), True)\n\n    def test_stop_2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = []\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.stop(), True)\n\n    def test_stop_3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        self.assertEqual(musicPlayer.stop(), False)\n\n    def test_stop_4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.stop(), True)\n\n    def test_stop_5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song2\"\n        self.assertEqual(musicPlayer.stop(), True)\n\nclass MusicPlayerTestSwitchSong(unittest.TestCase):\n    def test_switch_song(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.switch_song(), True)\n\n    def test_switch_song2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song2\"\n        self.assertEqual(musicPlayer.switch_song(), False)\n\n    def test_switch_song3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\"]\n        musicPlayer.current_song = \"song3\"\n        self.assertEqual(musicPlayer.switch_song(), False)\n\n    def test_switch_song4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        self.assertEqual(musicPlayer.switch_song(), False)\n\n    def test_switch_song5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = []\n        self.assertEqual(musicPlayer.switch_song(), False)\n\nclass MusicPlayerTestPreviousSong(unittest.TestCase):\n    def test_previous_song(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\"]\n        musicPlayer.current_song = \"song2\"\n        self.assertEqual(musicPlayer.previous_song(), True)\n\n    def test_previous_song2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.previous_song(), False)\n\n    def test_previous_song3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\"]\n        musicPlayer.current_song = \"song3\"\n        self.assertEqual(musicPlayer.previous_song(), True)\n\n    def test_previous_song4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\"]\n        self.assertEqual(musicPlayer.previous_song(), False)\n\n    def test_previous_song5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = []\n        self.assertEqual(musicPlayer.previous_song(), False)\n\nclass MusicPlayerTestSetVolume(unittest.TestCase):\n    def test_set_volume(self):\n        musicPlayer = MusicPlayer()\n        self.assertEqual(musicPlayer.set_volume(50), None)\n        self.assertEqual(musicPlayer.volume, 50)\n\n    def test_set_volume2(self):\n        musicPlayer = MusicPlayer()\n        self.assertEqual(musicPlayer.set_volume(100), None)\n        self.assertEqual(musicPlayer.volume, 100)\n\n    def test_set_volume3(self):\n        musicPlayer = MusicPlayer()\n        self.assertEqual(musicPlayer.set_volume(0), None)\n        self.assertEqual(musicPlayer.volume, 0)\n\n    def test_set_volume4(self):\n        musicPlayer = MusicPlayer()\n        self.assertEqual(musicPlayer.set_volume(101), False)\n        self.assertEqual(musicPlayer.volume, 50)\n\n    def test_set_volume5(self):\n        musicPlayer = MusicPlayer()\n        self.assertEqual(musicPlayer.set_volume(-1), False)\n        self.assertEqual(musicPlayer.volume, 50)\n\nclass MusicPlayerTestShuffle(unittest.TestCase):\n    def test_shuffle(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        self.assertEqual(musicPlayer.shuffle(), True)\n\n    def test_shuffle_2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = []\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.shuffle(), False)\n\n    def test_shuffle_3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song2\"\n        self.assertEqual(musicPlayer.shuffle(), True)\n\n    def test_shuffle_4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song3\"\n        self.assertEqual(musicPlayer.shuffle(), True)\n\n    def test_shuffle_5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.shuffle(), True)\n\nclass MusicPlayerTestMain(unittest.TestCase):\n    def test_main(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.play(), \"song1\")\n        self.assertEqual(musicPlayer.stop(), True)\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.switch_song(), True)\n        self.assertEqual(musicPlayer.previous_song(), True)\n        musicPlayer.set_volume(50)\n        self.assertEqual(musicPlayer.volume, 50)",
        "solution_code": "class MusicPlayer:\n    def __init__(self):\n        self.playlist = []\n        self.current_song = None\n        self.volume = 50\n\n    def add_song(self, song):\n        self.playlist.append(song)\n\n    def remove_song(self, song):\n        if song in self.playlist:\n            self.playlist.remove(song)\n            if self.current_song == song:\n                self.stop()\n\n    def play(self):\n        if self.playlist and self.current_song:\n            return self.playlist[0]\n        elif len(self.playlist): \n            return False\n\n    def stop(self):\n        if self.current_song:\n            self.current_song = None\n            return True\n        else:\n            return False\n\n    def switch_song(self):\n        if self.current_song:\n            current_index = self.playlist.index(self.current_song)\n            if current_index < len(self.playlist) - 1:\n                self.current_song = self.playlist[current_index + 1]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def previous_song(self):\n        if self.current_song:\n            current_index = self.playlist.index(self.current_song)\n            if current_index > 0:\n                self.current_song = self.playlist[current_index - 1]\n                return True\n            else:\n                return False\n        else:\n            return False\n\n    def set_volume(self, volume):\n        if 0 <= volume <= 100:\n            self.volume = volume\n        else:\n            return False\n\n    def shuffle(self):\n        if self.playlist:\n            import random\n            random.shuffle(self.playlist)\n            return True\n        else:\n            return False",
        "import_statement": [
            "import random"
        ],
        "class_description": "    \"\"\"\n    This is a class as a music player that provides to play, stop, add songs, remove songs, set volume, shuffle, and switch to the next or previous song.\n    \"\"\"\n",
        "class_name": "MusicPlayer",
        "test_classes": [
            "MusicPlayerTestAddSong",
            "MusicPlayerTestRemoveSong",
            "MusicPlayerTestPlay",
            "MusicPlayerTestStop",
            "MusicPlayerTestSwitchSong",
            "MusicPlayerTestPreviousSong",
            "MusicPlayerTestSetVolume",
            "MusicPlayerTestShuffle",
            "MusicPlayerTestMain"
        ],
        "class_constructor": "class MusicPlayer: \n    def __init__(self):\n        \"\"\"\n        Initializes the music player with an empty playlist, no current song, and a default volume of 50.\n        \"\"\"\n        self.playlist = []\n        self.current_song = None\n        self.volume = 50\n\n",
        "fields": [
            "self.current_song",
            "self.playlist",
            "self.volume"
        ],
        "methods_info": [
            {
                "method_name": "add_song",
                "method_description": "def add_song(self, song):\n        \"\"\"\n        Adds a song to the playlist.\n        :param song: The song to add to the playlist, str.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.add_song(\"song1\")\n        >>> musicPlayer.playlist\n        ['song1']\n\n        \"\"\"",
                "test_class": "MusicPlayerTestAddSong",
                "test_code": "class MusicPlayerTestAddSong(unittest.TestCase):\n    def test_add_song(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.add_song(\"song1\")\n        self.assertEqual(musicPlayer.playlist, [\"song1\"])\n\n    def test_add_song2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.add_song(\"song1\")\n        musicPlayer.add_song(\"song2\")\n        self.assertEqual(musicPlayer.playlist, [\"song1\", \"song2\"])\n\n    def test_add_song3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.add_song(\"song1\")\n        musicPlayer.add_song(\"song2\")\n        musicPlayer.add_song(\"song3\")\n        self.assertEqual(musicPlayer.playlist, [\"song1\", \"song2\", \"song3\"])\n\n    def test_add_song4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.add_song(\"song1\")\n        musicPlayer.add_song(\"song2\")\n        musicPlayer.add_song(\"song3\")\n        musicPlayer.add_song(\"song4\")\n        self.assertEqual(musicPlayer.playlist, [\"song1\", \"song2\", \"song3\", \"song4\"])\n\n    def test_add_song5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.add_song(\"song1\")\n        musicPlayer.add_song(\"song2\")\n        musicPlayer.add_song(\"song3\")\n        musicPlayer.add_song(\"song4\")\n        musicPlayer.add_song(\"song5\")\n        self.assertEqual(musicPlayer.playlist, [\"song1\", \"song2\", \"song3\", \"song4\", \"song5\"])",
                "solution_code": "def add_song(self, song):\n        self.playlist.append(song)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.playlist"
                    ],
                    "method_dependencies": [
                        "play"
                    ]
                }
            },
            {
                "method_name": "remove_song",
                "method_description": "def remove_song(self, song):\n        \"\"\"\n        Removes a song from the playlist.\n        :param song: The song to remove from the playlist, str.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.remove_song(\"song1\")\n        >>> musicPlayer.playlist\n        ['song2']\n\n        \"\"\"",
                "test_class": "MusicPlayerTestRemoveSong",
                "test_code": "class MusicPlayerTestRemoveSong(unittest.TestCase):\n    def test_remove_song(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.remove_song(\"song1\")\n        self.assertEqual(musicPlayer.playlist, [\"song2\"])\n\n    def test_remove_song2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.current_song = \"song1\"\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\"]\n        musicPlayer.remove_song(\"song1\")\n        self.assertEqual(musicPlayer.playlist, [\"song2\", \"song3\"])\n\n    def test_remove_song3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.current_song = \"song1\"\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\", \"song4\"]\n        musicPlayer.remove_song(\"song1\")\n        self.assertEqual(musicPlayer.playlist, [\"song2\", \"song3\", \"song4\"])\n\n    def test_remove_song4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\", \"song4\", \"song5\"]\n        musicPlayer.remove_song(\"song1\")\n        self.assertEqual(musicPlayer.playlist, [\"song2\", \"song3\", \"song4\", \"song5\"])\n\n    def test_remove_song5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\", \"song4\", \"song5\"]\n        musicPlayer.remove_song(\"song1\")\n        musicPlayer.remove_song(\"song2\")\n        self.assertEqual(musicPlayer.playlist, [\"song3\", \"song4\", \"song5\"])\n\n    def test_remove_song6(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = []\n        musicPlayer.remove_song(\"song1\")\n        self.assertEqual(musicPlayer.playlist, [])",
                "solution_code": "def remove_song(self, song):\n        if song in self.playlist:\n            self.playlist.remove(song)\n            if self.current_song == song:\n                self.stop()",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.current_song",
                        "self.playlist"
                    ],
                    "method_dependencies": [
                        "play",
                        "stop"
                    ]
                }
            },
            {
                "method_name": "play",
                "method_description": "def play(self):\n        \"\"\"\n        Plays the current song in the playlist.\n        :return: The current song in the playlist, or False if there is no current song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.play()\n        'song1'\n\n        \"\"\"",
                "test_class": "MusicPlayerTestPlay",
                "test_code": "class MusicPlayerTestPlay(unittest.TestCase):\n    def test_play(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.play(), \"song1\")\n\n    def test_play_2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = []\n        musicPlayer.current_song = \"song2\"\n        self.assertEqual(musicPlayer.play(), None)\n\n    def test_play_3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        self.assertEqual(musicPlayer.play(),False)\n\n    def test_play_4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song3\"\n        self.assertEqual(musicPlayer.play(), \"song1\")\n\n    def test_play_5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.play(), \"song1\")",
                "solution_code": "def play(self):\n        if self.playlist and self.current_song:\n            return self.playlist[0]\n        elif len(self.playlist): \n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.current_song",
                        "self.playlist"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "stop",
                "method_description": "def stop(self):\n        \"\"\"\n        Stops the current song in the playlist.\n        :return: True if the current song was stopped, False if there was no current song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.stop()\n        True\n\n        \"\"\"",
                "test_class": "MusicPlayerTestStop",
                "test_code": "class MusicPlayerTestStop(unittest.TestCase):\n    def test_stop(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.stop(), True)\n\n    def test_stop_2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = []\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.stop(), True)\n\n    def test_stop_3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        self.assertEqual(musicPlayer.stop(), False)\n\n    def test_stop_4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.stop(), True)\n\n    def test_stop_5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song2\"\n        self.assertEqual(musicPlayer.stop(), True)",
                "solution_code": "def stop(self):\n        if self.current_song:\n            self.current_song = None\n            return True\n        else:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.current_song"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "switch_song",
                "method_description": "def switch_song(self):\n        \"\"\"\n        Switches to the next song in the playlist.\n        :return: True if the next song was switched to, False if there was no next song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song1\"\n        >>> musicPlayer.switch_song()\n        True\n\n        \"\"\"",
                "test_class": "MusicPlayerTestSwitchSong",
                "test_code": "class MusicPlayerTestSwitchSong(unittest.TestCase):\n    def test_switch_song(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.switch_song(), True)\n\n    def test_switch_song2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song2\"\n        self.assertEqual(musicPlayer.switch_song(), False)\n\n    def test_switch_song3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\"]\n        musicPlayer.current_song = \"song3\"\n        self.assertEqual(musicPlayer.switch_song(), False)\n\n    def test_switch_song4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        self.assertEqual(musicPlayer.switch_song(), False)\n\n    def test_switch_song5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = []\n        self.assertEqual(musicPlayer.switch_song(), False)",
                "solution_code": "def switch_song(self):\n        if self.current_song:\n            current_index = self.playlist.index(self.current_song)\n            if current_index < len(self.playlist) - 1:\n                self.current_song = self.playlist[current_index + 1]\n                return True\n            else:\n                return False\n        else:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.current_song",
                        "self.playlist"
                    ],
                    "method_dependencies": [
                        "play"
                    ]
                }
            },
            {
                "method_name": "previous_song",
                "method_description": "def previous_song(self):\n        \"\"\"\n        Switches to the previous song in the playlist.\n        :return: True if the previous song was switched to, False if there was no previous song.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.current_song = \"song2\"\n        >>> musicPlayer.previous_song()\n        True\n\n        \"\"\"",
                "test_class": "MusicPlayerTestPreviousSong",
                "test_code": "class MusicPlayerTestPreviousSong(unittest.TestCase):\n    def test_previous_song(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\"]\n        musicPlayer.current_song = \"song2\"\n        self.assertEqual(musicPlayer.previous_song(), True)\n\n    def test_previous_song2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.previous_song(), False)\n\n    def test_previous_song3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\"]\n        musicPlayer.current_song = \"song3\"\n        self.assertEqual(musicPlayer.previous_song(), True)\n\n    def test_previous_song4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\", \"song3\"]\n        self.assertEqual(musicPlayer.previous_song(), False)\n\n    def test_previous_song5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = []\n        self.assertEqual(musicPlayer.previous_song(), False)",
                "solution_code": "def previous_song(self):\n        if self.current_song:\n            current_index = self.playlist.index(self.current_song)\n            if current_index > 0:\n                self.current_song = self.playlist[current_index - 1]\n                return True\n            else:\n                return False\n        else:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.current_song",
                        "self.playlist"
                    ],
                    "method_dependencies": [
                        "play"
                    ]
                }
            },
            {
                "method_name": "set_volume",
                "method_description": "def set_volume(self, volume):\n        \"\"\"\n        Sets the volume of the music player,ifthe volume is between 0 and 100 is valid.\n        :param volume: The volume to set the music player to,int.\n        :return: True if the volume was set, False if the volume was invalid.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.set_volume(50)\n        >>> musicPlayer.volume\n        50\n\n        \"\"\"",
                "test_class": "MusicPlayerTestSetVolume",
                "test_code": "class MusicPlayerTestSetVolume(unittest.TestCase):\n    def test_set_volume(self):\n        musicPlayer = MusicPlayer()\n        self.assertEqual(musicPlayer.set_volume(50), None)\n        self.assertEqual(musicPlayer.volume, 50)\n\n    def test_set_volume2(self):\n        musicPlayer = MusicPlayer()\n        self.assertEqual(musicPlayer.set_volume(100), None)\n        self.assertEqual(musicPlayer.volume, 100)\n\n    def test_set_volume3(self):\n        musicPlayer = MusicPlayer()\n        self.assertEqual(musicPlayer.set_volume(0), None)\n        self.assertEqual(musicPlayer.volume, 0)\n\n    def test_set_volume4(self):\n        musicPlayer = MusicPlayer()\n        self.assertEqual(musicPlayer.set_volume(101), False)\n        self.assertEqual(musicPlayer.volume, 50)\n\n    def test_set_volume5(self):\n        musicPlayer = MusicPlayer()\n        self.assertEqual(musicPlayer.set_volume(-1), False)\n        self.assertEqual(musicPlayer.volume, 50)",
                "solution_code": "def set_volume(self, volume):\n        if 0 <= volume <= 100:\n            self.volume = volume\n        else:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.volume"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "shuffle",
                "method_description": "def shuffle(self):\n        \"\"\"\n        Shuffles the playlist.\n        :return: True if the playlist was shuffled, False if the playlist was empty.\n        >>> musicPlayer = MusicPlayer()\n        >>> musicPlayer.playlist = [\"song1\", \"song2\"]\n        >>> musicPlayer.shuffle()\n        True\n\n        \"\"\"",
                "test_class": "MusicPlayerTestShuffle",
                "test_code": "class MusicPlayerTestShuffle(unittest.TestCase):\n    def test_shuffle(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        self.assertEqual(musicPlayer.shuffle(), True)\n\n    def test_shuffle_2(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = []\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.shuffle(), False)\n\n    def test_shuffle_3(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song2\"\n        self.assertEqual(musicPlayer.shuffle(), True)\n\n    def test_shuffle_4(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song3\"\n        self.assertEqual(musicPlayer.shuffle(), True)\n\n    def test_shuffle_5(self):\n        musicPlayer = MusicPlayer()\n        musicPlayer.playlist = [\"song1\", \"song2\"]\n        musicPlayer.current_song = \"song1\"\n        self.assertEqual(musicPlayer.shuffle(), True)",
                "solution_code": "def shuffle(self):\n        if self.playlist:\n            import random\n            random.shuffle(self.playlist)\n            return True\n        else:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "random"
                    ],
                    "field_dependencies": [
                        "self.playlist"
                    ],
                    "method_dependencies": [
                        "play"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_63",
        "skeleton": "import re\nfrom collections import Counter\n\nclass NLPDataProcessor2:\n    \"\"\"\n    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word, and returning the top 5 most frequent words.\n    \"\"\"\n\n\n    def process_data(self, string_list):\n        \"\"\"\n        keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words.\n        :param string_list: a list of strings\n        :return: words_list: a list of words lists\n        >>> NLPDataProcessor.process_data(['This is a test.'])\n        [['this', 'is', 'a', 'test']]\n        \"\"\"\n\n    def calculate_word_frequency(self, words_list):\n        \"\"\"\n        Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param words_list: a list of words lists\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.calculate_word_frequency([['this', 'is', 'a', 'test'], ['this', 'is', 'another', 'test']])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"\n\n    def process(self, string_list):\n        \"\"\"\n        keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words. Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param string_list: a list of strings\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.process(['This is a test.', 'This is another test.'])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"",
        "test": "import unittest\n\nclass NLPDataProcessorTestProcessData(unittest.TestCase):\n\n    def setUp(self):\n        self.processor = NLPDataProcessor2()\n\n    def test_process_data(self):\n        string_list = [\"Hello World!\", \"This is a test.\"]\n        expected_output = [['hello', 'world'], ['this', 'is', 'a', 'test']]\n        self.assertEqual(self.processor.process_data(string_list), expected_output)\n\n    def test_process_data2(self):\n        string_list = [\"12345\", \"Special@Characters\"]\n        expected_output = [[], ['specialcharacters']]\n        self.assertEqual(self.processor.process_data(string_list), expected_output)\n\n    def test_process_data3(self):\n        string_list = []\n        expected_output = []\n        self.assertEqual(self.processor.process_data(string_list), expected_output)\n\n    def test_process_data4(self):\n        string_list = [\"Hello World!\", \"This is a test.\", \"12345\", \"Special@Characters\"]\n        expected_output = [['hello', 'world'], ['this', 'is', 'a', 'test'], [], ['specialcharacters']]\n        self.assertEqual(self.processor.process_data(string_list), expected_output)\n\n    def test_process_data5(self):\n        string_list = [\"Hello World!\", \"This is a test.\", \"12345\", \"Special@Characters\", \"Hello World!\", \"This is a test.\", \"12345\", \"Special@Characters\"]\n        expected_output = [['hello', 'world'], ['this', 'is', 'a', 'test'], [], ['specialcharacters'], ['hello', 'world'], ['this', 'is', 'a', 'test'], [], ['specialcharacters']]\n        self.assertEqual(self.processor.process_data(string_list), expected_output)\n\nclass NLPDataProcessorTestCalculate(unittest.TestCase):\n\n    def setUp(self):\n        self.processor = NLPDataProcessor2()\n\n    def test_calculate_word_frequency(self):\n        words_list = [['hello', 'world'], ['this', 'is', 'a', 'test'], ['hello', 'world', 'this', 'is', 'another', 'test'],\n                      ['hello', 'hello', 'world']]\n        expected_output = {'hello': 4, 'world': 3, 'this': 2, 'is': 2, 'test': 2}\n        self.assertEqual(self.processor.calculate_word_frequency(words_list), expected_output)\n\n    def test_calculate_word_frequency2(self):\n        words_list = [['hello', 'world'], ['this', 'is', 'a', 'test'], ['hello', 'world', 'this', 'is', 'another', 'test'],\n                      ['hello', 'hello', 'world'], ['world', 'world', 'world']]\n        expected_output = {'world': 6, 'hello': 4, 'this': 2, 'is': 2, 'test': 2}\n        self.assertEqual(self.processor.calculate_word_frequency(words_list), expected_output)\n\n    def test_calculate_word_frequency3(self):\n        words_list = [['hello', 'world'], ['hello', 'hello', 'world'], ['world', 'world']]\n        expected_output = {'world': 4, 'hello': 3}\n        self.assertEqual(self.processor.calculate_word_frequency(words_list), expected_output)\n\n    def test_calculate_word_frequency4(self):\n        words_list = [['hello', 'world'], ['this', 'is', 'a', '%%%'], ['hello', 'world', 'this', 'is', 'another', '%%%'],\n                      ['hello', 'hello', 'world'], ['%%%', 'world', 'a', '%%%'], ['%%%', 'hello', '%%%']]\n        expected_output = {'%%%': 6, 'hello': 5, 'world': 4, 'is': 2, 'this': 2}\n        self.assertEqual(self.processor.calculate_word_frequency(words_list), expected_output)\n\n    def test_calculate_word_frequency5(self):\n        words_list = [['hello', 'world'], ['this', 'is', 'a', '%%%'], ['hello', 'world', 'this', 'is', 'another', '%%%'],\n                      ['hello', 'hello', 'world'], ['%%%', 'world', 'a', '%%%'], ['%%%', 'hello', '%%%'], ['hello', 'world'], ['this', 'is', 'a', '%%%'], ['hello', 'world', 'this', 'is', 'another', '%%%'],\n                      ['hello', 'hello', 'world'], ['%%%', 'world', 'a', '%%%'], ['%%%', 'hello', '%%%']]\n        expected_output = {'%%%': 12, 'hello': 10, 'world': 8, 'is': 4, 'this': 4}\n        self.assertEqual(self.processor.calculate_word_frequency(words_list), expected_output)\n\nclass NLPDataProcessorTestProcess(unittest.TestCase):\n\n    def setUp(self):\n        self.processor = NLPDataProcessor2()\n\n    def test_process(self):\n        string_list = [\"Hello World!\", \"This is a test.\", \"Hello World, this is a test.\"]\n        expected_output = {'hello': 2, 'world': 2, 'this': 2, 'is': 2, 'a': 2}\n        self.assertEqual(self.processor.process(string_list), expected_output)\n\n    def test_process2(self):\n        string_list = []\n        expected_output = []\n        self.assertEqual(self.processor.process_data(string_list), expected_output)\n\n    def test_calculate3(self):\n        words_list = []\n        expected_output = {}\n        self.assertEqual(self.processor.calculate_word_frequency(words_list), expected_output)\n\n    def test_process4(self):\n        string_list = [\"@#$%^&*\", \"Special_Characters\", \"12345\"]\n        expected_output = [[], ['specialcharacters'], []]\n        self.assertEqual(self.processor.process_data(string_list), expected_output)\n\n    def test_process5(self):\n        string_list = [\"Hello World! %%%\", \"This is a %%% test. %%% \", \"Hello World, this is a test. %%%\"]\n        expected_output = {'hello': 2, 'world': 2, 'this': 2, 'is': 2, 'a': 2}\n        self.assertEqual(self.processor.process(string_list), expected_output)\n\n    def test_process6(self):\n        string_list = [\"12345\", \"67890\", \"98765\"]\n        expected_output = [[], [], []]\n        self.assertEqual(self.processor.process_data(string_list), expected_output)",
        "solution_code": "from collections import Counter\nimport re\n\nclass NLPDataProcessor2:\n\n    def process_data(self, string_list):\n        words_list = []\n        for string in string_list:\n            # Remove non-English letters and convert to lowercase\n            processed_string = re.sub(r'[^a-zA-Z\\s]', '', string.lower())\n            # Split the string into words\n            words = processed_string.split()\n            words_list.append(words)\n        return words_list\n\n    def calculate_word_frequency(self, words_list):\n        word_frequency = Counter()\n        for words in words_list:\n            word_frequency.update(words)\n        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))\n        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])\n        return top_5_word_frequency\n\n    def process(self, string_list):\n        words_list = self.process_data(string_list)\n        word_frequency_dict = self.calculate_word_frequency(words_list)\n        return word_frequency_dict",
        "import_statement": [
            "from collections import Counter",
            "import re"
        ],
        "class_description": "    \"\"\"\n    The class processes NLP data by extracting words from a list of strings, calculating the frequency of each word, and returning the top 5 most frequent words.\n    \"\"\"\n",
        "class_name": "NLPDataProcessor2",
        "test_classes": [
            "NLPDataProcessorTestProcessData",
            "NLPDataProcessorTestCalculate",
            "NLPDataProcessorTestProcess"
        ],
        "class_constructor": "class NLPDataProcessor2: \n",
        "fields": [],
        "methods_info": [
            {
                "method_name": "process_data",
                "method_description": "def process_data(self, string_list):\n        \"\"\"\n        keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words.\n        :param string_list: a list of strings\n        :return: words_list: a list of words lists\n        >>> NLPDataProcessor.process_data(['This is a test.'])\n        [['this', 'is', 'a', 'test']]\n        \"\"\"",
                "test_class": "NLPDataProcessorTestProcessData",
                "test_code": "class NLPDataProcessorTestProcessData(unittest.TestCase):\n\n    def setUp(self):\n        self.processor = NLPDataProcessor2()\n\n    def test_process_data(self):\n        string_list = [\"Hello World!\", \"This is a test.\"]\n        expected_output = [['hello', 'world'], ['this', 'is', 'a', 'test']]\n        self.assertEqual(self.processor.process_data(string_list), expected_output)\n\n    def test_process_data2(self):\n        string_list = [\"12345\", \"Special@Characters\"]\n        expected_output = [[], ['specialcharacters']]\n        self.assertEqual(self.processor.process_data(string_list), expected_output)\n\n    def test_process_data3(self):\n        string_list = []\n        expected_output = []\n        self.assertEqual(self.processor.process_data(string_list), expected_output)\n\n    def test_process_data4(self):\n        string_list = [\"Hello World!\", \"This is a test.\", \"12345\", \"Special@Characters\"]\n        expected_output = [['hello', 'world'], ['this', 'is', 'a', 'test'], [], ['specialcharacters']]\n        self.assertEqual(self.processor.process_data(string_list), expected_output)\n\n    def test_process_data5(self):\n        string_list = [\"Hello World!\", \"This is a test.\", \"12345\", \"Special@Characters\", \"Hello World!\", \"This is a test.\", \"12345\", \"Special@Characters\"]\n        expected_output = [['hello', 'world'], ['this', 'is', 'a', 'test'], [], ['specialcharacters'], ['hello', 'world'], ['this', 'is', 'a', 'test'], [], ['specialcharacters']]\n        self.assertEqual(self.processor.process_data(string_list), expected_output)",
                "solution_code": "def process_data(self, string_list):\n        words_list = []\n        for string in string_list:\n            # Remove non-English letters and convert to lowercase\n            processed_string = re.sub(r'[^a-zA-Z\\s]', '', string.lower())\n            # Split the string into words\n            words = processed_string.split()\n            words_list.append(words)\n        return words_list",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "re"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "process"
                    ]
                }
            },
            {
                "method_name": "calculate_word_frequency",
                "method_description": "def calculate_word_frequency(self, words_list):\n        \"\"\"\n        Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param words_list: a list of words lists\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.calculate_word_frequency([['this', 'is', 'a', 'test'], ['this', 'is', 'another', 'test']])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"",
                "test_class": "NLPDataProcessorTestCalculate",
                "test_code": "class NLPDataProcessorTestCalculate(unittest.TestCase):\n\n    def setUp(self):\n        self.processor = NLPDataProcessor2()\n\n    def test_calculate_word_frequency(self):\n        words_list = [['hello', 'world'], ['this', 'is', 'a', 'test'], ['hello', 'world', 'this', 'is', 'another', 'test'],\n                      ['hello', 'hello', 'world']]\n        expected_output = {'hello': 4, 'world': 3, 'this': 2, 'is': 2, 'test': 2}\n        self.assertEqual(self.processor.calculate_word_frequency(words_list), expected_output)\n\n    def test_calculate_word_frequency2(self):\n        words_list = [['hello', 'world'], ['this', 'is', 'a', 'test'], ['hello', 'world', 'this', 'is', 'another', 'test'],\n                      ['hello', 'hello', 'world'], ['world', 'world', 'world']]\n        expected_output = {'world': 6, 'hello': 4, 'this': 2, 'is': 2, 'test': 2}\n        self.assertEqual(self.processor.calculate_word_frequency(words_list), expected_output)\n\n    def test_calculate_word_frequency3(self):\n        words_list = [['hello', 'world'], ['hello', 'hello', 'world'], ['world', 'world']]\n        expected_output = {'world': 4, 'hello': 3}\n        self.assertEqual(self.processor.calculate_word_frequency(words_list), expected_output)\n\n    def test_calculate_word_frequency4(self):\n        words_list = [['hello', 'world'], ['this', 'is', 'a', '%%%'], ['hello', 'world', 'this', 'is', 'another', '%%%'],\n                      ['hello', 'hello', 'world'], ['%%%', 'world', 'a', '%%%'], ['%%%', 'hello', '%%%']]\n        expected_output = {'%%%': 6, 'hello': 5, 'world': 4, 'is': 2, 'this': 2}\n        self.assertEqual(self.processor.calculate_word_frequency(words_list), expected_output)\n\n    def test_calculate_word_frequency5(self):\n        words_list = [['hello', 'world'], ['this', 'is', 'a', '%%%'], ['hello', 'world', 'this', 'is', 'another', '%%%'],\n                      ['hello', 'hello', 'world'], ['%%%', 'world', 'a', '%%%'], ['%%%', 'hello', '%%%'], ['hello', 'world'], ['this', 'is', 'a', '%%%'], ['hello', 'world', 'this', 'is', 'another', '%%%'],\n                      ['hello', 'hello', 'world'], ['%%%', 'world', 'a', '%%%'], ['%%%', 'hello', '%%%']]\n        expected_output = {'%%%': 12, 'hello': 10, 'world': 8, 'is': 4, 'this': 4}\n        self.assertEqual(self.processor.calculate_word_frequency(words_list), expected_output)",
                "solution_code": "def calculate_word_frequency(self, words_list):\n        word_frequency = Counter()\n        for words in words_list:\n            word_frequency.update(words)\n        sorted_word_frequency = dict(sorted(word_frequency.items(), key=lambda x: x[1], reverse=True))\n        top_5_word_frequency = dict(list(sorted_word_frequency.items())[:5])\n        return top_5_word_frequency",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "Counter"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "process",
                "method_description": "def process(self, string_list):\n        \"\"\"\n        keep only English letters and spaces in the string, then convert the string to lower case, and then split the string into a list of words. Calculate the word frequency of each word in the list of words list, and sort the word frequency dictionary by value in descending order.\n        :param string_list: a list of strings\n        :return: top 5 word frequency dictionary, a dictionary of word frequency, key is word, value is frequency\n        >>> NLPDataProcessor.process(['This is a test.', 'This is another test.'])\n        {'this': 2, 'is': 2, 'test': 2, 'a': 1, 'another': 1}\n        \"\"\"",
                "test_class": "NLPDataProcessorTestProcess",
                "test_code": "class NLPDataProcessorTestProcess(unittest.TestCase):\n\n    def setUp(self):\n        self.processor = NLPDataProcessor2()\n\n    def test_process(self):\n        string_list = [\"Hello World!\", \"This is a test.\", \"Hello World, this is a test.\"]\n        expected_output = {'hello': 2, 'world': 2, 'this': 2, 'is': 2, 'a': 2}\n        self.assertEqual(self.processor.process(string_list), expected_output)\n\n    def test_process2(self):\n        string_list = []\n        expected_output = []\n        self.assertEqual(self.processor.process_data(string_list), expected_output)\n\n    def test_calculate3(self):\n        words_list = []\n        expected_output = {}\n        self.assertEqual(self.processor.calculate_word_frequency(words_list), expected_output)\n\n    def test_process4(self):\n        string_list = [\"@#$%^&*\", \"Special_Characters\", \"12345\"]\n        expected_output = [[], ['specialcharacters'], []]\n        self.assertEqual(self.processor.process_data(string_list), expected_output)\n\n    def test_process5(self):\n        string_list = [\"Hello World! %%%\", \"This is a %%% test. %%% \", \"Hello World, this is a test. %%%\"]\n        expected_output = {'hello': 2, 'world': 2, 'this': 2, 'is': 2, 'a': 2}\n        self.assertEqual(self.processor.process(string_list), expected_output)\n\n    def test_process6(self):\n        string_list = [\"12345\", \"67890\", \"98765\"]\n        expected_output = [[], [], []]\n        self.assertEqual(self.processor.process_data(string_list), expected_output)",
                "solution_code": "def process(self, string_list):\n        words_list = self.process_data(string_list)\n        word_frequency_dict = self.calculate_word_frequency(words_list)\n        return word_frequency_dict",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "process_data",
                        "calculate_word_frequency"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_69",
        "skeleton": "import PyPDF2\n\nclass PDFHandler:\n    \"\"\"\n    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.\n    \"\"\"\n\n    def __init__(self, filepaths):\n        \"\"\"\n        takes a list of file paths filepaths as a parameter.\n        It creates a list named readers using PyPDF2, where each reader opens a file from the given paths.\n        \"\"\"\n        self.filepaths = filepaths\n        self.readers = [PyPDF2.PdfFileReader(fp) for fp in filepaths]\n\n    def merge_pdfs(self, output_filepath):\n        \"\"\"\n        Read files in self.readers which stores handles to multiple PDF files.\n        Merge them to one pdf and update the page number, then save in disk.\n        :param output_filepath: str, ouput file path to save to\n        :return: str, \"Merged PDFs saved at {output_filepath}\" if successfully merged\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.merge_pdfs('out.pdf')\n        Merged PDFs saved at out.pdf\n        \"\"\"\n\n    def extract_text_from_pdfs(self):\n        \"\"\"\n        Extract text from pdf files in self.readers\n        :return pdf_texts: list of str, each element is the text of one pdf file\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.extract_text_from_pdfs()\n        ['Test a.pdf', 'Test b.pdf']\n        \"\"\"",
        "test": "import os\nimport unittest\nfrom PyPDF2 import PdfFileReader\nfrom reportlab.pdfgen import canvas\n\n\nclass TestPDFHandler(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.test_files = [\"test1.pdf\", \"test2.pdf\"]\n        cls.test_text = [\"This is a test1.\", \"This is a test2.\"]\n        for i in range(2):\n            c = canvas.Canvas(cls.test_files[i])\n            c.drawString(100, 100, cls.test_text[i])\n            c.showPage()\n            c.save()\n\n    @classmethod\n    def tearDownClass(cls):\n        for filename in cls.test_files:\n            os.remove(filename)\n        os.remove(\"merged.pdf\")\n\n\n\nclass PDFHandlerTestMergePdfs(unittest.TestCase):\n    def setUp(self) -> None:\n        TestPDFHandler.setUpClass()\n\n    def tearDown(self) -> None:\n        TestPDFHandler.tearDownClass()\n\n    def test_merge_pdfs(self):\n        TestPDFHandler.setUpClass()\n        handler = PDFHandler(TestPDFHandler.test_files)\n        result = handler.merge_pdfs(\"merged.pdf\")\n        self.assertEqual(\"Merged PDFs saved at merged.pdf\", result)\n        self.assertTrue(os.path.exists(\"merged.pdf\"))\n\n\n\nclass PDFHandlerTestExtractTextFromPdfs(unittest.TestCase):\n    def setUp(self) -> None:\n        TestPDFHandler.setUpClass()\n\n    def test_extract_text_from_pdfs(self):\n        TestPDFHandler.setUpClass()\n        handler = PDFHandler(TestPDFHandler.test_files)\n        result = handler.extract_text_from_pdfs()\n        self.assertEqual(result, [\"This is a test1.\\n\", \"This is a test2.\\n\"])\n\n\nclass PDFHandlerTestMain(unittest.TestCase):\n    def setUp(self) -> None:\n        TestPDFHandler.setUpClass()\n\n    def tearDown(self) -> None:\n        TestPDFHandler.tearDownClass()\n\n    def test_main(self):\n        TestPDFHandler.setUpClass()\n        handler = PDFHandler(TestPDFHandler.test_files)\n        result = handler.merge_pdfs(\"merged.pdf\")\n        self.assertEqual(\"Merged PDFs saved at merged.pdf\", result)\n        self.assertTrue(os.path.exists(\"merged.pdf\"))\n\n        result = handler.extract_text_from_pdfs()\n        self.assertEqual(result, [\"This is a test1.\\n\", \"This is a test2.\\n\"])",
        "solution_code": "import PyPDF2\n\n\nclass PDFHandler:\n    def __init__(self, filepaths):\n        self.filepaths = filepaths\n        # PdfFileReader is deprecated and was removed in PyPDF2 3.0.0. Use PdfReader instead.\n        self.readers = [PyPDF2.PdfReader(fp) for fp in filepaths]\n\n    def merge_pdfs(self, output_filepath):\n        pdf_writer = PyPDF2.PdfWriter()\n\n        for reader in self.readers:\n            # reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.\n            for page_num in range(len(reader.pages)):\n                # reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.\n                page = reader.pages[page_num]\n                # addPage is deprecated and was removed in PyPDF2 3.0.0. Use add_page instead.\n                pdf_writer.add_page(page)\n\n        with open(output_filepath, 'wb') as out:\n            pdf_writer.write(out)\n        return f\"Merged PDFs saved at {output_filepath}\"\n\n    def extract_text_from_pdfs(self):\n        pdf_texts = []\n        for reader in self.readers:\n            for page_num in range(len(reader.pages)):\n                page = reader.pages[page_num]\n                pdf_texts.append(page.extract_text())\n        return pdf_texts",
        "import_statement": [
            "import PyPDF2"
        ],
        "class_description": "    \"\"\"\n    The class allows merging multiple PDF files into one and extracting text from PDFs using PyPDF2 library.\n    \"\"\"\n",
        "class_name": "PDFHandler",
        "test_classes": [
            "TestPDFHandler",
            "PDFHandlerTestMergePdfs",
            "PDFHandlerTestExtractTextFromPdfs",
            "PDFHandlerTestMain"
        ],
        "class_constructor": "class PDFHandler: \n    def __init__(self, filepaths):\n        \"\"\"\n        takes a list of file paths filepaths as a parameter.\n        It creates a list named readers using PyPDF2, where each reader opens a file from the given paths.\n        \"\"\"\n        self.filepaths = filepaths\n        self.readers = [PyPDF2.PdfFileReader(fp) for fp in filepaths]\n\n",
        "fields": [
            "self.filepaths",
            "self.readers"
        ],
        "methods_info": [
            {
                "method_name": "merge_pdfs",
                "method_description": "def merge_pdfs(self, output_filepath):\n        \"\"\"\n        Read files in self.readers which stores handles to multiple PDF files.\n        Merge them to one pdf and update the page number, then save in disk.\n        :param output_filepath: str, ouput file path to save to\n        :return: str, \"Merged PDFs saved at {output_filepath}\" if successfully merged\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.merge_pdfs('out.pdf')\n        Merged PDFs saved at out.pdf\n        \"\"\"",
                "test_class": "TestPDFHandler",
                "test_code": "class TestPDFHandler(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.test_files = [\"test1.pdf\", \"test2.pdf\"]\n        cls.test_text = [\"This is a test1.\", \"This is a test2.\"]\n        for i in range(2):\n            c = canvas.Canvas(cls.test_files[i])\n            c.drawString(100, 100, cls.test_text[i])\n            c.showPage()\n            c.save()\n\n    @classmethod\n    def tearDownClass(cls):\n        for filename in cls.test_files:\n            os.remove(filename)\n        os.remove(\"merged.pdf\")",
                "solution_code": "def merge_pdfs(self, output_filepath):\n        pdf_writer = PyPDF2.PdfWriter()\n\n        for reader in self.readers:\n            # reader.getNumPages is deprecated and was removed in PyPDF2 3.0.0. Use len(reader.pages) instead.\n            for page_num in range(len(reader.pages)):\n                # reader.getPage(pageNumber) is deprecated and was removed in PyPDF2 3.0.0. Use reader.pages[page_number] instead.\n                page = reader.pages[page_num]\n                # addPage is deprecated and was removed in PyPDF2 3.0.0. Use add_page instead.\n                pdf_writer.add_page(page)\n\n        with open(output_filepath, 'wb') as out:\n            pdf_writer.write(out)\n        return f\"Merged PDFs saved at {output_filepath}\"",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "PyPDF2"
                    ],
                    "field_dependencies": [
                        "self.readers"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "extract_text_from_pdfs",
                "method_description": "def extract_text_from_pdfs(self):\n        \"\"\"\n        Extract text from pdf files in self.readers\n        :return pdf_texts: list of str, each element is the text of one pdf file\n        >>> handler = PDFHandler(['a.pdf', 'b.pdf'])\n        >>> handler.extract_text_from_pdfs()\n        ['Test a.pdf', 'Test b.pdf']\n        \"\"\"",
                "test_class": "PDFHandlerTestMergePdfs",
                "test_code": "class PDFHandlerTestMergePdfs(unittest.TestCase):\n    def setUp(self) -> None:\n        TestPDFHandler.setUpClass()\n\n    def tearDown(self) -> None:\n        TestPDFHandler.tearDownClass()\n\n    def test_merge_pdfs(self):\n        TestPDFHandler.setUpClass()\n        handler = PDFHandler(TestPDFHandler.test_files)\n        result = handler.merge_pdfs(\"merged.pdf\")\n        self.assertEqual(\"Merged PDFs saved at merged.pdf\", result)\n        self.assertTrue(os.path.exists(\"merged.pdf\"))",
                "solution_code": "def extract_text_from_pdfs(self):\n        pdf_texts = []\n        for reader in self.readers:\n            for page_num in range(len(reader.pages)):\n                page = reader.pages[page_num]\n                pdf_texts.append(page.extract_text())\n        return pdf_texts",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.readers"
                    ],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_72",
        "skeleton": "import re\n\nclass RegexUtils:\n    \"\"\"\n    The class provides to match, find all occurrences, split, and substitute text using regular expressions. It also includes predefined patterns, validating phone numbers and extracting email addresses.\n    \"\"\"\n\n\n    def match(self, pattern, text):\n        \"\"\"\n        Check if the text matches the regular expression\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: True or False, representing whether the text matches the regular expression or not\n        >>> ru = RegexUtils()\n        >>> ru.match(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890\")\n        True\n        \"\"\"\n\n    def findall(self, pattern, text):\n        \"\"\"\n        Find all matching substrings and return a list of all matching substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: list of string, List of all matching substrings\n        >>> ru = RegexUtils()\n        >>> ru.findall(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        ['123-456-7890', '876-286-9876', '987-762-9767']\n        \"\"\"\n\n    def split(self, pattern, text):\n        \"\"\"\n        Split text based on regular expression patterns and return a list of substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to be split\n        :return: list of string, List of substrings after splitting\n        >>> ru = RegexUtils()\n        >>> ru.split(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        ['', ' abiguygusu ', ' kjgufwycs ', '']\n        \"\"\"\n\n    def sub(self, pattern, replacement, text):\n        \"\"\"\n        Replace the substring matched by a regular expression with the specified string\n        :param pattern: string, Regular expression pattern\n        :param replacement: Text to replace with\n        :param text: string, Text to be replaced\n        :return: string, Text after replacement\n        >>> ru = RegexUtils()\n        >>> ru.sub(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', 'phone num',  \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        'phone num abiguygusu phone num kjgufwycs phone num'\n        \"\"\"\n\n    def generate_email_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match email addresses\n        :return: string, regular expression patterns that match email addresses\n        >>> ru = RegexUtils()\n        >>> ru.generate_email_pattern()\n        '\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n        \"\"\"\n\n    def generate_phone_number_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match phone numbers\n        :return: string, regular expression patterns that match phone numbers\n        >>> ru = RegexUtils()\n        >>> ru.generate_phone_number_pattern()\n        '\\b\\d{3}-\\d{3}-\\d{4}\\b'\n        \"\"\"\n\n    def generate_split_sentences_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match the middle characters of two sentences\n        :return: string, regular expression patterns that match the middle characters of two sentences\n        >>> ru = RegexUtils()\n        >>> ru.generate_split_sentences_pattern()\n        '[.!?][\\s]{1,2}(?=[A-Z])'\n        \"\"\"\n\n    def split_sentences(self, text):\n        \"\"\"\n        Split the text into a list of sentences without Punctuation except the last sentence\n        :param text: Text to be split\n        :return: Split Text List\n        >>> ru = RegexUtils()\n        >>> ru.split_sentences(\"Aaa. Bbbb? Ccc!\")\n        ['Aaa', 'Bbbb', 'Ccc!']\n        \"\"\"\n\n    def validate_phone_number(self, phone_number):\n        \"\"\"\n        Verify if the phone number is valid\n        :param phone_number: Phone number to be verified\n        :return: True or False, indicating whether the phone number is valid\n        >>> ru = RegexUtils()\n        >>> ru.validate_phone_number(\"123-456-7890\")\n        True\n        \"\"\"\n\n    def extract_email(self, text):\n        \"\"\"\n        Extract all email addresses from the text\n        :param text: string, input text\n        :return: list of string, All extracted email addresses\n        >>> ru = RegexUtils()\n        >>> ru.extract_email(\"abcdefg@163.com ygusyfysy@126.com wljduyuv@qq.com\")\n        ['abcdefg@163.com', 'ygusyfysy@126.com', 'wljduyuv@qq.com']\n        \"\"\"",
        "test": "import unittest\n\n\nclass RegexUtilsTestMatch(unittest.TestCase):\n    def test_match_1(self):\n        ru = RegexUtils()\n        res = ru.match(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890\")\n        self.assertEqual(res, True)\n\n    def test_match_2(self):\n        ru = RegexUtils()\n        res = ru.match(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"1234567890\")\n        self.assertEqual(res, False)\n\n    def test_match_3(self):\n        ru = RegexUtils()\n        res = ru.match(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"111-111-1111\")\n        self.assertEqual(res, True)\n\n    def test_match_4(self):\n        ru = RegexUtils()\n        res = ru.match(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-789\")\n        self.assertEqual(res, False)\n\n    def test_match_5(self):\n        ru = RegexUtils()\n        res = ru.match(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-789a\")\n        self.assertEqual(res, False)\n\n\nclass RegexUtilsTestFindall(unittest.TestCase):\n    def test_findall_1(self):\n        ru = RegexUtils()\n        res = ru.findall(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['123-456-7890', '876-286-9876', '987-762-9767'])\n\n    def test_findall_2(self):\n        ru = RegexUtils()\n        res = ru.findall(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"abiguygusu  kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['987-762-9767'])\n\n    def test_findall_3(self):\n        ru = RegexUtils()\n        res = ru.findall(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"abiguygusu  kjgufwycs \")\n        self.assertEqual(res, [])\n\n    def test_findall_4(self):\n        ru = RegexUtils()\n        res = ru.findall(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"abiguygusu  111-111-1111 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['111-111-1111', '987-762-9767'])\n\n    def test_findall_5(self):\n        ru = RegexUtils()\n        res = ru.findall(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"abiguygusu  111-111-111a kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['987-762-9767'])\n\n\nclass RegexUtilsTestSplit(unittest.TestCase):\n    def test_split_1(self):\n        ru = RegexUtils()\n        res = ru.split(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['', ' abiguygusu ', ' kjgufwycs ', ''])\n\n    def test_split_2(self):\n        ru = RegexUtils()\n        res = ru.split(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"1234567890 abiguygusu 8762869876 kjgufwycs 9877629767\")\n        self.assertEqual(res, ['1234567890 abiguygusu 8762869876 kjgufwycs 9877629767'])\n\n    def test_split_3(self):\n        ru = RegexUtils()\n        res = ru.split(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"111-111-1111 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['', ' abiguygusu ', ' kjgufwycs ', ''])\n\n    def test_split_4(self):\n        ru = RegexUtils()\n        res = ru.split(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['123456-7890 abiguygusu ', ' kjgufwycs ', ''])\n\n    def test_split_5(self):\n        ru = RegexUtils()\n        res = ru.split(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-789a abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['123-456-789a abiguygusu ', ' kjgufwycs ', ''])\n\n\nclass RegexUtilsTestSub(unittest.TestCase):\n    def test_sub_1(self):\n        ru = RegexUtils()\n        res = ru.sub(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', 'phone num',\n                     \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, 'phone num abiguygusu phone num kjgufwycs phone num')\n\n    def test_sub_2(self):\n        ru = RegexUtils()\n        res = ru.sub(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', 'phone num',\n                     \"1234567890 abiguygusu 8762869876 kjgufwycs 9877629767\")\n        self.assertEqual(res, \"1234567890 abiguygusu 8762869876 kjgufwycs 9877629767\")\n\n    def test_sub_3(self):\n        ru = RegexUtils()\n        res = ru.sub(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', 'phone num',\n                     \"123456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, '123456-7890 abiguygusu phone num kjgufwycs phone num')\n\n    def test_sub_4(self):\n        ru = RegexUtils()\n        res = ru.sub(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', 'phone num',\n                     \"123-456-789a abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, '123-456-789a abiguygusu phone num kjgufwycs phone num')\n\n    def test_sub_5(self):\n        ru = RegexUtils()\n        res = ru.sub(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', 'phone num',\n                     \"123-456-780 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, '123-456-780 abiguygusu phone num kjgufwycs phone num')\n\n\nclass RegexUtilsTestGenerateEmailPattern(unittest.TestCase):\n    def test_generate_email_pattern_1(self):\n        ru = RegexUtils()\n        pat = ru.generate_email_pattern()\n        res = ru.match(pat, 'iustd87t2euh@163.com')\n        self.assertEqual(res, True)\n\n    def test_generate_email_pattern_2(self):\n        ru = RegexUtils()\n        pat = ru.generate_email_pattern()\n        res = ru.match(pat, 'iustd87t2euhifg.com')\n        self.assertEqual(res, False)\n\n    def test_generate_email_pattern_3(self):\n        ru = RegexUtils()\n        pat = ru.generate_email_pattern()\n        res = ru.match(pat, 'iustd87t2euhifg@.com')\n        self.assertEqual(res, False)\n\n    def test_generate_email_pattern_4(self):\n        ru = RegexUtils()\n        pat = ru.generate_email_pattern()\n        res = ru.match(pat, 'iustd87t2euhifg@.')\n        self.assertEqual(res, False)\n\n    def test_generate_email_pattern_5(self):\n        ru = RegexUtils()\n        pat = ru.generate_email_pattern()\n        res = ru.match(pat, 'iustd87t2euhifg@com.')\n        self.assertEqual(res, False)\n\n\nclass RegexUtilsTestGeneratePhoneNumberPattern(unittest.TestCase):\n    def test_generate_phone_number_pattern_1(self):\n        ru = RegexUtils()\n        pat = ru.generate_phone_number_pattern()\n        res = ru.match(pat, '123-456-7890')\n        self.assertEqual(res, True)\n\n    def test_generate_phone_number_pattern_2(self):\n        ru = RegexUtils()\n        pat = ru.generate_phone_number_pattern()\n        res = ru.match(pat, '1234567890')\n        self.assertEqual(res, False)\n\n    def test_generate_phone_number_pattern_3(self):\n        ru = RegexUtils()\n        pat = ru.generate_phone_number_pattern()\n        res = ru.match(pat, '123-456-789')\n        self.assertEqual(res, False)\n\n    def test_generate_phone_number_pattern_4(self):\n        ru = RegexUtils()\n        pat = ru.generate_phone_number_pattern()\n        res = ru.match(pat, 'a23-456-7890')\n        self.assertEqual(res, False)\n\n    def test_generate_phone_number_pattern_5(self):\n        ru = RegexUtils()\n        pat = ru.generate_phone_number_pattern()\n        res = ru.match(pat, '1234-56-7890')\n        self.assertEqual(res, False)\n\n\nclass RegexUtilsTestGenerateSplitSentencesPattern(unittest.TestCase):\n    def test_generate_split_sentences_pattern_1(self):\n        ru = RegexUtils()\n        pat = ru.generate_split_sentences_pattern()\n        res = ru.match(pat, '? Y')\n        self.assertEqual(res, True)\n\n    def test_generate_split_sentences_pattern_2(self):\n        ru = RegexUtils()\n        pat = ru.generate_split_sentences_pattern()\n        res = ru.match(pat, '! Y')\n        self.assertEqual(res, True)\n\n    def test_generate_split_sentences_pattern_3(self):\n        ru = RegexUtils()\n        pat = ru.generate_split_sentences_pattern()\n        res = ru.match(pat, '? ')\n        self.assertEqual(res, False)\n\n    def test_generate_split_sentences_pattern_4(self):\n        ru = RegexUtils()\n        pat = ru.generate_split_sentences_pattern()\n        res = ru.match(pat, '?Y')\n        self.assertEqual(res, False)\n\n    def test_generate_split_sentences_pattern_5(self):\n        ru = RegexUtils()\n        pat = ru.generate_split_sentences_pattern()\n        res = ru.match(pat, '.Y')\n        self.assertEqual(res, False)\n\n\nclass RegexUtilsTestSplitSentences(unittest.TestCase):\n    def test_split_sentences_1(self):\n        ru = RegexUtils()\n        res = ru.split_sentences(\"Aaa. Bbbb? Ccc!\")\n        self.assertEqual(res, ['Aaa', 'Bbbb', 'Ccc!'])\n\n    def test_split_sentences_2(self):\n        ru = RegexUtils()\n        res = ru.split_sentences(\"Aaa.Bbbb? Ccc!\")\n        self.assertEqual(res, ['Aaa.Bbbb', 'Ccc!'])\n\n    def test_split_sentences_3(self):\n        ru = RegexUtils()\n        res = ru.split_sentences(\"Aaa. bbbb? Ccc!\")\n        self.assertEqual(res, ['Aaa. bbbb', 'Ccc!'])\n\n    def test_split_sentences_4(self):\n        ru = RegexUtils()\n        res = ru.split_sentences(\"Aaa. bbbb, Ccc!\")\n        self.assertEqual(res, ['Aaa. bbbb, Ccc!'])\n\n    def test_split_sentences_5(self):\n        ru = RegexUtils()\n        res = ru.split_sentences(\"Aaa, Bbbb? Ccc!\")\n        self.assertEqual(res, ['Aaa, Bbbb', 'Ccc!'])\n\n\nclass RegexUtilsTestValidatePhoneNumber(unittest.TestCase):\n    def test_validate_phone_number_1(self):\n        ru = RegexUtils()\n        res = ru.validate_phone_number(\"123-456-7890\")\n        self.assertEqual(res, True)\n\n    def test_validate_phone_number_2(self):\n        ru = RegexUtils()\n        res = ru.validate_phone_number(\"1234567890\")\n        self.assertEqual(res, False)\n\n    def test_validate_phone_number_3(self):\n        ru = RegexUtils()\n        res = ru.validate_phone_number(\"a23-456-7890\")\n        self.assertEqual(res, False)\n\n    def test_validate_phone_number_4(self):\n        ru = RegexUtils()\n        res = ru.validate_phone_number(\"123-456-789\")\n        self.assertEqual(res, False)\n\n    def test_validate_phone_number_5(self):\n        ru = RegexUtils()\n        res = ru.validate_phone_number(\"1234-56-789\")\n        self.assertEqual(res, False)\n\n\nclass RegexUtilsTestExtractEmail(unittest.TestCase):\n    def test_extract_email_1(self):\n        ru = RegexUtils()\n        res = ru.extract_email(\"abcdefg@163.com ygusyfysy@126.com wljduyuv@qq.com\")\n        self.assertEqual(res, ['abcdefg@163.com', 'ygusyfysy@126.com', 'wljduyuv@qq.com'])\n\n    def test_extract_email_2(self):\n        ru = RegexUtils()\n        res = ru.extract_email(\"abcdefg@.com ygusyfysy@126.com wljduyuv@qq.com\")\n        self.assertEqual(res, ['ygusyfysy@126.com', 'wljduyuv@qq.com'])\n\n    def test_extract_email_3(self):\n        ru = RegexUtils()\n        res = ru.extract_email(\"abcdefgiscom ygusyfysy@126.com wljduyuv@qq.com\")\n        self.assertEqual(res, ['ygusyfysy@126.com', 'wljduyuv@qq.com'])\n\n    def test_extract_email_4(self):\n        ru = RegexUtils()\n        res = ru.extract_email(\"abcdefgiscom ygusyfysy126.com wljduyuv@qq.com\")\n        self.assertEqual(res, ['wljduyuv@qq.com'])\n\n    def test_extract_email_5(self):\n        ru = RegexUtils()\n        res = ru.extract_email(\"abcdefgiscom ygusyfysy@.com wljduyuv@qq.com\")\n        self.assertEqual(res, ['wljduyuv@qq.com'])\n\n\nclass RegexUtilsTest(unittest.TestCase):\n    def test_regexutils(self):\n        ru = RegexUtils()\n        res = ru.match(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890\")\n        self.assertEqual(res, True)\n\n        res = ru.findall(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['123-456-7890', '876-286-9876', '987-762-9767'])\n\n        res = ru.split(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['', ' abiguygusu ', ' kjgufwycs ', ''])\n\n        res = ru.sub(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', 'phone num',\n                     \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, 'phone num abiguygusu phone num kjgufwycs phone num')\n\n        pat = ru.generate_email_pattern()\n        res = ru.match(pat, 'iustd87t2euh@163.com')\n        self.assertEqual(res, True)\n\n        pat = ru.generate_phone_number_pattern()\n        res = ru.match(pat, '123-456-7890')\n        self.assertEqual(res, True)\n\n        pat = ru.generate_split_sentences_pattern()\n        res = ru.match(pat, '? Y')\n        self.assertEqual(res, True)\n\n        res = ru.split_sentences(\"Aaa. Bbbb? Ccc!\")\n        self.assertEqual(res, ['Aaa', 'Bbbb', 'Ccc!'])\n\n        res = ru.validate_phone_number(\"123-456-7890\")\n        self.assertEqual(res, True)\n\n        res = ru.extract_email(\"abcdefg@163.com ygusyfysy@126.com wljduyuv@qq.com\")\n        self.assertEqual(res, ['abcdefg@163.com', 'ygusyfysy@126.com', 'wljduyuv@qq.com'])",
        "solution_code": "import re\n\n\nclass RegexUtils:\n\n    def match(self, pattern, text):\n        ans = re.match(pattern, text)\n        if ans:\n            return True\n        else:\n            return False\n\n    def findall(self, pattern, text):\n        return re.findall(pattern, text)\n\n    def split(self, pattern, text):\n        return re.split(pattern, text)\n\n    def sub(self, pattern, replacement, text):\n        return re.sub(pattern, replacement, text)\n\n    def generate_email_pattern(self):\n        pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n        return pattern\n\n    def generate_phone_number_pattern(self):\n        pattern = r'\\b\\d{3}-\\d{3}-\\d{4}\\b'\n        return pattern\n\n    def generate_split_sentences_pattern(self):\n        pattern = r'[.!?][\\s]{1,2}(?=[A-Z])'\n        return pattern\n\n    def split_sentences(self, text):\n        pattern = self.generate_split_sentences_pattern()\n        return self.split(pattern, text)\n\n    def validate_phone_number(self, phone_number):\n        pattern = self.generate_phone_number_pattern()\n        return self.match(pattern, phone_number)\n\n    def extract_email(self, text):\n        pattern = self.generate_email_pattern()\n        return self.findall(pattern, text)",
        "import_statement": [
            "import re"
        ],
        "class_description": "    \"\"\"\n    The class provides to match, find all occurrences, split, and substitute text using regular expressions. It also includes predefined patterns, validating phone numbers and extracting email addresses.\n    \"\"\"\n",
        "class_name": "RegexUtils",
        "test_classes": [
            "RegexUtilsTestMatch",
            "RegexUtilsTestFindall",
            "RegexUtilsTestSplit",
            "RegexUtilsTestSub",
            "RegexUtilsTestGenerateEmailPattern",
            "RegexUtilsTestGeneratePhoneNumberPattern",
            "RegexUtilsTestGenerateSplitSentencesPattern",
            "RegexUtilsTestSplitSentences",
            "RegexUtilsTestValidatePhoneNumber",
            "RegexUtilsTestExtractEmail",
            "RegexUtilsTest"
        ],
        "class_constructor": "class RegexUtils: \n",
        "fields": [],
        "methods_info": [
            {
                "method_name": "match",
                "method_description": "def match(self, pattern, text):\n        \"\"\"\n        Check if the text matches the regular expression\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: True or False, representing whether the text matches the regular expression or not\n        >>> ru = RegexUtils()\n        >>> ru.match(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890\")\n        True\n        \"\"\"",
                "test_class": "RegexUtilsTestMatch",
                "test_code": "class RegexUtilsTestMatch(unittest.TestCase):\n    def test_match_1(self):\n        ru = RegexUtils()\n        res = ru.match(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890\")\n        self.assertEqual(res, True)\n\n    def test_match_2(self):\n        ru = RegexUtils()\n        res = ru.match(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"1234567890\")\n        self.assertEqual(res, False)\n\n    def test_match_3(self):\n        ru = RegexUtils()\n        res = ru.match(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"111-111-1111\")\n        self.assertEqual(res, True)\n\n    def test_match_4(self):\n        ru = RegexUtils()\n        res = ru.match(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-789\")\n        self.assertEqual(res, False)\n\n    def test_match_5(self):\n        ru = RegexUtils()\n        res = ru.match(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-789a\")\n        self.assertEqual(res, False)",
                "solution_code": "def match(self, pattern, text):\n        ans = re.match(pattern, text)\n        if ans:\n            return True\n        else:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "re"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "findall",
                "method_description": "def findall(self, pattern, text):\n        \"\"\"\n        Find all matching substrings and return a list of all matching substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to match\n        :return: list of string, List of all matching substrings\n        >>> ru = RegexUtils()\n        >>> ru.findall(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        ['123-456-7890', '876-286-9876', '987-762-9767']\n        \"\"\"",
                "test_class": "RegexUtilsTestFindall",
                "test_code": "class RegexUtilsTestFindall(unittest.TestCase):\n    def test_findall_1(self):\n        ru = RegexUtils()\n        res = ru.findall(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['123-456-7890', '876-286-9876', '987-762-9767'])\n\n    def test_findall_2(self):\n        ru = RegexUtils()\n        res = ru.findall(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"abiguygusu  kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['987-762-9767'])\n\n    def test_findall_3(self):\n        ru = RegexUtils()\n        res = ru.findall(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"abiguygusu  kjgufwycs \")\n        self.assertEqual(res, [])\n\n    def test_findall_4(self):\n        ru = RegexUtils()\n        res = ru.findall(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"abiguygusu  111-111-1111 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['111-111-1111', '987-762-9767'])\n\n    def test_findall_5(self):\n        ru = RegexUtils()\n        res = ru.findall(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"abiguygusu  111-111-111a kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['987-762-9767'])",
                "solution_code": "def findall(self, pattern, text):\n        return re.findall(pattern, text)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "re"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "split",
                "method_description": "def split(self, pattern, text):\n        \"\"\"\n        Split text based on regular expression patterns and return a list of substrings\n        :param pattern: string, Regular expression pattern\n        :param text: string, Text to be split\n        :return: list of string, List of substrings after splitting\n        >>> ru = RegexUtils()\n        >>> ru.split(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        ['', ' abiguygusu ', ' kjgufwycs ', '']\n        \"\"\"",
                "test_class": "RegexUtilsTestSplit",
                "test_code": "class RegexUtilsTestSplit(unittest.TestCase):\n    def test_split_1(self):\n        ru = RegexUtils()\n        res = ru.split(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['', ' abiguygusu ', ' kjgufwycs ', ''])\n\n    def test_split_2(self):\n        ru = RegexUtils()\n        res = ru.split(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"1234567890 abiguygusu 8762869876 kjgufwycs 9877629767\")\n        self.assertEqual(res, ['1234567890 abiguygusu 8762869876 kjgufwycs 9877629767'])\n\n    def test_split_3(self):\n        ru = RegexUtils()\n        res = ru.split(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"111-111-1111 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['', ' abiguygusu ', ' kjgufwycs ', ''])\n\n    def test_split_4(self):\n        ru = RegexUtils()\n        res = ru.split(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['123456-7890 abiguygusu ', ' kjgufwycs ', ''])\n\n    def test_split_5(self):\n        ru = RegexUtils()\n        res = ru.split(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', \"123-456-789a abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, ['123-456-789a abiguygusu ', ' kjgufwycs ', ''])",
                "solution_code": "def split(self, pattern, text):\n        return re.split(pattern, text)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "re"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "sub",
                "method_description": "def sub(self, pattern, replacement, text):\n        \"\"\"\n        Replace the substring matched by a regular expression with the specified string\n        :param pattern: string, Regular expression pattern\n        :param replacement: Text to replace with\n        :param text: string, Text to be replaced\n        :return: string, Text after replacement\n        >>> ru = RegexUtils()\n        >>> ru.sub(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', 'phone num',  \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        'phone num abiguygusu phone num kjgufwycs phone num'\n        \"\"\"",
                "test_class": "RegexUtilsTestSub",
                "test_code": "class RegexUtilsTestSub(unittest.TestCase):\n    def test_sub_1(self):\n        ru = RegexUtils()\n        res = ru.sub(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', 'phone num',\n                     \"123-456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, 'phone num abiguygusu phone num kjgufwycs phone num')\n\n    def test_sub_2(self):\n        ru = RegexUtils()\n        res = ru.sub(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', 'phone num',\n                     \"1234567890 abiguygusu 8762869876 kjgufwycs 9877629767\")\n        self.assertEqual(res, \"1234567890 abiguygusu 8762869876 kjgufwycs 9877629767\")\n\n    def test_sub_3(self):\n        ru = RegexUtils()\n        res = ru.sub(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', 'phone num',\n                     \"123456-7890 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, '123456-7890 abiguygusu phone num kjgufwycs phone num')\n\n    def test_sub_4(self):\n        ru = RegexUtils()\n        res = ru.sub(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', 'phone num',\n                     \"123-456-789a abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, '123-456-789a abiguygusu phone num kjgufwycs phone num')\n\n    def test_sub_5(self):\n        ru = RegexUtils()\n        res = ru.sub(r'\\b\\d{3}-\\d{3}-\\d{4}\\b', 'phone num',\n                     \"123-456-780 abiguygusu 876-286-9876 kjgufwycs 987-762-9767\")\n        self.assertEqual(res, '123-456-780 abiguygusu phone num kjgufwycs phone num')",
                "solution_code": "def sub(self, pattern, replacement, text):\n        return re.sub(pattern, replacement, text)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "re"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "generate_email_pattern",
                "method_description": "def generate_email_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match email addresses\n        :return: string, regular expression patterns that match email addresses\n        >>> ru = RegexUtils()\n        >>> ru.generate_email_pattern()\n        '\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n        \"\"\"",
                "test_class": "RegexUtilsTestGenerateEmailPattern",
                "test_code": "class RegexUtilsTestGenerateEmailPattern(unittest.TestCase):\n    def test_generate_email_pattern_1(self):\n        ru = RegexUtils()\n        pat = ru.generate_email_pattern()\n        res = ru.match(pat, 'iustd87t2euh@163.com')\n        self.assertEqual(res, True)\n\n    def test_generate_email_pattern_2(self):\n        ru = RegexUtils()\n        pat = ru.generate_email_pattern()\n        res = ru.match(pat, 'iustd87t2euhifg.com')\n        self.assertEqual(res, False)\n\n    def test_generate_email_pattern_3(self):\n        ru = RegexUtils()\n        pat = ru.generate_email_pattern()\n        res = ru.match(pat, 'iustd87t2euhifg@.com')\n        self.assertEqual(res, False)\n\n    def test_generate_email_pattern_4(self):\n        ru = RegexUtils()\n        pat = ru.generate_email_pattern()\n        res = ru.match(pat, 'iustd87t2euhifg@.')\n        self.assertEqual(res, False)\n\n    def test_generate_email_pattern_5(self):\n        ru = RegexUtils()\n        pat = ru.generate_email_pattern()\n        res = ru.match(pat, 'iustd87t2euhifg@com.')\n        self.assertEqual(res, False)",
                "solution_code": "def generate_email_pattern(self):\n        pattern = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n        return pattern",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "generate_phone_number_pattern",
                "method_description": "def generate_phone_number_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match phone numbers\n        :return: string, regular expression patterns that match phone numbers\n        >>> ru = RegexUtils()\n        >>> ru.generate_phone_number_pattern()\n        '\\b\\d{3}-\\d{3}-\\d{4}\\b'\n        \"\"\"",
                "test_class": "RegexUtilsTestGeneratePhoneNumberPattern",
                "test_code": "class RegexUtilsTestGeneratePhoneNumberPattern(unittest.TestCase):\n    def test_generate_phone_number_pattern_1(self):\n        ru = RegexUtils()\n        pat = ru.generate_phone_number_pattern()\n        res = ru.match(pat, '123-456-7890')\n        self.assertEqual(res, True)\n\n    def test_generate_phone_number_pattern_2(self):\n        ru = RegexUtils()\n        pat = ru.generate_phone_number_pattern()\n        res = ru.match(pat, '1234567890')\n        self.assertEqual(res, False)\n\n    def test_generate_phone_number_pattern_3(self):\n        ru = RegexUtils()\n        pat = ru.generate_phone_number_pattern()\n        res = ru.match(pat, '123-456-789')\n        self.assertEqual(res, False)\n\n    def test_generate_phone_number_pattern_4(self):\n        ru = RegexUtils()\n        pat = ru.generate_phone_number_pattern()\n        res = ru.match(pat, 'a23-456-7890')\n        self.assertEqual(res, False)\n\n    def test_generate_phone_number_pattern_5(self):\n        ru = RegexUtils()\n        pat = ru.generate_phone_number_pattern()\n        res = ru.match(pat, '1234-56-7890')\n        self.assertEqual(res, False)",
                "solution_code": "def generate_phone_number_pattern(self):\n        pattern = r'\\b\\d{3}-\\d{3}-\\d{4}\\b'\n        return pattern",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "generate_split_sentences_pattern",
                "method_description": "def generate_split_sentences_pattern(self):\n        \"\"\"\n        Generate regular expression patterns that match the middle characters of two sentences\n        :return: string, regular expression patterns that match the middle characters of two sentences\n        >>> ru = RegexUtils()\n        >>> ru.generate_split_sentences_pattern()\n        '[.!?][\\s]{1,2}(?=[A-Z])'\n        \"\"\"",
                "test_class": "RegexUtilsTestGenerateSplitSentencesPattern",
                "test_code": "class RegexUtilsTestGenerateSplitSentencesPattern(unittest.TestCase):\n    def test_generate_split_sentences_pattern_1(self):\n        ru = RegexUtils()\n        pat = ru.generate_split_sentences_pattern()\n        res = ru.match(pat, '? Y')\n        self.assertEqual(res, True)\n\n    def test_generate_split_sentences_pattern_2(self):\n        ru = RegexUtils()\n        pat = ru.generate_split_sentences_pattern()\n        res = ru.match(pat, '! Y')\n        self.assertEqual(res, True)\n\n    def test_generate_split_sentences_pattern_3(self):\n        ru = RegexUtils()\n        pat = ru.generate_split_sentences_pattern()\n        res = ru.match(pat, '? ')\n        self.assertEqual(res, False)\n\n    def test_generate_split_sentences_pattern_4(self):\n        ru = RegexUtils()\n        pat = ru.generate_split_sentences_pattern()\n        res = ru.match(pat, '?Y')\n        self.assertEqual(res, False)\n\n    def test_generate_split_sentences_pattern_5(self):\n        ru = RegexUtils()\n        pat = ru.generate_split_sentences_pattern()\n        res = ru.match(pat, '.Y')\n        self.assertEqual(res, False)",
                "solution_code": "def generate_split_sentences_pattern(self):\n        pattern = r'[.!?][\\s]{1,2}(?=[A-Z])'\n        return pattern",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "split_sentences",
                "method_description": "def split_sentences(self, text):\n        \"\"\"\n        Split the text into a list of sentences without Punctuation except the last sentence\n        :param text: Text to be split\n        :return: Split Text List\n        >>> ru = RegexUtils()\n        >>> ru.split_sentences(\"Aaa. Bbbb? Ccc!\")\n        ['Aaa', 'Bbbb', 'Ccc!']\n        \"\"\"",
                "test_class": "RegexUtilsTestSplitSentences",
                "test_code": "class RegexUtilsTestSplitSentences(unittest.TestCase):\n    def test_split_sentences_1(self):\n        ru = RegexUtils()\n        res = ru.split_sentences(\"Aaa. Bbbb? Ccc!\")\n        self.assertEqual(res, ['Aaa', 'Bbbb', 'Ccc!'])\n\n    def test_split_sentences_2(self):\n        ru = RegexUtils()\n        res = ru.split_sentences(\"Aaa.Bbbb? Ccc!\")\n        self.assertEqual(res, ['Aaa.Bbbb', 'Ccc!'])\n\n    def test_split_sentences_3(self):\n        ru = RegexUtils()\n        res = ru.split_sentences(\"Aaa. bbbb? Ccc!\")\n        self.assertEqual(res, ['Aaa. bbbb', 'Ccc!'])\n\n    def test_split_sentences_4(self):\n        ru = RegexUtils()\n        res = ru.split_sentences(\"Aaa. bbbb, Ccc!\")\n        self.assertEqual(res, ['Aaa. bbbb, Ccc!'])\n\n    def test_split_sentences_5(self):\n        ru = RegexUtils()\n        res = ru.split_sentences(\"Aaa, Bbbb? Ccc!\")\n        self.assertEqual(res, ['Aaa, Bbbb', 'Ccc!'])",
                "solution_code": "def split_sentences(self, text):\n        pattern = self.generate_split_sentences_pattern()\n        return self.split(pattern, text)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "split",
                        "generate_split_sentences_pattern"
                    ]
                }
            },
            {
                "method_name": "validate_phone_number",
                "method_description": "def validate_phone_number(self, phone_number):\n        \"\"\"\n        Verify if the phone number is valid\n        :param phone_number: Phone number to be verified\n        :return: True or False, indicating whether the phone number is valid\n        >>> ru = RegexUtils()\n        >>> ru.validate_phone_number(\"123-456-7890\")\n        True\n        \"\"\"",
                "test_class": "RegexUtilsTestValidatePhoneNumber",
                "test_code": "class RegexUtilsTestValidatePhoneNumber(unittest.TestCase):\n    def test_validate_phone_number_1(self):\n        ru = RegexUtils()\n        res = ru.validate_phone_number(\"123-456-7890\")\n        self.assertEqual(res, True)\n\n    def test_validate_phone_number_2(self):\n        ru = RegexUtils()\n        res = ru.validate_phone_number(\"1234567890\")\n        self.assertEqual(res, False)\n\n    def test_validate_phone_number_3(self):\n        ru = RegexUtils()\n        res = ru.validate_phone_number(\"a23-456-7890\")\n        self.assertEqual(res, False)\n\n    def test_validate_phone_number_4(self):\n        ru = RegexUtils()\n        res = ru.validate_phone_number(\"123-456-789\")\n        self.assertEqual(res, False)\n\n    def test_validate_phone_number_5(self):\n        ru = RegexUtils()\n        res = ru.validate_phone_number(\"1234-56-789\")\n        self.assertEqual(res, False)",
                "solution_code": "def validate_phone_number(self, phone_number):\n        pattern = self.generate_phone_number_pattern()\n        return self.match(pattern, phone_number)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "match",
                        "generate_phone_number_pattern"
                    ]
                }
            },
            {
                "method_name": "extract_email",
                "method_description": "def extract_email(self, text):\n        \"\"\"\n        Extract all email addresses from the text\n        :param text: string, input text\n        :return: list of string, All extracted email addresses\n        >>> ru = RegexUtils()\n        >>> ru.extract_email(\"abcdefg@163.com ygusyfysy@126.com wljduyuv@qq.com\")\n        ['abcdefg@163.com', 'ygusyfysy@126.com', 'wljduyuv@qq.com']\n        \"\"\"",
                "test_class": "RegexUtilsTestExtractEmail",
                "test_code": "class RegexUtilsTestExtractEmail(unittest.TestCase):\n    def test_extract_email_1(self):\n        ru = RegexUtils()\n        res = ru.extract_email(\"abcdefg@163.com ygusyfysy@126.com wljduyuv@qq.com\")\n        self.assertEqual(res, ['abcdefg@163.com', 'ygusyfysy@126.com', 'wljduyuv@qq.com'])\n\n    def test_extract_email_2(self):\n        ru = RegexUtils()\n        res = ru.extract_email(\"abcdefg@.com ygusyfysy@126.com wljduyuv@qq.com\")\n        self.assertEqual(res, ['ygusyfysy@126.com', 'wljduyuv@qq.com'])\n\n    def test_extract_email_3(self):\n        ru = RegexUtils()\n        res = ru.extract_email(\"abcdefgiscom ygusyfysy@126.com wljduyuv@qq.com\")\n        self.assertEqual(res, ['ygusyfysy@126.com', 'wljduyuv@qq.com'])\n\n    def test_extract_email_4(self):\n        ru = RegexUtils()\n        res = ru.extract_email(\"abcdefgiscom ygusyfysy126.com wljduyuv@qq.com\")\n        self.assertEqual(res, ['wljduyuv@qq.com'])\n\n    def test_extract_email_5(self):\n        ru = RegexUtils()\n        res = ru.extract_email(\"abcdefgiscom ygusyfysy@.com wljduyuv@qq.com\")\n        self.assertEqual(res, ['wljduyuv@qq.com'])",
                "solution_code": "def extract_email(self, text):\n        pattern = self.generate_email_pattern()\n        return self.findall(pattern, text)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "findall",
                        "generate_email_pattern"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_77",
        "skeleton": "import random\n\nclass Snake:\n    \"\"\"\n    The class is a snake game, with allows snake to move and eat food, and also enables to reset, and generat a random food position.\n    \"\"\"\n\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        \"\"\"\n        Initialize the length of the snake, screen width, screen height, block size, snake head position, score, and food position.\n        :param SCREEN_WIDTH: int\n        :param SCREEN_HEIGHT: int\n        :param BLOCK_SIZE: int, Size of moving units\n        :param food_position: tuple, representing the position(x, y) of food.\n        \"\"\"\n        self.length = 1\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        self.BLOCK_SIZE = BLOCK_SIZE\n        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]\n        self.score = 0\n        self.food_position = food_position\n\n\n    def move(self, direction):\n        \"\"\"\n        Move the snake in the specified direction. If the new position of the snake's head is equal to the position of the food, then eat the food; If the position of the snake's head is equal to the position of its body, then start over, otherwise its own length plus one.\n        :param direction: tuple, representing the direction of movement (x, y).\n        :return: None\n        >>> snake.move((1,1))\n        self.length = 1\n        self.positions = [(51, 51), (50, 50)]\n        self.score = 10\n        \"\"\"\n\n\n    def random_food_position(self):\n        \"\"\"\n        Randomly generate a new food position, but don't place it on the snake.\n        :return: None, Change the food position\n        \"\"\"\n\n\n    def reset(self):\n        \"\"\"\n        Reset the snake to its initial state. Set the length to 1, the snake head position to ((SCREEN_WIDTH/2), (SCREEN_HEIGHT/2)), the score to 0, and randomly generate new food position.\n        :return: None\n        >>> snake = Snake(100, 100, 1, (51, 51))\n        >>> snake.reset()\n        self.length = 1\n        self.positions = [(50, 50)]\n        self.score = 0\n        self.random_food_position()\n        \"\"\"\n\n\n    def eat_food(self):\n        \"\"\"\n        Increase the length of the snake by 1 and increase the score by 100. Randomly generate a new food position, but\n        don't place it on the snake.\n        :return: None\n        >>> snake = Snake(100, 100, 1, (51, 51))\n        >>> snake.move((1,1))\n        >>> snake.eat_food()\n        self.length = 2\n        self.score = 10\n        \"\"\"",
        "test": "import unittest\n\n\nclass SnakeTestMove(unittest.TestCase):\n    def test_move_1(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((1, 1))\n        self.assertEqual(snake.length, 2)\n        self.assertEqual(snake.positions[0], (51, 51))\n        self.assertEqual(snake.positions[1], (50, 50))\n        self.assertEqual(snake.score, 100)\n\n    def test_move_2(self):\n        snake = Snake(100, 100, 1, (80, 80))\n        snake.move((1, 1))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (51, 51))\n        self.assertEqual(snake.score, 0)\n\n    def test_move_3(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((1, 0))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (51, 50))\n        self.assertEqual(snake.score, 0)\n\n    def test_move_4(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((0, 0))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)\n\n    def test_move_5(self):\n        snake = Snake(100, 100, 1, (99, 99))\n        snake.move((1, 0))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (51, 50))\n        self.assertEqual(snake.score, 0)\n\n\nclass SnakeTestRandomFoodPosition(unittest.TestCase):\n    def test_random_food_position_1(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        self.assertEqual(snake.food_position, (51, 51))\n        snake.random_food_position()\n        self.assertNotIn(snake.food_position, snake.positions)\n        self.assertGreaterEqual(snake.food_position[0], 0)\n        self.assertGreaterEqual(snake.food_position[1], 0)\n        self.assertLessEqual(snake.food_position[0], 100)\n        self.assertLessEqual(snake.food_position[1], 100)\n\n    def test_random_food_position_2(self):\n        snake = Snake(100, 100, 1, (99, 99))\n        self.assertEqual(snake.food_position, (99, 99))\n        snake.random_food_position()\n        self.assertNotIn(snake.food_position, snake.positions)\n        self.assertGreaterEqual(snake.food_position[0], 0)\n        self.assertGreaterEqual(snake.food_position[1], 0)\n        self.assertLessEqual(snake.food_position[0], 100)\n        self.assertLessEqual(snake.food_position[1], 100)\n\n    def test_random_food_position_3(self):\n        snake = Snake(100, 100, 1, (0, 0))\n        self.assertEqual(snake.food_position, (0, 0))\n        snake.random_food_position()\n        self.assertNotIn(snake.food_position, snake.positions)\n        self.assertGreaterEqual(snake.food_position[0], 0)\n        self.assertGreaterEqual(snake.food_position[1], 0)\n        self.assertLessEqual(snake.food_position[0], 100)\n        self.assertLessEqual(snake.food_position[1], 100)\n\n    def test_random_food_position_4(self):\n        snake = Snake(100, 100, 1, (40, 40))\n        self.assertEqual(snake.food_position, (40, 40))\n        snake.random_food_position()\n        self.assertNotIn(snake.food_position, snake.positions)\n        self.assertGreaterEqual(snake.food_position[0], 0)\n        self.assertGreaterEqual(snake.food_position[1], 0)\n        self.assertLessEqual(snake.food_position[0], 100)\n        self.assertLessEqual(snake.food_position[1], 100)\n\n    def test_random_food_position_5(self):\n        snake = Snake(100, 100, 1, (60, 60))\n        self.assertEqual(snake.food_position, (60, 60))\n        snake.random_food_position()\n        self.assertNotIn(snake.food_position, snake.positions)\n        self.assertGreaterEqual(snake.food_position[0], 0)\n        self.assertGreaterEqual(snake.food_position[1], 0)\n        self.assertLessEqual(snake.food_position[0], 100)\n        self.assertLessEqual(snake.food_position[1], 100)\n\n\nclass SnakeTestReset(unittest.TestCase):\n    def test_reset_1(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((1, 1))\n        snake.reset()\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)\n\n    def test_reset_2(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((0, 1))\n        snake.reset()\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)\n\n    def test_reset_3(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((0, -1))\n        snake.reset()\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)\n\n    def test_reset_4(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((-1, 0))\n        snake.reset()\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)\n\n    def test_reset_5(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((1, 0))\n        snake.reset()\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)\n\n\nclass SnakeTestEatFood(unittest.TestCase):\n    def test_eat_food_1(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.score, 0)\n        snake.eat_food()\n        self.assertEqual(snake.length, 2)\n        self.assertEqual(snake.score, 100)\n\n    def test_eat_food_2(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.score, 0)\n        snake.eat_food()\n        snake.eat_food()\n        self.assertEqual(snake.length, 3)\n        self.assertEqual(snake.score, 200)\n\n    def test_eat_food_3(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.score, 0)\n        snake.eat_food()\n        snake.eat_food()\n        snake.eat_food()\n        self.assertEqual(snake.length, 4)\n        self.assertEqual(snake.score, 300)\n\n    def test_eat_food_4(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.score, 0)\n        snake.eat_food()\n        snake.eat_food()\n        snake.eat_food()\n        snake.eat_food()\n        self.assertEqual(snake.length, 5)\n        self.assertEqual(snake.score, 400)\n\n    def test_eat_food_5(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.score, 0)\n        snake.eat_food()\n        snake.eat_food()\n        snake.eat_food()\n        snake.eat_food()\n        snake.eat_food()\n        self.assertEqual(snake.length, 6)\n        self.assertEqual(snake.score, 500)\n\n\nclass SnakeTest(unittest.TestCase):\n    def test_snake(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.SCREEN_WIDTH, 100)\n        self.assertEqual(snake.SCREEN_HEIGHT, 100)\n        self.assertEqual(snake.BLOCK_SIZE, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)\n        self.assertEqual(snake.food_position, (51, 51))\n        snake.move((1, 1))\n        self.assertEqual(snake.length, 2)\n        self.assertEqual(snake.positions[0], (51, 51))\n        self.assertEqual(snake.score, 100)\n        snake.random_food_position()\n        self.assertNotIn(snake.food_position, snake.positions)\n        snake.reset()\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)",
        "solution_code": "import random\n\n\nclass Snake:\n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        self.length = 1\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        self.BLOCK_SIZE = BLOCK_SIZE\n        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]\n        self.score = 0\n        self.food_position = food_position\n\n    def move(self, direction):\n        cur = self.positions[0]\n        x, y = direction\n\n        new = (\n            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),\n            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,\n        )\n\n        if new == self.food_position:\n            self.eat_food()\n\n        if len(self.positions) > 2 and new in self.positions[2:]:\n            self.reset()\n        else:\n            self.positions.insert(0, new)\n            if len(self.positions) > self.length:\n                self.positions.pop()\n\n    def random_food_position(self):\n        while self.food_position in self.positions:\n            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,\n                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)\n\n    def reset(self):\n        self.length = 1\n        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]\n        self.score = 0\n        self.random_food_position()\n\n    def eat_food(self):\n        self.length += 1\n        self.score += 100\n        self.random_food_position()",
        "import_statement": [
            "import random"
        ],
        "class_description": "    \"\"\"\n    The class is a snake game, with allows snake to move and eat food, and also enables to reset, and generat a random food position.\n    \"\"\"\n",
        "class_name": "Snake",
        "test_classes": [
            "SnakeTestMove",
            "SnakeTestRandomFoodPosition",
            "SnakeTestReset",
            "SnakeTestEatFood",
            "SnakeTest"
        ],
        "class_constructor": "class Snake: \n    def __init__(self, SCREEN_WIDTH, SCREEN_HEIGHT, BLOCK_SIZE, food_position):\n        \"\"\"\n        Initialize the length of the snake, screen width, screen height, block size, snake head position, score, and food position.\n        :param SCREEN_WIDTH: int\n        :param SCREEN_HEIGHT: int\n        :param BLOCK_SIZE: int, Size of moving units\n        :param food_position: tuple, representing the position(x, y) of food.\n        \"\"\"\n        self.length = 1\n        self.SCREEN_WIDTH = SCREEN_WIDTH\n        self.SCREEN_HEIGHT = SCREEN_HEIGHT\n        self.BLOCK_SIZE = BLOCK_SIZE\n        self.positions = [((SCREEN_WIDTH / 2), (SCREEN_HEIGHT / 2))]\n        self.score = 0\n        self.food_position = food_position\n\n\n",
        "fields": [
            "self.BLOCK_SIZE",
            "self.SCREEN_HEIGHT",
            "self.SCREEN_WIDTH",
            "self.food_position",
            "self.length",
            "self.positions",
            "self.score"
        ],
        "methods_info": [
            {
                "method_name": "move",
                "method_description": "def move(self, direction):\n        \"\"\"\n        Move the snake in the specified direction. If the new position of the snake's head is equal to the position of the food, then eat the food; If the position of the snake's head is equal to the position of its body, then start over, otherwise its own length plus one.\n        :param direction: tuple, representing the direction of movement (x, y).\n        :return: None\n        >>> snake.move((1,1))\n        self.length = 1\n        self.positions = [(51, 51), (50, 50)]\n        self.score = 10\n        \"\"\"",
                "test_class": "SnakeTestMove",
                "test_code": "class SnakeTestMove(unittest.TestCase):\n    def test_move_1(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((1, 1))\n        self.assertEqual(snake.length, 2)\n        self.assertEqual(snake.positions[0], (51, 51))\n        self.assertEqual(snake.positions[1], (50, 50))\n        self.assertEqual(snake.score, 100)\n\n    def test_move_2(self):\n        snake = Snake(100, 100, 1, (80, 80))\n        snake.move((1, 1))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (51, 51))\n        self.assertEqual(snake.score, 0)\n\n    def test_move_3(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((1, 0))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (51, 50))\n        self.assertEqual(snake.score, 0)\n\n    def test_move_4(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((0, 0))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)\n\n    def test_move_5(self):\n        snake = Snake(100, 100, 1, (99, 99))\n        snake.move((1, 0))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (51, 50))\n        self.assertEqual(snake.score, 0)",
                "solution_code": "def move(self, direction):\n        cur = self.positions[0]\n        x, y = direction\n\n        new = (\n            ((cur[0] + (x * self.BLOCK_SIZE)) % self.SCREEN_WIDTH),\n            (cur[1] + (y * self.BLOCK_SIZE)) % self.SCREEN_HEIGHT,\n        )\n\n        if new == self.food_position:\n            self.eat_food()\n\n        if len(self.positions) > 2 and new in self.positions[2:]:\n            self.reset()\n        else:\n            self.positions.insert(0, new)\n            if len(self.positions) > self.length:\n                self.positions.pop()",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.BLOCK_SIZE",
                        "self.SCREEN_HEIGHT",
                        "self.SCREEN_WIDTH",
                        "self.food_position",
                        "self.length",
                        "self.positions"
                    ],
                    "method_dependencies": [
                        "reset",
                        "eat_food"
                    ]
                }
            },
            {
                "method_name": "random_food_position",
                "method_description": "def random_food_position(self):\n        \"\"\"\n        Randomly generate a new food position, but don't place it on the snake.\n        :return: None, Change the food position\n        \"\"\"",
                "test_class": "SnakeTestRandomFoodPosition",
                "test_code": "class SnakeTestRandomFoodPosition(unittest.TestCase):\n    def test_random_food_position_1(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        self.assertEqual(snake.food_position, (51, 51))\n        snake.random_food_position()\n        self.assertNotIn(snake.food_position, snake.positions)\n        self.assertGreaterEqual(snake.food_position[0], 0)\n        self.assertGreaterEqual(snake.food_position[1], 0)\n        self.assertLessEqual(snake.food_position[0], 100)\n        self.assertLessEqual(snake.food_position[1], 100)\n\n    def test_random_food_position_2(self):\n        snake = Snake(100, 100, 1, (99, 99))\n        self.assertEqual(snake.food_position, (99, 99))\n        snake.random_food_position()\n        self.assertNotIn(snake.food_position, snake.positions)\n        self.assertGreaterEqual(snake.food_position[0], 0)\n        self.assertGreaterEqual(snake.food_position[1], 0)\n        self.assertLessEqual(snake.food_position[0], 100)\n        self.assertLessEqual(snake.food_position[1], 100)\n\n    def test_random_food_position_3(self):\n        snake = Snake(100, 100, 1, (0, 0))\n        self.assertEqual(snake.food_position, (0, 0))\n        snake.random_food_position()\n        self.assertNotIn(snake.food_position, snake.positions)\n        self.assertGreaterEqual(snake.food_position[0], 0)\n        self.assertGreaterEqual(snake.food_position[1], 0)\n        self.assertLessEqual(snake.food_position[0], 100)\n        self.assertLessEqual(snake.food_position[1], 100)\n\n    def test_random_food_position_4(self):\n        snake = Snake(100, 100, 1, (40, 40))\n        self.assertEqual(snake.food_position, (40, 40))\n        snake.random_food_position()\n        self.assertNotIn(snake.food_position, snake.positions)\n        self.assertGreaterEqual(snake.food_position[0], 0)\n        self.assertGreaterEqual(snake.food_position[1], 0)\n        self.assertLessEqual(snake.food_position[0], 100)\n        self.assertLessEqual(snake.food_position[1], 100)\n\n    def test_random_food_position_5(self):\n        snake = Snake(100, 100, 1, (60, 60))\n        self.assertEqual(snake.food_position, (60, 60))\n        snake.random_food_position()\n        self.assertNotIn(snake.food_position, snake.positions)\n        self.assertGreaterEqual(snake.food_position[0], 0)\n        self.assertGreaterEqual(snake.food_position[1], 0)\n        self.assertLessEqual(snake.food_position[0], 100)\n        self.assertLessEqual(snake.food_position[1], 100)",
                "solution_code": "def random_food_position(self):\n        while self.food_position in self.positions:\n            self.food_position = (random.randint(0, self.SCREEN_WIDTH // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE,\n                                  random.randint(0, self.SCREEN_HEIGHT // self.BLOCK_SIZE - 1) * self.BLOCK_SIZE)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "random"
                    ],
                    "field_dependencies": [
                        "self.BLOCK_SIZE",
                        "self.SCREEN_HEIGHT",
                        "self.SCREEN_WIDTH",
                        "self.food_position",
                        "self.positions"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "reset",
                "method_description": "def reset(self):\n        \"\"\"\n        Reset the snake to its initial state. Set the length to 1, the snake head position to ((SCREEN_WIDTH/2), (SCREEN_HEIGHT/2)), the score to 0, and randomly generate new food position.\n        :return: None\n        >>> snake = Snake(100, 100, 1, (51, 51))\n        >>> snake.reset()\n        self.length = 1\n        self.positions = [(50, 50)]\n        self.score = 0\n        self.random_food_position()\n        \"\"\"",
                "test_class": "SnakeTestReset",
                "test_code": "class SnakeTestReset(unittest.TestCase):\n    def test_reset_1(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((1, 1))\n        snake.reset()\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)\n\n    def test_reset_2(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((0, 1))\n        snake.reset()\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)\n\n    def test_reset_3(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((0, -1))\n        snake.reset()\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)\n\n    def test_reset_4(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((-1, 0))\n        snake.reset()\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)\n\n    def test_reset_5(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        snake.move((1, 0))\n        snake.reset()\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.positions[0], (50, 50))\n        self.assertEqual(snake.score, 0)",
                "solution_code": "def reset(self):\n        self.length = 1\n        self.positions = [((self.SCREEN_WIDTH / 2), (self.SCREEN_HEIGHT / 2))]\n        self.score = 0\n        self.random_food_position()",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.SCREEN_HEIGHT",
                        "self.SCREEN_WIDTH",
                        "self.length",
                        "self.positions",
                        "self.score"
                    ],
                    "method_dependencies": [
                        "random_food_position"
                    ]
                }
            },
            {
                "method_name": "eat_food",
                "method_description": "def eat_food(self):\n        \"\"\"\n        Increase the length of the snake by 1 and increase the score by 100. Randomly generate a new food position, but\n        don't place it on the snake.\n        :return: None\n        >>> snake = Snake(100, 100, 1, (51, 51))\n        >>> snake.move((1,1))\n        >>> snake.eat_food()\n        self.length = 2\n        self.score = 10\n        \"\"\"",
                "test_class": "SnakeTestEatFood",
                "test_code": "class SnakeTestEatFood(unittest.TestCase):\n    def test_eat_food_1(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.score, 0)\n        snake.eat_food()\n        self.assertEqual(snake.length, 2)\n        self.assertEqual(snake.score, 100)\n\n    def test_eat_food_2(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.score, 0)\n        snake.eat_food()\n        snake.eat_food()\n        self.assertEqual(snake.length, 3)\n        self.assertEqual(snake.score, 200)\n\n    def test_eat_food_3(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.score, 0)\n        snake.eat_food()\n        snake.eat_food()\n        snake.eat_food()\n        self.assertEqual(snake.length, 4)\n        self.assertEqual(snake.score, 300)\n\n    def test_eat_food_4(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.score, 0)\n        snake.eat_food()\n        snake.eat_food()\n        snake.eat_food()\n        snake.eat_food()\n        self.assertEqual(snake.length, 5)\n        self.assertEqual(snake.score, 400)\n\n    def test_eat_food_5(self):\n        snake = Snake(100, 100, 1, (51, 51))\n        self.assertEqual(snake.length, 1)\n        self.assertEqual(snake.score, 0)\n        snake.eat_food()\n        snake.eat_food()\n        snake.eat_food()\n        snake.eat_food()\n        snake.eat_food()\n        self.assertEqual(snake.length, 6)\n        self.assertEqual(snake.score, 500)",
                "solution_code": "def eat_food(self):\n        self.length += 1\n        self.score += 100\n        self.random_food_position()",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.length",
                        "self.score"
                    ],
                    "method_dependencies": [
                        "random_food_position"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_78",
        "skeleton": "import re\n\nclass SplitSentence:\n    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text file to find the maximum word count.\n    \"\"\"\n\n\n    def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. Please note that Mr. also end with . but are not sentences.\n        :param sentences_string: string, string to split\n        :return:list, split sentence list\n        >>> ss = SplitSentence()\n        >>> ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\")\n        ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?']\n        \"\"\"\n\n    def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Note that words are separated by spaces and that punctuation marks and numbers are not counted as words.\n        :param sentence:string, sentence to be counted, where words are separated by spaces\n        :return:int, number of words in the sentence\n        >>> ss.count_words(\"abc def\")\n        2\n        \"\"\"\n\n    def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence\n        :param sentences_string: string, undivided long sentence\n        :return:int, the number of words in the longest sentence\n        >>> ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\")\n        4\n        \"\"\"",
        "test": "import unittest\n\n\nclass SplitSentenceTestSplitSentences(unittest.TestCase):\n    def test_split_sentences_1(self):\n        ss = SplitSentence()\n        lst = ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\")\n        self.assertEqual(lst, ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?'])\n\n    def test_split_sentences_2(self):\n        ss = SplitSentence()\n        lst = ss.split_sentences(\"Who is Mr. Smith? He is a teacher.\")\n        self.assertEqual(lst, ['Who is Mr. Smith?', 'He is a teacher.'])\n\n    def test_split_sentences_3(self):\n        ss = SplitSentence()\n        lst = ss.split_sentences(\"Who is A.B.C.? He is a teacher.\")\n        self.assertEqual(lst, ['Who is A.B.C.?', 'He is a teacher.'])\n\n    def test_split_sentences_4(self):\n        ss = SplitSentence()\n        lst = ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc.\")\n        self.assertEqual(lst, ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.'])\n\n    def test_split_sentences_5(self):\n        ss = SplitSentence()\n        lst = ss.split_sentences(\"aaa aaaa. bb bbbb bbb?\")\n        self.assertEqual(lst, ['aaa aaaa.', 'bb bbbb bbb?'])\n\n\nclass SplitSentenceTestCountWords(unittest.TestCase):\n    def test_count_words_1(self):\n        ss = SplitSentence()\n        cnt = ss.count_words(\"abc def\")\n        self.assertEqual(cnt, 2)\n\n    def test_count_words_2(self):\n        ss = SplitSentence()\n        cnt = ss.count_words(\"abc def 1\")\n        self.assertEqual(cnt, 2)\n\n    def test_count_words_3(self):\n        ss = SplitSentence()\n        cnt = ss.count_words(\"abc 1\")\n        self.assertEqual(cnt, 1)\n\n    def test_count_words_4(self):\n        ss = SplitSentence()\n        cnt = ss.count_words(\"abc def bbb1\")\n        self.assertEqual(cnt, 3)\n\n    def test_count_words_5(self):\n        ss = SplitSentence()\n        cnt = ss.count_words(\"abc def 111\")\n        self.assertEqual(cnt, 2)\n\n\nclass SplitSentenceTestProcessTextFile(unittest.TestCase):\n    def test_process_text_file_1(self):\n        ss = SplitSentence()\n        cnt = ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\")\n        self.assertEqual(cnt, 4)\n\n    def test_process_text_file_2(self):\n        ss = SplitSentence()\n        cnt = ss.process_text_file(\"Mr. Smith is a teacher. Yes.\")\n        self.assertEqual(cnt, 5)\n\n    def test_process_text_file_3(self):\n        ss = SplitSentence()\n        cnt = ss.process_text_file(\"Mr. Smith is a teacher. Yes 1 2 3 4 5 6.\")\n        self.assertEqual(cnt, 5)\n\n    def test_process_text_file_4(self):\n        ss = SplitSentence()\n        cnt = ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc.\")\n        self.assertEqual(cnt, 4)\n\n    def test_process_text_file_5(self):\n        ss = SplitSentence()\n        cnt = ss.process_text_file(\"aaa aaaa. bb bbbb bbb?\")\n        self.assertEqual(cnt, 3)\n\n\nclass SplitSentenceTest(unittest.TestCase):\n    def test_SplitSentence(self):\n        ss = SplitSentence()\n        lst = ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\")\n        self.assertEqual(lst, ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?'])\n\n        cnt = ss.count_words(\"abc def\")\n        self.assertEqual(cnt, 2)\n\n        cnt = ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\")\n        self.assertEqual(cnt, 4)",
        "solution_code": "import re\n\n\nclass SplitSentence:\n\n    def split_sentences(self, sentences_string):\n        sentences = re.split(r'(?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s', sentences_string)\n        return sentences\n\n    def count_words(self, sentence):\n        sentence = re.sub(r'[^a-zA-Z\\s]', '', sentence)\n        words = sentence.split()\n        return len(words)\n\n    def process_text_file(self, sentences_string):\n        sentences = self.split_sentences(sentences_string)\n        max_count = 0\n        for sentence in sentences:\n            count = self.count_words(sentence)\n            if count > max_count:\n                max_count = count\n\n        return max_count",
        "import_statement": [
            "import re"
        ],
        "class_description": "    \"\"\"\n    The class allows to split sentences, count words in a sentence, and process a text file to find the maximum word count.\n    \"\"\"\n",
        "class_name": "SplitSentence",
        "test_classes": [
            "SplitSentenceTestSplitSentences",
            "SplitSentenceTestCountWords",
            "SplitSentenceTestProcessTextFile",
            "SplitSentenceTest"
        ],
        "class_constructor": "class SplitSentence: \n",
        "fields": [],
        "methods_info": [
            {
                "method_name": "split_sentences",
                "method_description": "def split_sentences(self, sentences_string):\n        \"\"\"\n        Split a string into a list of sentences. Sentences end with . or ? and with a space after that. Please note that Mr. also end with . but are not sentences.\n        :param sentences_string: string, string to split\n        :return:list, split sentence list\n        >>> ss = SplitSentence()\n        >>> ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\")\n        ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?']\n        \"\"\"",
                "test_class": "SplitSentenceTestSplitSentences",
                "test_code": "class SplitSentenceTestSplitSentences(unittest.TestCase):\n    def test_split_sentences_1(self):\n        ss = SplitSentence()\n        lst = ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc. dd ddd?\")\n        self.assertEqual(lst, ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.', 'dd ddd?'])\n\n    def test_split_sentences_2(self):\n        ss = SplitSentence()\n        lst = ss.split_sentences(\"Who is Mr. Smith? He is a teacher.\")\n        self.assertEqual(lst, ['Who is Mr. Smith?', 'He is a teacher.'])\n\n    def test_split_sentences_3(self):\n        ss = SplitSentence()\n        lst = ss.split_sentences(\"Who is A.B.C.? He is a teacher.\")\n        self.assertEqual(lst, ['Who is A.B.C.?', 'He is a teacher.'])\n\n    def test_split_sentences_4(self):\n        ss = SplitSentence()\n        lst = ss.split_sentences(\"aaa aaaa. bb bbbb bbb? cccc cccc.\")\n        self.assertEqual(lst, ['aaa aaaa.', 'bb bbbb bbb?', 'cccc cccc.'])\n\n    def test_split_sentences_5(self):\n        ss = SplitSentence()\n        lst = ss.split_sentences(\"aaa aaaa. bb bbbb bbb?\")\n        self.assertEqual(lst, ['aaa aaaa.', 'bb bbbb bbb?'])",
                "solution_code": "def split_sentences(self, sentences_string):\n        sentences = re.split(r'(?<!\\w\\.\\w.)(?<![A-Z][a-z]\\.)(?<=\\.|\\?)\\s', sentences_string)\n        return sentences",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "re"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "count_words",
                "method_description": "def count_words(self, sentence):\n        \"\"\"\n        Count the number of words in a sentence. Note that words are separated by spaces and that punctuation marks and numbers are not counted as words.\n        :param sentence:string, sentence to be counted, where words are separated by spaces\n        :return:int, number of words in the sentence\n        >>> ss.count_words(\"abc def\")\n        2\n        \"\"\"",
                "test_class": "SplitSentenceTestCountWords",
                "test_code": "class SplitSentenceTestCountWords(unittest.TestCase):\n    def test_count_words_1(self):\n        ss = SplitSentence()\n        cnt = ss.count_words(\"abc def\")\n        self.assertEqual(cnt, 2)\n\n    def test_count_words_2(self):\n        ss = SplitSentence()\n        cnt = ss.count_words(\"abc def 1\")\n        self.assertEqual(cnt, 2)\n\n    def test_count_words_3(self):\n        ss = SplitSentence()\n        cnt = ss.count_words(\"abc 1\")\n        self.assertEqual(cnt, 1)\n\n    def test_count_words_4(self):\n        ss = SplitSentence()\n        cnt = ss.count_words(\"abc def bbb1\")\n        self.assertEqual(cnt, 3)\n\n    def test_count_words_5(self):\n        ss = SplitSentence()\n        cnt = ss.count_words(\"abc def 111\")\n        self.assertEqual(cnt, 2)",
                "solution_code": "def count_words(self, sentence):\n        sentence = re.sub(r'[^a-zA-Z\\s]', '', sentence)\n        words = sentence.split()\n        return len(words)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "re"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "process_text_file",
                "method_description": "def process_text_file(self, sentences_string):\n        \"\"\"\n        Given a text, return the number of words in the longest sentence\n        :param sentences_string: string, undivided long sentence\n        :return:int, the number of words in the longest sentence\n        >>> ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\")\n        4\n        \"\"\"",
                "test_class": "SplitSentenceTestProcessTextFile",
                "test_code": "class SplitSentenceTestProcessTextFile(unittest.TestCase):\n    def test_process_text_file_1(self):\n        ss = SplitSentence()\n        cnt = ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc. dd ddd?\")\n        self.assertEqual(cnt, 4)\n\n    def test_process_text_file_2(self):\n        ss = SplitSentence()\n        cnt = ss.process_text_file(\"Mr. Smith is a teacher. Yes.\")\n        self.assertEqual(cnt, 5)\n\n    def test_process_text_file_3(self):\n        ss = SplitSentence()\n        cnt = ss.process_text_file(\"Mr. Smith is a teacher. Yes 1 2 3 4 5 6.\")\n        self.assertEqual(cnt, 5)\n\n    def test_process_text_file_4(self):\n        ss = SplitSentence()\n        cnt = ss.process_text_file(\"aaa aaaa. bb bbbb bbb? cccc ccccccc cc ccc.\")\n        self.assertEqual(cnt, 4)\n\n    def test_process_text_file_5(self):\n        ss = SplitSentence()\n        cnt = ss.process_text_file(\"aaa aaaa. bb bbbb bbb?\")\n        self.assertEqual(cnt, 3)",
                "solution_code": "def process_text_file(self, sentences_string):\n        sentences = self.split_sentences(sentences_string)\n        max_count = 0\n        for sentence in sentences:\n            count = self.count_words(sentence)\n            if count > max_count:\n                max_count = count\n\n        return max_count",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "split_sentences",
                        "count_words"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_81",
        "skeleton": "import math\n\nclass Statistics3:\n    \"\"\"\n    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.\n    \"\"\"\n\n    @staticmethod\n    def median(data):\n        \"\"\"\n        calculates the median of the given list.\n        :param data: the given list, list.\n        :return: the median of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.median([1, 2, 3, 4])\n        2.5\n\n        \"\"\"\n\n    @staticmethod\n    def mode(data):\n        \"\"\"\n        calculates the mode of the given list.\n        :param data: the given list, list.\n        :return: the mode of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mode([1, 2, 3, 3])\n        [3]\n\n        \"\"\"\n\n    @staticmethod\n    def correlation(x, y):\n        \"\"\"\n        calculates the correlation of the given list.\n        :param x: the given list, list.\n        :param y: the given list, list.\n        :return: the correlation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation([1, 2, 3], [4, 5, 6])\n        1.0\n\n        \"\"\"\n\n    @staticmethod\n    def mean(data):\n        \"\"\"\n        calculates the mean of the given list.\n        :param data: the given list, list.\n        :return: the mean of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mean([1, 2, 3])\n        2.0\n\n        \"\"\"\n\n    @staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        calculates the correlation matrix of the given list.\n        :param data: the given list, list.\n        :return: the correlation matrix of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n\n        \"\"\"\n\n    @staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        calculates the standard deviation of the given list.\n        :param data: the given list, list.\n        :return: the standard deviation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.standard_deviation([1, 2, 3])\n        1.0\n\n        \"\"\"\n\n    @staticmethod\n    def z_score(data):\n        \"\"\"\n        calculates the z-score of the given list.\n        :param data: the given list, list.\n        :return: the z-score of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.z_score([1, 2, 3, 4])\n        [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225]\n\n        \"\"\"",
        "test": "import unittest\n\nclass Statistics3TestMedian(unittest.TestCase):\n    def test_median(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4]), 2.5)\n\n    def test_median_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5]), 3)\n\n    def test_median_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5, 6]), 3.5)\n\n    def test_median_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5, 6, 7]), 4)\n\n    def test_median_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5, 6, 7, 8]), 4.5)\n\nclass Statistics3TestMode(unittest.TestCase):\n    def test_mode(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3]), [3])\n\n    def test_mode_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4]), [3, 4])\n\n    def test_mode_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4, 5]), [3, 4])\n\n    def test_mode_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4, 5, 5]), [3, 4, 5])\n\n    def test_mode_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4, 5, 5, 6]), [3, 4, 5])\n\nclass Statistics3TestCorrelation(unittest.TestCase):\n    def test_correlation(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 2, 3], [4, 5, 6]), 1.0)\n\n    def test_correlation_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 2, 3, 4], [5, 6, 7, 8]), 1.0)\n\n    def test_correlation_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 2, 3], [1,2,3]), 1.0)\n\n    def test_correlation_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 1,1], [2,2,2]), None)\n\n    def test_correlation_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 1,1], [1,1,1]), None)\n\nclass Statistics3TestMean(unittest.TestCase):\n    def test_mean(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 2, 3]), 2.0)\n\n    def test_mean_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([]), None)\n\n    def test_mean_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 1, 1]), 1.0)\n\n    def test_mean_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 1, 1, 1]), 1.0)\n\n    def test_mean_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 1, 1, 1, 1]), 1.0)\n\nclass Statistics3TestCorrelationMatrix(unittest.TestCase):\n    def test_correlation_matrix(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\n    def test_correlation_matrix_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\n    def test_correlation_matrix_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3]]), [[None, None, None], [None, None, None], [None, None, None]])\n\n    def test_correlation_matrix_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11,12]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\n    def test_correlation_matrix_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11,12], [13, 14, 15]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\nclass Statistics3TestStandardDeviation(unittest.TestCase):\n    def test_standard_deviation(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 2, 3]), 1.0)\n\n    def test_standard_deviation_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1, 1]), 0.0)\n\n    def test_standard_deviation_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1]), 0.0)\n\n    def test_standard_deviation_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1, 1, 1]), 0.0)\n\n    def test_standard_deviation_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1, 2, 1, 4]), 1.3038404810405297)\n\n\nclass Statistics3TestZScore(unittest.TestCase):\n    def test_z_score(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 2, 3, 4]), [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225])\n\n    def test_z_score_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 1, 1, 1]), None)\n\n    def test_z_score_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1]),None)\n\n    def test_z_score_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 1, 2, 3]), [-0.7833494518006403,-0.7833494518006403,0.26111648393354675,1.3055824196677337])\n\n    def test_z_score_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 1, 1, 1, 1]), None)\n\n\nclass Statistics3TestMain(unittest.TestCase):\n    def test_main(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4]), 2.5)\n        self.assertEqual(statistics3.mode([1, 2, 3, 3]), [3])\n        self.assertEqual(statistics3.correlation([1, 2, 3], [4, 5, 6]), 1.0)\n        self.assertEqual(statistics3.mean([1, 2, 3]), 2.0)\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n        self.assertEqual(statistics3.standard_deviation([1, 2, 3]), 1.0)\n        self.assertEqual(statistics3.z_score([1, 2, 3, 4]), [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225])",
        "solution_code": "import math\nclass Statistics3:\n    @staticmethod\n    def median(data):\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 1:\n            return sorted_data[n // 2]\n        else:\n            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2\n\n    @staticmethod\n    def mode(data):\n        counts = {}\n        for value in data:\n            counts[value] = counts.get(value, 0) + 1\n        max_count = max(counts.values())\n        mode_values = [value for value, count in counts.items() if count == max_count]\n        return mode_values\n\n    @staticmethod\n    def correlation(x, y):\n        n = len(x)\n        mean_x = sum(x) / n\n        mean_y = sum(y) / n\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))\n        if denominator == 0:\n            return None\n        return numerator / denominator\n\n    @staticmethod\n    def mean(data):\n        if len(data) == 0:\n            return None\n        return sum(data) / len(data)\n\n    @staticmethod\n    def correlation_matrix(data):\n        matrix = []\n        for i in range(len(data[0])):\n            row = []\n            for j in range(len(data[0])):\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                correlation = Statistics3.correlation(column1, column2)\n                row.append(correlation)\n            matrix.append(row)\n        return matrix\n\n    @staticmethod\n    def standard_deviation(data):\n        n = len(data)\n        if n < 2:\n            return None\n        mean_value = Statistics3.mean(data)\n        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)\n        return math.sqrt(variance)\n\n    @staticmethod\n    def z_score(data):\n        mean = Statistics3.mean(data)\n        std_deviation = Statistics3.standard_deviation(data)\n        if std_deviation is None or std_deviation == 0:\n            return None\n        return [(x - mean) / std_deviation for x in data]",
        "import_statement": [
            "import math"
        ],
        "class_description": "    \"\"\"\n    This is a class that implements methods for calculating indicators such as median, mode, correlation matrix, and Z-score in statistics.\n    \"\"\"\n",
        "class_name": "Statistics3",
        "test_classes": [
            "Statistics3TestMedian",
            "Statistics3TestMode",
            "Statistics3TestCorrelation",
            "Statistics3TestMean",
            "Statistics3TestCorrelationMatrix",
            "Statistics3TestStandardDeviation",
            "Statistics3TestZScore",
            "Statistics3TestMain"
        ],
        "class_constructor": "class Statistics3: \n",
        "fields": [],
        "methods_info": [
            {
                "method_name": "median",
                "method_description": "def median(data):\n        \"\"\"\n        calculates the median of the given list.\n        :param data: the given list, list.\n        :return: the median of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.median([1, 2, 3, 4])\n        2.5\n\n        \"\"\"",
                "test_class": "Statistics3TestMedian",
                "test_code": "class Statistics3TestMedian(unittest.TestCase):\n    def test_median(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4]), 2.5)\n\n    def test_median_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5]), 3)\n\n    def test_median_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5, 6]), 3.5)\n\n    def test_median_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5, 6, 7]), 4)\n\n    def test_median_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.median([1, 2, 3, 4, 5, 6, 7, 8]), 4.5)",
                "solution_code": "def median(data):\n        sorted_data = sorted(data)\n        n = len(sorted_data)\n        if n % 2 == 1:\n            return sorted_data[n // 2]\n        else:\n            return (sorted_data[n // 2 - 1] + sorted_data[n // 2]) / 2",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "mode",
                "method_description": "@staticmethod\n    def mode(data):\n        \"\"\"\n        calculates the mode of the given list.\n        :param data: the given list, list.\n        :return: the mode of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mode([1, 2, 3, 3])\n        [3]\n\n        \"\"\"",
                "test_class": "Statistics3TestMode",
                "test_code": "class Statistics3TestMode(unittest.TestCase):\n    def test_mode(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3]), [3])\n\n    def test_mode_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4]), [3, 4])\n\n    def test_mode_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4, 5]), [3, 4])\n\n    def test_mode_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4, 5, 5]), [3, 4, 5])\n\n    def test_mode_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mode([1, 2, 3, 3, 4, 4, 5, 5, 6]), [3, 4, 5])",
                "solution_code": "@staticmethod\n    def mode(data):\n        counts = {}\n        for value in data:\n            counts[value] = counts.get(value, 0) + 1\n        max_count = max(counts.values())\n        mode_values = [value for value, count in counts.items() if count == max_count]\n        return mode_values",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "correlation",
                "method_description": "@staticmethod\n    def correlation(x, y):\n        \"\"\"\n        calculates the correlation of the given list.\n        :param x: the given list, list.\n        :param y: the given list, list.\n        :return: the correlation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation([1, 2, 3], [4, 5, 6])\n        1.0\n\n        \"\"\"",
                "test_class": "Statistics3TestCorrelation",
                "test_code": "class Statistics3TestCorrelation(unittest.TestCase):\n    def test_correlation(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 2, 3], [4, 5, 6]), 1.0)\n\n    def test_correlation_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 2, 3, 4], [5, 6, 7, 8]), 1.0)\n\n    def test_correlation_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 2, 3], [1,2,3]), 1.0)\n\n    def test_correlation_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 1,1], [2,2,2]), None)\n\n    def test_correlation_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation([1, 1,1], [1,1,1]), None)",
                "solution_code": "@staticmethod\n    def correlation(x, y):\n        n = len(x)\n        mean_x = sum(x) / n\n        mean_y = sum(y) / n\n        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))\n        denominator = math.sqrt(sum((xi - mean_x) ** 2 for xi in x) * sum((yi - mean_y) ** 2 for yi in y))\n        if denominator == 0:\n            return None\n        return numerator / denominator",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "math"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "mean"
                    ]
                }
            },
            {
                "method_name": "mean",
                "method_description": "@staticmethod\n    def mean(data):\n        \"\"\"\n        calculates the mean of the given list.\n        :param data: the given list, list.\n        :return: the mean of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.mean([1, 2, 3])\n        2.0\n\n        \"\"\"",
                "test_class": "Statistics3TestMean",
                "test_code": "class Statistics3TestMean(unittest.TestCase):\n    def test_mean(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 2, 3]), 2.0)\n\n    def test_mean_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([]), None)\n\n    def test_mean_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 1, 1]), 1.0)\n\n    def test_mean_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 1, 1, 1]), 1.0)\n\n    def test_mean_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.mean([1, 1, 1, 1, 1]), 1.0)",
                "solution_code": "@staticmethod\n    def mean(data):\n        if len(data) == 0:\n            return None\n        return sum(data) / len(data)",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "correlation_matrix",
                "method_description": "@staticmethod\n    def correlation_matrix(data):\n        \"\"\"\n        calculates the correlation matrix of the given list.\n        :param data: the given list, list.\n        :return: the correlation matrix of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\n        [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]]\n\n        \"\"\"",
                "test_class": "Statistics3TestCorrelationMatrix",
                "test_code": "class Statistics3TestCorrelationMatrix(unittest.TestCase):\n    def test_correlation_matrix(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\n    def test_correlation_matrix_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\n    def test_correlation_matrix_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3]]), [[None, None, None], [None, None, None], [None, None, None]])\n\n    def test_correlation_matrix_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11,12]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])\n\n    def test_correlation_matrix_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.correlation_matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11,12], [13, 14, 15]]), [[1.0, 1.0, 1.0], [1.0, 1.0, 1.0], [1.0, 1.0, 1.0]])",
                "solution_code": "@staticmethod\n    def correlation_matrix(data):\n        matrix = []\n        for i in range(len(data[0])):\n            row = []\n            for j in range(len(data[0])):\n                column1 = [row[i] for row in data]\n                column2 = [row[j] for row in data]\n                correlation = Statistics3.correlation(column1, column2)\n                row.append(correlation)\n            matrix.append(row)\n        return matrix",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "correlation"
                    ]
                }
            },
            {
                "method_name": "standard_deviation",
                "method_description": "@staticmethod\n    def standard_deviation(data):\n        \"\"\"\n        calculates the standard deviation of the given list.\n        :param data: the given list, list.\n        :return: the standard deviation of the given list, float.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.standard_deviation([1, 2, 3])\n        1.0\n\n        \"\"\"",
                "test_class": "Statistics3TestStandardDeviation",
                "test_code": "class Statistics3TestStandardDeviation(unittest.TestCase):\n    def test_standard_deviation(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 2, 3]), 1.0)\n\n    def test_standard_deviation_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1, 1]), 0.0)\n\n    def test_standard_deviation_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1]), 0.0)\n\n    def test_standard_deviation_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1, 1, 1]), 0.0)\n\n    def test_standard_deviation_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.standard_deviation([1, 1, 2, 1, 4]), 1.3038404810405297)",
                "solution_code": "@staticmethod\n    def standard_deviation(data):\n        n = len(data)\n        if n < 2:\n            return None\n        mean_value = Statistics3.mean(data)\n        variance = sum((x - mean_value) ** 2 for x in data) / (n - 1)\n        return math.sqrt(variance)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "math"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "mean"
                    ]
                }
            },
            {
                "method_name": "z_score",
                "method_description": "@staticmethod\n    def z_score(data):\n        \"\"\"\n        calculates the z-score of the given list.\n        :param data: the given list, list.\n        :return: the z-score of the given list, list.\n        >>> statistics3 = Statistics3()\n        >>> statistics3.z_score([1, 2, 3, 4])\n        [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225]\n\n        \"\"\"",
                "test_class": "Statistics3TestZScore",
                "test_code": "class Statistics3TestZScore(unittest.TestCase):\n    def test_z_score(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 2, 3, 4]), [-1.161895003862225, -0.3872983346207417, 0.3872983346207417, 1.161895003862225])\n\n    def test_z_score_2(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 1, 1, 1]), None)\n\n    def test_z_score_3(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1]),None)\n\n    def test_z_score_4(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 1, 2, 3]), [-0.7833494518006403,-0.7833494518006403,0.26111648393354675,1.3055824196677337])\n\n    def test_z_score_5(self):\n        statistics3 = Statistics3()\n        self.assertEqual(statistics3.z_score([1, 1, 1, 1, 1]), None)",
                "solution_code": "@staticmethod\n    def z_score(data):\n        mean = Statistics3.mean(data)\n        std_deviation = Statistics3.standard_deviation(data)\n        if std_deviation is None or std_deviation == 0:\n            return None\n        return [(x - mean) / std_deviation for x in data]",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "mean",
                        "standard_deviation"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_83",
        "skeleton": "import sqlite3\n\nclass StudentDatabaseProcessor:\n    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n\n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n    def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        \"\"\"\n\n    def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        \"\"\"\n\n    def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> result = processor.search_student_by_name(\"John\")\n        \"\"\"\n\n    def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> processor.delete_student_by_name(\"John\")\n        \"\"\"",
        "test": "import unittest\n\n\nclass StudentDatabaseProcessorTestInsertStudent(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_insert_student_1(self):\n        student_data = {\n            'name': 'Alice',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Alice',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_insert_student_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('aaa',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_insert_student_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('bbb',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'bbb')\n\n    def test_insert_student_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ccc',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ccc')\n\n    def test_insert_student_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ddd',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ddd')\n\n\nclass StudentDatabaseProcessorTestSearchStudentByName(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_search_student_by_name_1(self):\n        student_data = {\n            'name': 'Bob',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('Bob')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Bob')\n\n    def test_search_student_by_name_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('aaa')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_search_student_by_name_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('bbb')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'bbb')\n\n    def test_search_student_by_name_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('ccc')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ccc')\n\n    def test_search_student_by_name_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('ddd')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ddd')\n\n\nclass StudentDatabaseProcessorTestDeleteStudentByName(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_delete_student_by_name_1(self):\n        student_data = {\n            'name': 'Charlie',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('Charlie')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Charlie',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('aaa')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('aaa',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('bbb')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('bbb',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('ccc')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ccc',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('ddd')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ddd',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n\nclass StudentDatabaseProcessorTest(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_StudentDatabaseProcessor(self):\n        student_data = {\n            'name': 'Alice',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Alice',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n        student_data = {\n            'name': 'Bob',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('Bob')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Bob')\n\n        student_data = {\n            'name': 'Charlie',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('Charlie')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Charlie',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)",
        "solution_code": "import sqlite3\n\n\nclass StudentDatabaseProcessor:\n\n    def __init__(self, database_name):\n        self.database_name = database_name\n\n    def create_student_table(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()\n\n    def insert_student(self, student_data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        cursor.execute(insert_query,\n                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n\n        conn.commit()\n        conn.close()\n\n    def search_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        select_query = \"SELECT * FROM students WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n\n        conn.close()\n\n        return result\n\n    def delete_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        delete_query = \"DELETE FROM students WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        conn.commit()\n        conn.close()",
        "import_statement": [
            "import sqlite3"
        ],
        "class_description": "    \"\"\"\n    This is a class with database operation, including inserting student information, searching for student information by name, and deleting student information by name.\n    \"\"\"\n",
        "class_name": "StudentDatabaseProcessor",
        "test_classes": [
            "StudentDatabaseProcessorTestInsertStudent",
            "StudentDatabaseProcessorTestSearchStudentByName",
            "StudentDatabaseProcessorTestDeleteStudentByName",
            "StudentDatabaseProcessorTest"
        ],
        "class_constructor": "class StudentDatabaseProcessor: \n    def __init__(self, database_name):\n        \"\"\"\n        Initializes the StudentDatabaseProcessor object with the specified database name.\n        :param database_name: str, the name of the SQLite database.\n        \"\"\"\n        self.database_name = database_name\n\n",
        "fields": [
            "self.database_name"
        ],
        "methods_info": [
            {
                "method_name": "create_student_table",
                "method_description": "def create_student_table(self):\n        \"\"\"\n        Creates a \"students\" table in the database if it does not exist already.Fields include ID of type int, name of type str, age of type int, gender of type str, and grade of type int\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        \"\"\"",
                "test_class": "StudentDatabaseProcessorTestInsertStudent",
                "test_code": "class StudentDatabaseProcessorTestInsertStudent(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_insert_student_1(self):\n        student_data = {\n            'name': 'Alice',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Alice',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n    def test_insert_student_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('aaa',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_insert_student_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('bbb',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'bbb')\n\n    def test_insert_student_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ccc',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ccc')\n\n    def test_insert_student_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ddd',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ddd')",
                "solution_code": "def create_student_table(self):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        create_table_query = \"\"\"\n        CREATE TABLE IF NOT EXISTS students (\n            id INTEGER PRIMARY KEY,\n            name TEXT,\n            age INTEGER,\n            gender TEXT,\n            grade INTEGER\n        )\n        \"\"\"\n        cursor.execute(create_table_query)\n\n        conn.commit()\n        conn.close()",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "sqlite3"
                    ],
                    "field_dependencies": [
                        "self.database_name"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "insert_student",
                "method_description": "def insert_student(self, student_data):\n        \"\"\"\n        Inserts a new student into the \"students\" table.\n        :param student_data: dict, a dictionary containing the student's information (name, age, gender, grade).\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        \"\"\"",
                "test_class": "StudentDatabaseProcessorTestSearchStudentByName",
                "test_code": "class StudentDatabaseProcessorTestSearchStudentByName(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_search_student_by_name_1(self):\n        student_data = {\n            'name': 'Bob',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('Bob')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Bob')\n\n    def test_search_student_by_name_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('aaa')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'aaa')\n\n    def test_search_student_by_name_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('bbb')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'bbb')\n\n    def test_search_student_by_name_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('ccc')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ccc')\n\n    def test_search_student_by_name_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('ddd')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'ddd')",
                "solution_code": "def insert_student(self, student_data):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        insert_query = \"\"\"\n        INSERT INTO students (name, age, gender, grade)\n        VALUES (?, ?, ?, ?)\n        \"\"\"\n        cursor.execute(insert_query,\n                       (student_data['name'], student_data['age'], student_data['gender'], student_data['grade']))\n\n        conn.commit()\n        conn.close()",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "sqlite3"
                    ],
                    "field_dependencies": [
                        "self.database_name"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "search_student_by_name",
                "method_description": "def search_student_by_name(self, name):\n        \"\"\"\n        Searches for a student in the \"students\" table by their name.\n        :param name: str, the name of the student to search for.\n        :return: list of tuples, the rows from the \"students\" table that match the search criteria.\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> result = processor.search_student_by_name(\"John\")\n        \"\"\"",
                "test_class": "StudentDatabaseProcessorTestDeleteStudentByName",
                "test_code": "class StudentDatabaseProcessorTestDeleteStudentByName(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_delete_student_by_name_1(self):\n        student_data = {\n            'name': 'Charlie',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('Charlie')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Charlie',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_2(self):\n        student_data = {\n            'name': 'aaa',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('aaa')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('aaa',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_3(self):\n        student_data = {\n            'name': 'bbb',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('bbb')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('bbb',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_4(self):\n        student_data = {\n            'name': 'ccc',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('ccc')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ccc',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)\n\n    def test_delete_student_by_name_5(self):\n        student_data = {\n            'name': 'ddd',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('ddd')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('ddd',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)",
                "solution_code": "def search_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        select_query = \"SELECT * FROM students WHERE name = ?\"\n        cursor.execute(select_query, (name,))\n        result = cursor.fetchall()\n\n        conn.close()\n\n        return result",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "sqlite3"
                    ],
                    "field_dependencies": [
                        "self.database_name"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "delete_student_by_name",
                "method_description": "def delete_student_by_name(self, name):\n        \"\"\"\n        Deletes a student from the \"students\" table by their name.\n        :param name: str, the name of the student to delete.\n        :return: None\n        >>> processor = StudentDatabaseProcessor(\"students.db\")\n        >>> processor.create_student_table()\n        >>> student_data = {'name': 'John', 'age': 15, 'gender': 'Male', 'grade': 9}\n        >>> processor.insert_student(student_data)\n        >>> processor.delete_student_by_name(\"John\")\n        \"\"\"",
                "test_class": "StudentDatabaseProcessorTest",
                "test_code": "class StudentDatabaseProcessorTest(unittest.TestCase):\n    def setUp(self):\n        self.processor = StudentDatabaseProcessor(\"test_database.db\")\n        self.processor.create_student_table()\n\n    def tearDown(self):\n        conn = sqlite3.connect(\"test_database.db\")\n        conn.execute(\"DROP TABLE IF EXISTS students\")\n        conn.commit()\n        conn.close()\n\n    def test_StudentDatabaseProcessor(self):\n        student_data = {\n            'name': 'Alice',\n            'age': 20,\n            'gender': 'female',\n            'grade': 90\n        }\n        self.processor.insert_student(student_data)\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Alice',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Alice')\n\n        student_data = {\n            'name': 'Bob',\n            'age': 19,\n            'gender': 'male',\n            'grade': 85\n        }\n        self.processor.insert_student(student_data)\n\n        result = self.processor.search_student_by_name('Bob')\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(result[0][1], 'Bob')\n\n        student_data = {\n            'name': 'Charlie',\n            'age': 18,\n            'gender': 'male',\n            'grade': 95\n        }\n        self.processor.insert_student(student_data)\n\n        self.processor.delete_student_by_name('Charlie')\n\n        conn = sqlite3.connect(\"test_database.db\")\n        cursor = conn.cursor()\n        cursor.execute(\"SELECT * FROM students WHERE name=?\", ('Charlie',))\n        result = cursor.fetchall()\n        conn.close()\n\n        self.assertEqual(len(result), 0)",
                "solution_code": "def delete_student_by_name(self, name):\n        conn = sqlite3.connect(self.database_name)\n        cursor = conn.cursor()\n\n        delete_query = \"DELETE FROM students WHERE name = ?\"\n        cursor.execute(delete_query, (name,))\n\n        conn.commit()\n        conn.close()",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "sqlite3"
                    ],
                    "field_dependencies": [
                        "self.database_name"
                    ],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_84",
        "skeleton": "import json\n\nclass TextFileProcessor:\n    \"\"\"\n    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n\n    def __init__(self, file_path):\n        \"\"\"\n        Initialize the file path.\n        :param file_path: str\n        \"\"\"\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        \"\"\"\n        Read the self.file_path file as json format.\n        if the file content doesn't obey json format, the code will raise error.\n        :return data: dict if the file is stored as json format, or str/int/float.. according to the file content otherwise.\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file_as_json()\n        {'name': 'test', 'age': 12}\n        >>> type(textFileProcessor.read_file_as_json())\n        <class 'dict'>\n        \"\"\"\n\n    def read_file(self):\n        \"\"\"\n        Read the return the content of self.file_path file.\n        :return: the same return as the read() method\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\\n    \"name\": \"test\",\\n    \"age\": 12\\n}'\n        \"\"\"\n\n    def write_file(self, content):\n        \"\"\"\n        Write content into the self.file_path file, and overwrite if the file has already existed.\n        :param content: any content\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.write_file('Hello world!')\n        >>> textFileProcessor.read_file()\n        'Hello world!'\n        \"\"\"\n\n    def process_file(self):\n        \"\"\"\n        Read the self.file_path file and filter out non-alphabetic characters from the content string.\n        Overwrite the after-processed data into the same self.file_path file.\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\\n    \"name\": \"test\",\\n    \"age\": 12\\n}'\n        >>> textFileProcessor.process_file()\n        'nametestage'\n        \"\"\"",
        "test": "import unittest\nimport json\nfrom unittest.mock import MagicMock\nimport os\n\n\nclass TextFileProcessorTestReadFileAsJson(unittest.TestCase):\n    def setUp(self):\n        self.files = ['test_1.txt', 'test_2.txt', 'test_3.txt', 'test_4.txt', 'test_5.txt']\n        self.contents = ['{\\n    \"name\": \"test\",\\n    \"age\": 12\\n}', '12345', '\\\"hello\\\"', '\\\"aaa\\\"', '\\\"bbb\\\"']\n        for index, file in enumerate(self.files):\n            with open(file, 'w') as f:\n                f.write(self.contents[index])\n\n    # the dict type\n    def test_read_file_as_json_1(self):\n        textFileProcessor = TextFileProcessor(self.files[0])\n        data = textFileProcessor.read_file_as_json()\n        expected = {\"name\": \"test\", \"age\": 12}\n        self.assertEqual(dict, type(data))\n        self.assertEqual(expected, data)\n\n    # the int type\n    def test_read_file_as_json_2(self):\n        textFileProcessor = TextFileProcessor(self.files[1])\n        data = textFileProcessor.read_file_as_json()\n        expected = 12345\n        self.assertEqual(int, type(data))\n        self.assertEqual(expected, data)\n\n    # the str type\n    def test_read_file_as_json_3(self):\n        textFileProcessor = TextFileProcessor(self.files[2])\n        data = textFileProcessor.read_file_as_json()\n        expected = 'hello'\n        self.assertEqual(str, type(data))\n        self.assertEqual(expected, data)\n\n    def test_read_file_as_json_4(self):\n        textFileProcessor = TextFileProcessor(self.files[3])\n        data = textFileProcessor.read_file_as_json()\n        expected = 'aaa'\n        self.assertEqual(str, type(data))\n        self.assertEqual(expected, data)\n\n    def test_read_file_as_json_5(self):\n        textFileProcessor = TextFileProcessor(self.files[4])\n        data = textFileProcessor.read_file_as_json()\n        expected = 'bbb'\n        self.assertEqual(str, type(data))\n        self.assertEqual(expected, data)\n\n\nclass TextFileProcessorTestReadFile(unittest.TestCase):\n    def setUp(self) -> None:\n        self.files = ['test_1.txt', 'test_2.txt', 'test_3.txt', 'test_4.txt', 'test_5.txt']\n        self.contents = ['123aac\\n&^(*&43)', '12345', 'aaa', 'bbb', 'ccc']\n        for index, file in enumerate(self.files):\n            with open(file, 'w') as f:\n                f.write(self.contents[index])\n\n    def test_read_file_1(self):\n        textFileProcessor = TextFileProcessor(self.files[0])\n        data = textFileProcessor.read_file()\n        self.assertEqual(str, type(data))\n        self.assertEqual(data, self.contents[0])\n\n    def test_read_file_2(self):\n        textFileProcessor = TextFileProcessor(self.files[1])\n        data = textFileProcessor.read_file()\n        self.assertEqual(str, type(data))\n        self.assertEqual(data, self.contents[1])\n\n    def test_read_file_3(self):\n        textFileProcessor = TextFileProcessor(self.files[2])\n        data = textFileProcessor.read_file()\n        self.assertEqual(str, type(data))\n        self.assertEqual(data, self.contents[2])\n\n    def test_read_file_4(self):\n        textFileProcessor = TextFileProcessor(self.files[3])\n        data = textFileProcessor.read_file()\n        self.assertEqual(str, type(data))\n        self.assertEqual(data, self.contents[3])\n\n    def test_read_file_5(self):\n        textFileProcessor = TextFileProcessor(self.files[4])\n        data = textFileProcessor.read_file()\n        self.assertEqual(str, type(data))\n        self.assertEqual(data, self.contents[4])\n\n\nclass TextFileProcessorTestWriteFile(unittest.TestCase):\n    def setUp(self) -> None:\n        self.files = ['test_1.txt', 'test_2.txt', 'test_3.txt', 'test_4.txt', 'test_5.txt']\n        self.contents = ['123aac\\n&^(*&43)', '12345', 'aaa', 'bbb', 'ccc']\n\n    def tearDown(self) -> None:\n        for file in self.files:\n            if os.path.exists(file):\n                os.remove(file)\n\n    def test_write_file_1(self):\n        textFileProcessor = TextFileProcessor(self.files[0])\n        textFileProcessor.write_file(self.contents[0])\n        with open(self.files[0], 'r') as f:\n            data = f.read()\n        self.assertEqual(data, self.contents[0])\n\n    def test_write_file_2(self):\n        textFileProcessor = TextFileProcessor(self.files[1])\n        textFileProcessor.write_file(self.contents[1])\n        with open(self.files[1], 'r') as f:\n            data = f.read()\n        self.assertEqual(data, self.contents[1])\n\n    def test_write_file_3(self):\n        textFileProcessor = TextFileProcessor(self.files[2])\n        textFileProcessor.write_file(self.contents[2])\n        with open(self.files[2], 'r') as f:\n            data = f.read()\n        self.assertEqual(data, self.contents[2])\n\n    def test_write_file_4(self):\n        textFileProcessor = TextFileProcessor(self.files[3])\n        textFileProcessor.write_file(self.contents[3])\n        with open(self.files[3], 'r') as f:\n            data = f.read()\n        self.assertEqual(data, self.contents[3])\n\n    def test_write_file_5(self):\n        textFileProcessor = TextFileProcessor(self.files[4])\n        textFileProcessor.write_file(self.contents[4])\n        with open(self.files[4], 'r') as f:\n            data = f.read()\n        self.assertEqual(data, self.contents[4])\n\n\nclass TextFileProcessorTestProcessFile(unittest.TestCase):\n    def test_process_file_1(self):\n        self.file = 'test.txt'\n        self.content = 'Hello, 123 World!'\n        self.expected_result = 'HelloWorld'\n\n        textFileProcessor = TextFileProcessor(self.file)\n        textFileProcessor.read_file = MagicMock(return_value=self.content)\n        textFileProcessor.write_file = MagicMock()\n\n        result = textFileProcessor.process_file()\n        self.assertEqual(result, self.expected_result)\n        textFileProcessor.read_file.assert_called_once()\n        textFileProcessor.write_file.assert_called_once_with(self.expected_result)\n\n    def test_process_file_2(self):\n        self.file = 'test.txt'\n        self.content = 'Hello, abc World!'\n        self.expected_result = 'HelloabcWorld'\n\n        textFileProcessor = TextFileProcessor(self.file)\n        textFileProcessor.read_file = MagicMock(return_value=self.content)\n        textFileProcessor.write_file = MagicMock()\n\n        result = textFileProcessor.process_file()\n        self.assertEqual(result, self.expected_result)\n        textFileProcessor.read_file.assert_called_once()\n        textFileProcessor.write_file.assert_called_once_with(self.expected_result)\n\n    def test_process_file_3(self):\n        self.file = 'test.txt'\n        self.content = ', 123 !'\n        self.expected_result = ''\n\n        textFileProcessor = TextFileProcessor(self.file)\n        textFileProcessor.read_file = MagicMock(return_value=self.content)\n        textFileProcessor.write_file = MagicMock()\n\n        result = textFileProcessor.process_file()\n        self.assertEqual(result, self.expected_result)\n        textFileProcessor.read_file.assert_called_once()\n        textFileProcessor.write_file.assert_called_once_with(self.expected_result)\n\n    def test_process_file_4(self):\n        self.file = 'test.txt'\n        self.content = 'Hello, World!'\n        self.expected_result = 'HelloWorld'\n\n        textFileProcessor = TextFileProcessor(self.file)\n        textFileProcessor.read_file = MagicMock(return_value=self.content)\n        textFileProcessor.write_file = MagicMock()\n\n        result = textFileProcessor.process_file()\n        self.assertEqual(result, self.expected_result)\n        textFileProcessor.read_file.assert_called_once()\n        textFileProcessor.write_file.assert_called_once_with(self.expected_result)\n\n    def test_process_file_5(self):\n        self.file = 'test.txt'\n        self.content = 'Hello, 123a World!'\n        self.expected_result = 'HelloaWorld'\n\n        textFileProcessor = TextFileProcessor(self.file)\n        textFileProcessor.read_file = MagicMock(return_value=self.content)\n        textFileProcessor.write_file = MagicMock()\n\n        result = textFileProcessor.process_file()\n        self.assertEqual(result, self.expected_result)\n        textFileProcessor.read_file.assert_called_once()\n        textFileProcessor.write_file.assert_called_once_with(self.expected_result)\n\n\nclass TextFileProcessorTestMain(unittest.TestCase):\n    def setUp(self) -> None:\n        self.file = 'test.txt'\n        self.content = '{\\n    \"name\": \"test\",\\n    \"age\": 12\\n}'\n        with open(self.file, 'w') as f:\n            f.write(self.content)\n\n    def test_main(self):\n        textFileProcessor = TextFileProcessor(self.file)\n        data1 = textFileProcessor.read_file_as_json()\n        expected1 = {\"name\": \"test\", \"age\": 12}\n        self.assertEqual(dict, type(data1))\n        self.assertEqual(expected1, data1)\n\n        textFileProcessor.write_file(self.content)\n        data2 = textFileProcessor.read_file()\n        self.assertEqual(str, type(data2))\n        self.assertEqual(self.content, data2)\n\n        data3 = textFileProcessor.process_file()\n        self.assertEqual(str, type(data3))\n        expected2 = 'nametestage'\n        self.assertEqual(expected2, data3)",
        "solution_code": "import json\n\n\nclass TextFileProcessor:\n    def __init__(self, file_path):\n        self.file_path = file_path\n\n    def read_file_as_json(self):\n        with open(self.file_path, 'r') as file:\n            data = json.load(file)\n\n        return data\n\n    def read_file(self):\n        with open(self.file_path, 'r') as file:\n            return file.read()\n\n    def write_file(self, content):\n        with open(self.file_path, 'w') as file:\n            file.write(content)\n\n    def process_file(self):\n        content = self.read_file()\n        content = ''.join([char for char in content if char.isalpha()])\n        self.write_file(content)\n        return content",
        "import_statement": [
            "import json"
        ],
        "class_description": "    \"\"\"\n    The class handles reading, writing, and processing text files. It can read the file as JSON, read the raw text, write content to the file, and process the file by removing non-alphabetic characters.\n    \"\"\"\n",
        "class_name": "TextFileProcessor",
        "test_classes": [
            "TextFileProcessorTestReadFileAsJson",
            "TextFileProcessorTestReadFile",
            "TextFileProcessorTestWriteFile",
            "TextFileProcessorTestProcessFile",
            "TextFileProcessorTestMain"
        ],
        "class_constructor": "class TextFileProcessor: \n    def __init__(self, file_path):\n        \"\"\"\n        Initialize the file path.\n        :param file_path: str\n        \"\"\"\n        self.file_path = file_path\n\n",
        "fields": [
            "self.file_path"
        ],
        "methods_info": [
            {
                "method_name": "read_file_as_json",
                "method_description": "def read_file_as_json(self):\n        \"\"\"\n        Read the self.file_path file as json format.\n        if the file content doesn't obey json format, the code will raise error.\n        :return data: dict if the file is stored as json format, or str/int/float.. according to the file content otherwise.\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file_as_json()\n        {'name': 'test', 'age': 12}\n        >>> type(textFileProcessor.read_file_as_json())\n        <class 'dict'>\n        \"\"\"",
                "test_class": "TextFileProcessorTestReadFileAsJson",
                "test_code": "class TextFileProcessorTestReadFileAsJson(unittest.TestCase):\n    def setUp(self):\n        self.files = ['test_1.txt', 'test_2.txt', 'test_3.txt', 'test_4.txt', 'test_5.txt']\n        self.contents = ['{\\n    \"name\": \"test\",\\n    \"age\": 12\\n}', '12345', '\\\"hello\\\"', '\\\"aaa\\\"', '\\\"bbb\\\"']\n        for index, file in enumerate(self.files):\n            with open(file, 'w') as f:\n                f.write(self.contents[index])\n\n    # the dict type\n    def test_read_file_as_json_1(self):\n        textFileProcessor = TextFileProcessor(self.files[0])\n        data = textFileProcessor.read_file_as_json()\n        expected = {\"name\": \"test\", \"age\": 12}\n        self.assertEqual(dict, type(data))\n        self.assertEqual(expected, data)\n\n    # the int type\n    def test_read_file_as_json_2(self):\n        textFileProcessor = TextFileProcessor(self.files[1])\n        data = textFileProcessor.read_file_as_json()\n        expected = 12345\n        self.assertEqual(int, type(data))\n        self.assertEqual(expected, data)\n\n    # the str type\n    def test_read_file_as_json_3(self):\n        textFileProcessor = TextFileProcessor(self.files[2])\n        data = textFileProcessor.read_file_as_json()\n        expected = 'hello'\n        self.assertEqual(str, type(data))\n        self.assertEqual(expected, data)\n\n    def test_read_file_as_json_4(self):\n        textFileProcessor = TextFileProcessor(self.files[3])\n        data = textFileProcessor.read_file_as_json()\n        expected = 'aaa'\n        self.assertEqual(str, type(data))\n        self.assertEqual(expected, data)\n\n    def test_read_file_as_json_5(self):\n        textFileProcessor = TextFileProcessor(self.files[4])\n        data = textFileProcessor.read_file_as_json()\n        expected = 'bbb'\n        self.assertEqual(str, type(data))\n        self.assertEqual(expected, data)",
                "solution_code": "def read_file_as_json(self):\n        with open(self.file_path, 'r') as file:\n            data = json.load(file)\n\n        return data",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "json"
                    ],
                    "field_dependencies": [
                        "self.file_path"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "read_file",
                "method_description": "def read_file(self):\n        \"\"\"\n        Read the return the content of self.file_path file.\n        :return: the same return as the read() method\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\\n    \"name\": \"test\",\\n    \"age\": 12\\n}'\n        \"\"\"",
                "test_class": "TextFileProcessorTestReadFile",
                "test_code": "class TextFileProcessorTestReadFile(unittest.TestCase):\n    def setUp(self) -> None:\n        self.files = ['test_1.txt', 'test_2.txt', 'test_3.txt', 'test_4.txt', 'test_5.txt']\n        self.contents = ['123aac\\n&^(*&43)', '12345', 'aaa', 'bbb', 'ccc']\n        for index, file in enumerate(self.files):\n            with open(file, 'w') as f:\n                f.write(self.contents[index])\n\n    def test_read_file_1(self):\n        textFileProcessor = TextFileProcessor(self.files[0])\n        data = textFileProcessor.read_file()\n        self.assertEqual(str, type(data))\n        self.assertEqual(data, self.contents[0])\n\n    def test_read_file_2(self):\n        textFileProcessor = TextFileProcessor(self.files[1])\n        data = textFileProcessor.read_file()\n        self.assertEqual(str, type(data))\n        self.assertEqual(data, self.contents[1])\n\n    def test_read_file_3(self):\n        textFileProcessor = TextFileProcessor(self.files[2])\n        data = textFileProcessor.read_file()\n        self.assertEqual(str, type(data))\n        self.assertEqual(data, self.contents[2])\n\n    def test_read_file_4(self):\n        textFileProcessor = TextFileProcessor(self.files[3])\n        data = textFileProcessor.read_file()\n        self.assertEqual(str, type(data))\n        self.assertEqual(data, self.contents[3])\n\n    def test_read_file_5(self):\n        textFileProcessor = TextFileProcessor(self.files[4])\n        data = textFileProcessor.read_file()\n        self.assertEqual(str, type(data))\n        self.assertEqual(data, self.contents[4])",
                "solution_code": "def read_file(self):\n        with open(self.file_path, 'r') as file:\n            return file.read()",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.file_path"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "write_file",
                "method_description": "def write_file(self, content):\n        \"\"\"\n        Write content into the self.file_path file, and overwrite if the file has already existed.\n        :param content: any content\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.write_file('Hello world!')\n        >>> textFileProcessor.read_file()\n        'Hello world!'\n        \"\"\"",
                "test_class": "TextFileProcessorTestWriteFile",
                "test_code": "class TextFileProcessorTestWriteFile(unittest.TestCase):\n    def setUp(self) -> None:\n        self.files = ['test_1.txt', 'test_2.txt', 'test_3.txt', 'test_4.txt', 'test_5.txt']\n        self.contents = ['123aac\\n&^(*&43)', '12345', 'aaa', 'bbb', 'ccc']\n\n    def tearDown(self) -> None:\n        for file in self.files:\n            if os.path.exists(file):\n                os.remove(file)\n\n    def test_write_file_1(self):\n        textFileProcessor = TextFileProcessor(self.files[0])\n        textFileProcessor.write_file(self.contents[0])\n        with open(self.files[0], 'r') as f:\n            data = f.read()\n        self.assertEqual(data, self.contents[0])\n\n    def test_write_file_2(self):\n        textFileProcessor = TextFileProcessor(self.files[1])\n        textFileProcessor.write_file(self.contents[1])\n        with open(self.files[1], 'r') as f:\n            data = f.read()\n        self.assertEqual(data, self.contents[1])\n\n    def test_write_file_3(self):\n        textFileProcessor = TextFileProcessor(self.files[2])\n        textFileProcessor.write_file(self.contents[2])\n        with open(self.files[2], 'r') as f:\n            data = f.read()\n        self.assertEqual(data, self.contents[2])\n\n    def test_write_file_4(self):\n        textFileProcessor = TextFileProcessor(self.files[3])\n        textFileProcessor.write_file(self.contents[3])\n        with open(self.files[3], 'r') as f:\n            data = f.read()\n        self.assertEqual(data, self.contents[3])\n\n    def test_write_file_5(self):\n        textFileProcessor = TextFileProcessor(self.files[4])\n        textFileProcessor.write_file(self.contents[4])\n        with open(self.files[4], 'r') as f:\n            data = f.read()\n        self.assertEqual(data, self.contents[4])",
                "solution_code": "def write_file(self, content):\n        with open(self.file_path, 'w') as file:\n            file.write(content)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.file_path"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "process_file",
                "method_description": "def process_file(self):\n        \"\"\"\n        Read the self.file_path file and filter out non-alphabetic characters from the content string.\n        Overwrite the after-processed data into the same self.file_path file.\n        >>> textFileProcessor = TextFileProcessor('test.json')\n        >>> textFileProcessor.read_file()\n        '{\\n    \"name\": \"test\",\\n    \"age\": 12\\n}'\n        >>> textFileProcessor.process_file()\n        'nametestage'\n        \"\"\"",
                "test_class": "TextFileProcessorTestProcessFile",
                "test_code": "class TextFileProcessorTestProcessFile(unittest.TestCase):\n    def test_process_file_1(self):\n        self.file = 'test.txt'\n        self.content = 'Hello, 123 World!'\n        self.expected_result = 'HelloWorld'\n\n        textFileProcessor = TextFileProcessor(self.file)\n        textFileProcessor.read_file = MagicMock(return_value=self.content)\n        textFileProcessor.write_file = MagicMock()\n\n        result = textFileProcessor.process_file()\n        self.assertEqual(result, self.expected_result)\n        textFileProcessor.read_file.assert_called_once()\n        textFileProcessor.write_file.assert_called_once_with(self.expected_result)\n\n    def test_process_file_2(self):\n        self.file = 'test.txt'\n        self.content = 'Hello, abc World!'\n        self.expected_result = 'HelloabcWorld'\n\n        textFileProcessor = TextFileProcessor(self.file)\n        textFileProcessor.read_file = MagicMock(return_value=self.content)\n        textFileProcessor.write_file = MagicMock()\n\n        result = textFileProcessor.process_file()\n        self.assertEqual(result, self.expected_result)\n        textFileProcessor.read_file.assert_called_once()\n        textFileProcessor.write_file.assert_called_once_with(self.expected_result)\n\n    def test_process_file_3(self):\n        self.file = 'test.txt'\n        self.content = ', 123 !'\n        self.expected_result = ''\n\n        textFileProcessor = TextFileProcessor(self.file)\n        textFileProcessor.read_file = MagicMock(return_value=self.content)\n        textFileProcessor.write_file = MagicMock()\n\n        result = textFileProcessor.process_file()\n        self.assertEqual(result, self.expected_result)\n        textFileProcessor.read_file.assert_called_once()\n        textFileProcessor.write_file.assert_called_once_with(self.expected_result)\n\n    def test_process_file_4(self):\n        self.file = 'test.txt'\n        self.content = 'Hello, World!'\n        self.expected_result = 'HelloWorld'\n\n        textFileProcessor = TextFileProcessor(self.file)\n        textFileProcessor.read_file = MagicMock(return_value=self.content)\n        textFileProcessor.write_file = MagicMock()\n\n        result = textFileProcessor.process_file()\n        self.assertEqual(result, self.expected_result)\n        textFileProcessor.read_file.assert_called_once()\n        textFileProcessor.write_file.assert_called_once_with(self.expected_result)\n\n    def test_process_file_5(self):\n        self.file = 'test.txt'\n        self.content = 'Hello, 123a World!'\n        self.expected_result = 'HelloaWorld'\n\n        textFileProcessor = TextFileProcessor(self.file)\n        textFileProcessor.read_file = MagicMock(return_value=self.content)\n        textFileProcessor.write_file = MagicMock()\n\n        result = textFileProcessor.process_file()\n        self.assertEqual(result, self.expected_result)\n        textFileProcessor.read_file.assert_called_once()\n        textFileProcessor.write_file.assert_called_once_with(self.expected_result)",
                "solution_code": "def process_file(self):\n        content = self.read_file()\n        content = ''.join([char for char in content if char.isalpha()])\n        self.write_file(content)\n        return content",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "read_file",
                        "write_file"
                    ]
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_87",
        "skeleton": "import datetime\nimport time\n\nclass TimeUtils:\n    \"\"\"\n    This is a time util class, including getting the current time and date, adding seconds to a datetime, converting between strings and datetime objects, calculating the time difference in minutes, and formatting a datetime object.\n    \"\"\"\n\n\n    def __init__(self):\n        \"\"\"\n        Get the current datetime\n        \"\"\"\n        self.datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        \"\"\"\n        Return the current time in the format of '%H:%M:%S'\n        :return: string\n        >>> timeutils = TimeUtils()\n        >>> timeutils.get_current_time()\n        \"19:19:22\"\n        \"\"\"\n\n    def get_current_date(self):\n        \"\"\"\n        Return the current date in the format of \"%Y-%m-%d\"\n        :return: string\n        >>> timeutils.get_current_date()\n        \"2023-06-14\"\n        \"\"\"\n\n    def add_seconds(self, seconds):\n        \"\"\"\n        Add the specified number of seconds to the current time\n        :param seconds: int, number of seconds to add\n        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'\n        >>> timeutils.add_seconds(600)\n        \"19:29:22\"\n        \"\"\"\n\n    def string_to_datetime(self, string):\n        \"\"\"\n        Convert the time string to a datetime instance\n        :param string: string, string before converting format\n        :return: datetime instance\n        >>> timeutils.string_to_datetime(\"2001-7-18 1:1:1\")\n        2001-07-18 01:01:01\n        \"\"\"\n\n    def datetime_to_string(self, datetime):\n        \"\"\"\n        Convert a datetime instance to a string\n        :param datetime: the datetime instance to convert\n        :return: string, converted time string\n        >>> timeutils.datetime_to_string(timeutils.datetime)\n        \"2023-06-14 19:30:03\"\n        \"\"\"\n\n    def get_minutes(self, string_time1, string_time2):\n        \"\"\"\n        Calculate how many minutes have passed between two times, and round the results to the nearest\n        :return: int, the number of minutes between two times, rounded off\n        >>> timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 2:1:1\")\n        60\n        \"\"\"\n\n    def get_format_time(self, year, month, day, hour, minute, second):\n        \"\"\"\n        get format time\n        :param year: int\n        :param month: int\n        :param day: int\n        :param hour: int\n        :param minute: int\n        :param second: int\n        :return: formatted time string\n        >>> timeutils.get_format_time(2001, 7, 18, 1, 1, 1)\n        \"2001-07-18 01:01:01\"\n        \"\"\"",
        "test": "import unittest\n\n\nclass TimeUtilsTestGetCurrentTime(unittest.TestCase):\n    def test_get_current_time_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_time(), timeutils.datetime.strftime(\"%H:%M:%S\"))\n\n    def test_get_current_time_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_time(), timeutils.datetime.strftime(\"%H:%M:%S\"))\n\n    def test_get_current_time_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_time(), timeutils.datetime.strftime(\"%H:%M:%S\"))\n\n    def test_get_current_time_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_time(), timeutils.datetime.strftime(\"%H:%M:%S\"))\n\n    def test_get_current_time_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_time(), timeutils.datetime.strftime(\"%H:%M:%S\"))\n\n\nclass TimeUtilsTestGetCurrentDate(unittest.TestCase):\n    def test_get_current_date_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_date(), timeutils.datetime.strftime(\"%Y-%m-%d\"))\n\n    def test_get_current_date_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_date(), timeutils.datetime.strftime(\"%Y-%m-%d\"))\n\n    def test_get_current_date_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_date(), timeutils.datetime.strftime(\"%Y-%m-%d\"))\n\n    def test_get_current_date_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_date(), timeutils.datetime.strftime(\"%Y-%m-%d\"))\n\n    def test_get_current_date_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_date(), timeutils.datetime.strftime(\"%Y-%m-%d\"))\n\n\nclass TimeUtilsTestAddSeconds(unittest.TestCase):\n    def test_add_seconds_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.add_seconds(600),\n                         (timeutils.datetime + datetime.timedelta(seconds=600)).strftime(\"%H:%M:%S\"))\n\n    def test_add_seconds_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.add_seconds(500),\n                         (timeutils.datetime + datetime.timedelta(seconds=500)).strftime(\"%H:%M:%S\"))\n\n    def test_add_seconds_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.add_seconds(400),\n                         (timeutils.datetime + datetime.timedelta(seconds=400)).strftime(\"%H:%M:%S\"))\n\n    def test_add_seconds_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.add_seconds(300),\n                         (timeutils.datetime + datetime.timedelta(seconds=300)).strftime(\"%H:%M:%S\"))\n\n    def test_add_seconds_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.add_seconds(200),\n                         (timeutils.datetime + datetime.timedelta(seconds=200)).strftime(\"%H:%M:%S\"))\n\n\nclass TimeUtilsTestStringToDatetime(unittest.TestCase):\n    def test_string_to_datetime_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.string_to_datetime('2001-7-18 1:1:1'), datetime.datetime(2001, 7, 18, 1, 1, 1))\n\n    def test_string_to_datetime_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.string_to_datetime('2001-7-17 1:1:1'), datetime.datetime(2001, 7, 17, 1, 1, 1))\n\n    def test_string_to_datetime_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.string_to_datetime('2001-7-16 1:1:1'), datetime.datetime(2001, 7, 16, 1, 1, 1))\n\n    def test_string_to_datetime_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.string_to_datetime('2001-7-15 1:1:1'), datetime.datetime(2001, 7, 15, 1, 1, 1))\n\n    def test_string_to_datetime_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.string_to_datetime('2001-7-14 1:1:1'), datetime.datetime(2001, 7, 14, 1, 1, 1))\n\n\nclass TimeUtilsTestDatetimeToString(unittest.TestCase):\n    def test_datetime_to_string_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.datetime_to_string(timeutils.datetime),\n                         timeutils.datetime.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\n    def test_datetime_to_string_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.datetime_to_string(timeutils.datetime),\n                         timeutils.datetime.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\n    def test_datetime_to_string_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.datetime_to_string(timeutils.datetime),\n                         timeutils.datetime.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\n    def test_datetime_to_string_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.datetime_to_string(timeutils.datetime),\n                         timeutils.datetime.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\n    def test_datetime_to_string_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.datetime_to_string(timeutils.datetime),\n                         timeutils.datetime.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\n\nclass TimeUtilsTestGetMinutes(unittest.TestCase):\n    def test_get_minutes_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 2:1:1\"), 60)\n\n    def test_get_minutes_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 3:1:1\"), 120)\n\n    def test_get_minutes_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 4:1:1\"), 180)\n\n    def test_get_minutes_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 5:1:1\"), 240)\n\n    def test_get_minutes_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 6:1:1\"), 300)\n\n\nclass TimeUtilsTestGetFormatTime(unittest.TestCase):\n    def test_get_format_time_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_format_time(2001, 7, 18, 1, 1, 1), \"2001-07-18 01:01:01\")\n\n    def test_get_format_time_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_format_time(2001, 7, 17, 1, 1, 1), \"2001-07-17 01:01:01\")\n\n    def test_get_format_time_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_format_time(2001, 7, 16, 1, 1, 1), \"2001-07-16 01:01:01\")\n\n    def test_get_format_time_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_format_time(2001, 7, 15, 1, 1, 1), \"2001-07-15 01:01:01\")\n\n    def test_get_format_time_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_format_time(2001, 7, 14, 1, 1, 1), \"2001-07-14 01:01:01\")\n\n\nclass TimeUtilsTest(unittest.TestCase):\n    def test_timeutils(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_time(), timeutils.datetime.strftime(\"%H:%M:%S\"))\n        self.assertEqual(timeutils.get_current_date(), timeutils.datetime.strftime(\"%Y-%m-%d\"))\n        self.assertEqual(timeutils.add_seconds(600),\n                         (timeutils.datetime + datetime.timedelta(seconds=600)).strftime(\"%H:%M:%S\"))\n        self.assertEqual(timeutils.string_to_datetime('2001-7-18 1:1:1'), datetime.datetime(2001, 7, 18, 1, 1, 1))\n        self.assertEqual(timeutils.datetime_to_string(timeutils.datetime),\n                         timeutils.datetime.strftime(\"%Y-%m-%d %H:%M:%S\"))\n        self.assertEqual(timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 2:1:1\"), 60)\n        self.assertEqual(timeutils.get_format_time(2001, 7, 18, 1, 1, 1), \"2001-07-18 01:01:01\")",
        "solution_code": "import datetime\nimport time\n\nclass TimeUtils:\n\n    def __init__(self):\n        self.datetime = datetime.datetime.now()\n\n    def get_current_time(self):\n        format = \"%H:%M:%S\"\n        return self.datetime.strftime(format)\n\n    def get_current_date(self):\n        format = \"%Y-%m-%d\"\n        return self.datetime.strftime(format)\n\n    def add_seconds(self, seconds):\n        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)\n        format = \"%H:%M:%S\"\n        return new_datetime.strftime(format)\n\n    def string_to_datetime(self, string):\n        return datetime.datetime.strptime(string, \"%Y-%m-%d %H:%M:%S\")\n\n    def datetime_to_string(self, datetime):\n        return datetime.strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    def get_minutes(self, string_time1, string_time2):\n        time1 = self.string_to_datetime(string_time1)\n        time2 = self.string_to_datetime(string_time2)\n        return round((time2 - time1).seconds / 60)\n\n    def get_format_time(self, year, month, day, hour, minute, second):\n        format = \"%Y-%m-%d %H:%M:%S\"\n        time_item = datetime.datetime(year, month, day, hour, minute, second)\n        return time_item.strftime(format)",
        "import_statement": [
            "import datetime",
            "import time"
        ],
        "class_description": "    \"\"\"\n    This is a time util class, including getting the current time and date, adding seconds to a datetime, converting between strings and datetime objects, calculating the time difference in minutes, and formatting a datetime object.\n    \"\"\"\n",
        "class_name": "TimeUtils",
        "test_classes": [
            "TimeUtilsTestGetCurrentTime",
            "TimeUtilsTestGetCurrentDate",
            "TimeUtilsTestAddSeconds",
            "TimeUtilsTestStringToDatetime",
            "TimeUtilsTestDatetimeToString",
            "TimeUtilsTestGetMinutes",
            "TimeUtilsTestGetFormatTime",
            "TimeUtilsTest"
        ],
        "class_constructor": "class TimeUtils: \n    def __init__(self):\n        \"\"\"\n        Get the current datetime\n        \"\"\"\n        self.datetime = datetime.datetime.now()\n\n",
        "fields": [
            "self.datetime"
        ],
        "methods_info": [
            {
                "method_name": "get_current_time",
                "method_description": "def get_current_time(self):\n        \"\"\"\n        Return the current time in the format of '%H:%M:%S'\n        :return: string\n        >>> timeutils = TimeUtils()\n        >>> timeutils.get_current_time()\n        \"19:19:22\"\n        \"\"\"",
                "test_class": "TimeUtilsTestGetCurrentTime",
                "test_code": "class TimeUtilsTestGetCurrentTime(unittest.TestCase):\n    def test_get_current_time_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_time(), timeutils.datetime.strftime(\"%H:%M:%S\"))\n\n    def test_get_current_time_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_time(), timeutils.datetime.strftime(\"%H:%M:%S\"))\n\n    def test_get_current_time_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_time(), timeutils.datetime.strftime(\"%H:%M:%S\"))\n\n    def test_get_current_time_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_time(), timeutils.datetime.strftime(\"%H:%M:%S\"))\n\n    def test_get_current_time_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_time(), timeutils.datetime.strftime(\"%H:%M:%S\"))",
                "solution_code": "def get_current_time(self):\n        format = \"%H:%M:%S\"\n        return self.datetime.strftime(format)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime",
                        "time"
                    ],
                    "field_dependencies": [
                        "self.datetime"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "get_current_date",
                "method_description": "def get_current_date(self):\n        \"\"\"\n        Return the current date in the format of \"%Y-%m-%d\"\n        :return: string\n        >>> timeutils.get_current_date()\n        \"2023-06-14\"\n        \"\"\"",
                "test_class": "TimeUtilsTestGetCurrentDate",
                "test_code": "class TimeUtilsTestGetCurrentDate(unittest.TestCase):\n    def test_get_current_date_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_date(), timeutils.datetime.strftime(\"%Y-%m-%d\"))\n\n    def test_get_current_date_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_date(), timeutils.datetime.strftime(\"%Y-%m-%d\"))\n\n    def test_get_current_date_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_date(), timeutils.datetime.strftime(\"%Y-%m-%d\"))\n\n    def test_get_current_date_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_date(), timeutils.datetime.strftime(\"%Y-%m-%d\"))\n\n    def test_get_current_date_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_current_date(), timeutils.datetime.strftime(\"%Y-%m-%d\"))",
                "solution_code": "def get_current_date(self):\n        format = \"%Y-%m-%d\"\n        return self.datetime.strftime(format)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime",
                        "time"
                    ],
                    "field_dependencies": [
                        "self.datetime"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "add_seconds",
                "method_description": "def add_seconds(self, seconds):\n        \"\"\"\n        Add the specified number of seconds to the current time\n        :param seconds: int, number of seconds to add\n        :return: string, time after adding the specified number of seconds in the format '%H:%M:%S'\n        >>> timeutils.add_seconds(600)\n        \"19:29:22\"\n        \"\"\"",
                "test_class": "TimeUtilsTestAddSeconds",
                "test_code": "class TimeUtilsTestAddSeconds(unittest.TestCase):\n    def test_add_seconds_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.add_seconds(600),\n                         (timeutils.datetime + datetime.timedelta(seconds=600)).strftime(\"%H:%M:%S\"))\n\n    def test_add_seconds_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.add_seconds(500),\n                         (timeutils.datetime + datetime.timedelta(seconds=500)).strftime(\"%H:%M:%S\"))\n\n    def test_add_seconds_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.add_seconds(400),\n                         (timeutils.datetime + datetime.timedelta(seconds=400)).strftime(\"%H:%M:%S\"))\n\n    def test_add_seconds_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.add_seconds(300),\n                         (timeutils.datetime + datetime.timedelta(seconds=300)).strftime(\"%H:%M:%S\"))\n\n    def test_add_seconds_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.add_seconds(200),\n                         (timeutils.datetime + datetime.timedelta(seconds=200)).strftime(\"%H:%M:%S\"))",
                "solution_code": "def add_seconds(self, seconds):\n        new_datetime = self.datetime + datetime.timedelta(seconds=seconds)\n        format = \"%H:%M:%S\"\n        return new_datetime.strftime(format)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime",
                        "time"
                    ],
                    "field_dependencies": [
                        "self.datetime"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "string_to_datetime",
                "method_description": "def string_to_datetime(self, string):\n        \"\"\"\n        Convert the time string to a datetime instance\n        :param string: string, string before converting format\n        :return: datetime instance\n        >>> timeutils.string_to_datetime(\"2001-7-18 1:1:1\")\n        2001-07-18 01:01:01\n        \"\"\"",
                "test_class": "TimeUtilsTestStringToDatetime",
                "test_code": "class TimeUtilsTestStringToDatetime(unittest.TestCase):\n    def test_string_to_datetime_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.string_to_datetime('2001-7-18 1:1:1'), datetime.datetime(2001, 7, 18, 1, 1, 1))\n\n    def test_string_to_datetime_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.string_to_datetime('2001-7-17 1:1:1'), datetime.datetime(2001, 7, 17, 1, 1, 1))\n\n    def test_string_to_datetime_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.string_to_datetime('2001-7-16 1:1:1'), datetime.datetime(2001, 7, 16, 1, 1, 1))\n\n    def test_string_to_datetime_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.string_to_datetime('2001-7-15 1:1:1'), datetime.datetime(2001, 7, 15, 1, 1, 1))\n\n    def test_string_to_datetime_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.string_to_datetime('2001-7-14 1:1:1'), datetime.datetime(2001, 7, 14, 1, 1, 1))",
                "solution_code": "def string_to_datetime(self, string):\n        return datetime.datetime.strptime(string, \"%Y-%m-%d %H:%M:%S\")",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime",
                        "time"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "datetime_to_string",
                "method_description": "def datetime_to_string(self, datetime):\n        \"\"\"\n        Convert a datetime instance to a string\n        :param datetime: the datetime instance to convert\n        :return: string, converted time string\n        >>> timeutils.datetime_to_string(timeutils.datetime)\n        \"2023-06-14 19:30:03\"\n        \"\"\"",
                "test_class": "TimeUtilsTestDatetimeToString",
                "test_code": "class TimeUtilsTestDatetimeToString(unittest.TestCase):\n    def test_datetime_to_string_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.datetime_to_string(timeutils.datetime),\n                         timeutils.datetime.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\n    def test_datetime_to_string_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.datetime_to_string(timeutils.datetime),\n                         timeutils.datetime.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\n    def test_datetime_to_string_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.datetime_to_string(timeutils.datetime),\n                         timeutils.datetime.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\n    def test_datetime_to_string_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.datetime_to_string(timeutils.datetime),\n                         timeutils.datetime.strftime(\"%Y-%m-%d %H:%M:%S\"))\n\n    def test_datetime_to_string_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.datetime_to_string(timeutils.datetime),\n                         timeutils.datetime.strftime(\"%Y-%m-%d %H:%M:%S\"))",
                "solution_code": "def datetime_to_string(self, datetime):\n        return datetime.strftime(\"%Y-%m-%d %H:%M:%S\")",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime",
                        "time"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "get_minutes",
                "method_description": "def get_minutes(self, string_time1, string_time2):\n        \"\"\"\n        Calculate how many minutes have passed between two times, and round the results to the nearest\n        :return: int, the number of minutes between two times, rounded off\n        >>> timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 2:1:1\")\n        60\n        \"\"\"",
                "test_class": "TimeUtilsTestGetMinutes",
                "test_code": "class TimeUtilsTestGetMinutes(unittest.TestCase):\n    def test_get_minutes_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 2:1:1\"), 60)\n\n    def test_get_minutes_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 3:1:1\"), 120)\n\n    def test_get_minutes_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 4:1:1\"), 180)\n\n    def test_get_minutes_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 5:1:1\"), 240)\n\n    def test_get_minutes_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_minutes(\"2001-7-18 1:1:1\", \"2001-7-18 6:1:1\"), 300)",
                "solution_code": "def get_minutes(self, string_time1, string_time2):\n        time1 = self.string_to_datetime(string_time1)\n        time2 = self.string_to_datetime(string_time2)\n        return round((time2 - time1).seconds / 60)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime",
                        "time"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": [
                        "string_to_datetime"
                    ]
                }
            },
            {
                "method_name": "get_format_time",
                "method_description": "def get_format_time(self, year, month, day, hour, minute, second):\n        \"\"\"\n        get format time\n        :param year: int\n        :param month: int\n        :param day: int\n        :param hour: int\n        :param minute: int\n        :param second: int\n        :return: formatted time string\n        >>> timeutils.get_format_time(2001, 7, 18, 1, 1, 1)\n        \"2001-07-18 01:01:01\"\n        \"\"\"",
                "test_class": "TimeUtilsTestGetFormatTime",
                "test_code": "class TimeUtilsTestGetFormatTime(unittest.TestCase):\n    def test_get_format_time_1(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_format_time(2001, 7, 18, 1, 1, 1), \"2001-07-18 01:01:01\")\n\n    def test_get_format_time_2(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_format_time(2001, 7, 17, 1, 1, 1), \"2001-07-17 01:01:01\")\n\n    def test_get_format_time_3(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_format_time(2001, 7, 16, 1, 1, 1), \"2001-07-16 01:01:01\")\n\n    def test_get_format_time_4(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_format_time(2001, 7, 15, 1, 1, 1), \"2001-07-15 01:01:01\")\n\n    def test_get_format_time_5(self):\n        timeutils = TimeUtils()\n        self.assertEqual(timeutils.get_format_time(2001, 7, 14, 1, 1, 1), \"2001-07-14 01:01:01\")",
                "solution_code": "def get_format_time(self, year, month, day, hour, minute, second):\n        format = \"%Y-%m-%d %H:%M:%S\"\n        time_item = datetime.datetime(year, month, day, hour, minute, second)\n        return time_item.strftime(format)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "datetime",
                        "time"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_89",
        "skeleton": "import random\n\nclass TwentyFourPointGame:\n    \"\"\"\n    This ia a game of twenty-four points, which provides to generate four numbers and check whether player's expression is equal to 24.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.nums = []\n\n\n    def _generate_cards(self):\n        \"\"\"\n        Generate random numbers between 1 and 9 for the cards.\n        \"\"\"\n\n\n    def get_my_cards(self):\n        \"\"\"\n        Get a list of four random numbers between 1 and 9 representing the player's cards.\n        :return: list of integers, representing the player's cards\n        >>> game = TwentyFourPointGame()\n        >>> game.get_my_cards()\n\n        \"\"\"\n\n\n    def answer(self, expression):\n        \"\"\"\n        Check if a given mathematical expression using the cards can evaluate to 24.\n        :param expression: string, mathematical expression using the cards\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> game.nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.answer(ans)\n        True\n        \"\"\"\n\n\n    def evaluate_expression(self, expression):\n        \"\"\"\n        Evaluate a mathematical expression and check if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.evaluate_expression(ans)\n        True\n        \"\"\"",
        "test": "import unittest\n\n\nclass TwentyFourPointGameTestGetMyCards(unittest.TestCase):\n    def test_get_my_cards_1(self):\n        game = TwentyFourPointGame()\n        cards = game.get_my_cards()\n        self.assertEqual(len(cards), 4)\n        for card in cards:\n            self.assertIn(card, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    def test_get_my_cards_2(self):\n        game = TwentyFourPointGame()\n        cards = game.get_my_cards()\n        self.assertEqual(len(cards), 4)\n        for card in cards:\n            self.assertIn(card, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    def test_get_my_cards_3(self):\n        game = TwentyFourPointGame()\n        cards = game.get_my_cards()\n        self.assertEqual(len(cards), 4)\n        for card in cards:\n            self.assertIn(card, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    def test_get_my_cards_4(self):\n        game = TwentyFourPointGame()\n        cards = game.get_my_cards()\n        self.assertEqual(len(cards), 4)\n        for card in cards:\n            self.assertIn(card, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    def test_get_my_cards_5(self):\n        game = TwentyFourPointGame()\n        cards = game.get_my_cards()\n        self.assertEqual(len(cards), 4)\n        for card in cards:\n            self.assertIn(card, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n\nclass TwentyFourPointGameTestAnswer(unittest.TestCase):\n    def test_answer_1(self):\n        game = TwentyFourPointGame()\n        cards = game.answer('pass')\n        self.assertEqual(len(cards), 4)\n\n    def test_answer_2(self):\n        game = TwentyFourPointGame()\n        result = game.answer('4*3+6+6')\n        self.assertTrue(result)\n\n    def test_answer_3(self):\n        game = TwentyFourPointGame()\n        result = game.answer('1+1+1+1')\n        self.assertFalse(result)\n\n    def test_answer_4(self):\n        game = TwentyFourPointGame()\n        result = game.answer('1+')\n        self.assertFalse(result)\n\n    def test_answer_5(self):\n        game = TwentyFourPointGame()\n        result = game.answer('abc')\n        self.assertFalse(result)\n\n    def test_answer_6(self):\n        game = TwentyFourPointGame()\n        game.nums = [1, 1, 1, 1]\n        result = game.answer('1+1+1+2')\n        self.assertFalse(result)\n\n    def test_answer_7(self):\n        game = TwentyFourPointGame()\n        game.nums = [1, 1, 1, 1]\n        result = game.answer('1+1+1+1+1')\n        self.assertFalse(result)\n\n\nclass TwentyFourPointGameTestEvaluateExpression(unittest.TestCase):\n    def test_evaluate_expression_1(self):\n        game = TwentyFourPointGame()\n        result = game.evaluate_expression('4+3+6+6')\n        self.assertFalse(result)\n\n    def test_evaluate_expression_2(self):\n        game = TwentyFourPointGame()\n        result = game.evaluate_expression('4*3+6+6')\n        self.assertTrue(result)\n\n    def test_evaluate_expression_3(self):\n        game = TwentyFourPointGame()\n        result = game.evaluate_expression('1+1+1+1')\n        self.assertFalse(result)\n\n    def test_evaluate_expression_4(self):\n        game = TwentyFourPointGame()\n        result = game.evaluate_expression('1+')\n        self.assertFalse(result)\n\n    def test_evaluate_expression_5(self):\n        game = TwentyFourPointGame()\n        result = game.evaluate_expression('abc')\n        self.assertFalse(result)\n\n\nclass TwentyFourPointGameTest(unittest.TestCase):\n    def test_TwentyFourPointGame(self):\n        game = TwentyFourPointGame()\n        cards = game.get_my_cards()\n        self.assertEqual(len(cards), 4)\n        for card in cards:\n            self.assertIn(card, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        game.nums = [4, 3, 6, 6]\n        result = game.answer('4*3+6+6')\n        self.assertTrue(result)\n        result = game.evaluate_expression('4*3+6+6')\n        self.assertTrue(result)",
        "solution_code": "import random\n\n\nclass TwentyFourPointGame:\n    def __init__(self) -> None:\n        self.nums = []\n\n    def _generate_cards(self):\n        for i in range(4):\n            self.nums.append(random.randint(1, 9))\n        assert len(self.nums) == 4\n\n    def get_my_cards(self):\n        self.nums = []\n        self._generate_cards()\n        return self.nums\n\n    def answer(self, expression):\n        if expression == 'pass':\n            return self.get_my_cards()\n        statistic = {}\n        for c in expression:\n            if c.isdigit() and int(c) in self.nums:\n                statistic[c] = statistic.get(c, 0) + 1\n\n        nums_used = statistic.copy()\n\n        for num in self.nums:\n            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:\n                nums_used[str(num)] -= 1\n            else:\n                return False\n\n        if all(count == 0 for count in nums_used.values()) == True:\n            return self.evaluate_expression(expression)\n        else:\n            return False\n\n    def evaluate_expression(self, expression):\n        try:\n            if eval(expression) == 24:\n                return True\n            else:\n                return False\n        except Exception as e:\n            return False",
        "import_statement": [
            "import random"
        ],
        "class_description": "    \"\"\"\n    This ia a game of twenty-four points, which provides to generate four numbers and check whether player's expression is equal to 24.\n    \"\"\"\n",
        "class_name": "TwentyFourPointGame",
        "test_classes": [
            "TwentyFourPointGameTestGetMyCards",
            "TwentyFourPointGameTestAnswer",
            "TwentyFourPointGameTestEvaluateExpression",
            "TwentyFourPointGameTest"
        ],
        "class_constructor": "class TwentyFourPointGame: \n    def __init__(self) -> None:\n        self.nums = []\n\n\n",
        "fields": [
            "self.nums"
        ],
        "methods_info": [
            {
                "method_name": "_generate_cards",
                "method_description": "def _generate_cards(self):\n        \"\"\"\n        Generate random numbers between 1 and 9 for the cards.\n        \"\"\"",
                "test_class": "TwentyFourPointGameTestGetMyCards",
                "test_code": "class TwentyFourPointGameTestGetMyCards(unittest.TestCase):\n    def test_get_my_cards_1(self):\n        game = TwentyFourPointGame()\n        cards = game.get_my_cards()\n        self.assertEqual(len(cards), 4)\n        for card in cards:\n            self.assertIn(card, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    def test_get_my_cards_2(self):\n        game = TwentyFourPointGame()\n        cards = game.get_my_cards()\n        self.assertEqual(len(cards), 4)\n        for card in cards:\n            self.assertIn(card, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    def test_get_my_cards_3(self):\n        game = TwentyFourPointGame()\n        cards = game.get_my_cards()\n        self.assertEqual(len(cards), 4)\n        for card in cards:\n            self.assertIn(card, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    def test_get_my_cards_4(self):\n        game = TwentyFourPointGame()\n        cards = game.get_my_cards()\n        self.assertEqual(len(cards), 4)\n        for card in cards:\n            self.assertIn(card, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n\n    def test_get_my_cards_5(self):\n        game = TwentyFourPointGame()\n        cards = game.get_my_cards()\n        self.assertEqual(len(cards), 4)\n        for card in cards:\n            self.assertIn(card, [1, 2, 3, 4, 5, 6, 7, 8, 9])",
                "solution_code": "def _generate_cards(self):\n        for i in range(4):\n            self.nums.append(random.randint(1, 9))\n        assert len(self.nums) == 4",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "random"
                    ],
                    "field_dependencies": [
                        "self.nums"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "get_my_cards",
                "method_description": "def get_my_cards(self):\n        \"\"\"\n        Get a list of four random numbers between 1 and 9 representing the player's cards.\n        :return: list of integers, representing the player's cards\n        >>> game = TwentyFourPointGame()\n        >>> game.get_my_cards()\n\n        \"\"\"",
                "test_class": "TwentyFourPointGameTestAnswer",
                "test_code": "class TwentyFourPointGameTestAnswer(unittest.TestCase):\n    def test_answer_1(self):\n        game = TwentyFourPointGame()\n        cards = game.answer('pass')\n        self.assertEqual(len(cards), 4)\n\n    def test_answer_2(self):\n        game = TwentyFourPointGame()\n        result = game.answer('4*3+6+6')\n        self.assertTrue(result)\n\n    def test_answer_3(self):\n        game = TwentyFourPointGame()\n        result = game.answer('1+1+1+1')\n        self.assertFalse(result)\n\n    def test_answer_4(self):\n        game = TwentyFourPointGame()\n        result = game.answer('1+')\n        self.assertFalse(result)\n\n    def test_answer_5(self):\n        game = TwentyFourPointGame()\n        result = game.answer('abc')\n        self.assertFalse(result)\n\n    def test_answer_6(self):\n        game = TwentyFourPointGame()\n        game.nums = [1, 1, 1, 1]\n        result = game.answer('1+1+1+2')\n        self.assertFalse(result)\n\n    def test_answer_7(self):\n        game = TwentyFourPointGame()\n        game.nums = [1, 1, 1, 1]\n        result = game.answer('1+1+1+1+1')\n        self.assertFalse(result)",
                "solution_code": "def get_my_cards(self):\n        self.nums = []\n        self._generate_cards()\n        return self.nums",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.nums"
                    ],
                    "method_dependencies": [
                        "_generate_cards"
                    ]
                }
            },
            {
                "method_name": "answer",
                "method_description": "def answer(self, expression):\n        \"\"\"\n        Check if a given mathematical expression using the cards can evaluate to 24.\n        :param expression: string, mathematical expression using the cards\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> game.nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.answer(ans)\n        True\n        \"\"\"",
                "test_class": "TwentyFourPointGameTestEvaluateExpression",
                "test_code": "class TwentyFourPointGameTestEvaluateExpression(unittest.TestCase):\n    def test_evaluate_expression_1(self):\n        game = TwentyFourPointGame()\n        result = game.evaluate_expression('4+3+6+6')\n        self.assertFalse(result)\n\n    def test_evaluate_expression_2(self):\n        game = TwentyFourPointGame()\n        result = game.evaluate_expression('4*3+6+6')\n        self.assertTrue(result)\n\n    def test_evaluate_expression_3(self):\n        game = TwentyFourPointGame()\n        result = game.evaluate_expression('1+1+1+1')\n        self.assertFalse(result)\n\n    def test_evaluate_expression_4(self):\n        game = TwentyFourPointGame()\n        result = game.evaluate_expression('1+')\n        self.assertFalse(result)\n\n    def test_evaluate_expression_5(self):\n        game = TwentyFourPointGame()\n        result = game.evaluate_expression('abc')\n        self.assertFalse(result)",
                "solution_code": "def answer(self, expression):\n        if expression == 'pass':\n            return self.get_my_cards()\n        statistic = {}\n        for c in expression:\n            if c.isdigit() and int(c) in self.nums:\n                statistic[c] = statistic.get(c, 0) + 1\n\n        nums_used = statistic.copy()\n\n        for num in self.nums:\n            if nums_used.get(str(num), -100) != -100 and nums_used[str(num)] > 0:\n                nums_used[str(num)] -= 1\n            else:\n                return False\n\n        if all(count == 0 for count in nums_used.values()) == True:\n            return self.evaluate_expression(expression)\n        else:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.nums"
                    ],
                    "method_dependencies": [
                        "get_my_cards",
                        "evaluate_expression"
                    ]
                }
            },
            {
                "method_name": "evaluate_expression",
                "method_description": "def evaluate_expression(self, expression):\n        \"\"\"\n        Evaluate a mathematical expression and check if the result is 24.\n        :param expression: string, mathematical expression\n        :return: bool, True if the expression evaluates to 24, False otherwise\n        >>> game = TwentyFourPointGame()\n        >>> nums = [4, 3, 6, 6]\n        >>> ans = \"4*3+6+6\"\n        >>> ret = game.evaluate_expression(ans)\n        True\n        \"\"\"",
                "test_class": "TwentyFourPointGameTest",
                "test_code": "class TwentyFourPointGameTest(unittest.TestCase):\n    def test_TwentyFourPointGame(self):\n        game = TwentyFourPointGame()\n        cards = game.get_my_cards()\n        self.assertEqual(len(cards), 4)\n        for card in cards:\n            self.assertIn(card, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n        game.nums = [4, 3, 6, 6]\n        result = game.answer('4*3+6+6')\n        self.assertTrue(result)\n        result = game.evaluate_expression('4*3+6+6')\n        self.assertTrue(result)",
                "solution_code": "def evaluate_expression(self, expression):\n        try:\n            if eval(expression) == 24:\n                return True\n            else:\n                return False\n        except Exception as e:\n            return False",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_91",
        "skeleton": "import urllib.parse\n\nclass UrlPath:\n    \"\"\"\n    The  class is a utility for encapsulating and manipulating the path component of a URL, including adding nodes, parsing path strings, and building path strings with optional encoding.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.\n        \"\"\"\n        self.segments = []\n        self.with_end_tag = False\n\n    def add(self, segment):\n        \"\"\"\n        Adds a segment to the list of segments in the UrlPath.\n        :param segment: str, the segment to add.\n        >>> url_path = UrlPath()\n        >>> url_path.add('foo')\n        >>> url_path.add('bar')\n\n        url_path.segments = ['foo', 'bar']\n        \"\"\"\n\n\n    def parse(self, path, charset):\n        \"\"\"\n        Parses a given path string and populates the list of segments in the UrlPath.\n        :param path: str, the path string to parse.\n        :param charset: str, the character encoding of the path string.\n        >>> url_path = UrlPath()\n        >>> url_path.parse('/foo/bar/', 'utf-8')\n\n        url_path.segments = ['foo', 'bar']\n        \"\"\"\n\n\n    @staticmethod\n    def fix_path(path):\n        \"\"\"\n        Fixes the given path string by removing leading and trailing slashes.\n        :param path: str, the path string to fix.\n        :return: str, the fixed path string.\n        >>> url_path = UrlPath()\n        >>> url_path.fix_path('/foo/bar/')\n        'foo/bar'\n\n        \"\"\"",
        "test": "import unittest\n\n\nclass UrlPathTestAdd(unittest.TestCase):\n    def test_add_1(self):\n        url_path = UrlPath()\n        url_path.add('foo')\n        url_path.add('bar')\n        self.assertEqual(url_path.segments, ['foo', 'bar'])\n\n    def test_add_2(self):\n        url_path = UrlPath()\n        url_path.add('aaa')\n        url_path.add('bbb')\n        self.assertEqual(url_path.segments, ['aaa', 'bbb'])\n\n    def test_add_3(self):\n        url_path = UrlPath()\n        url_path.add('123')\n        self.assertEqual(url_path.segments, ['123'])\n\n    def test_add_4(self):\n        url_path = UrlPath()\n        url_path.add('ddd')\n        self.assertEqual(url_path.segments, ['ddd'])\n\n    def test_add_5(self):\n        url_path = UrlPath()\n        url_path.add('eee')\n        self.assertEqual(url_path.segments, ['eee'])\n\n\nclass UrlPathTestParse(unittest.TestCase):\n    def test_parse_1(self):\n        url_path = UrlPath()\n        url_path.parse('/foo/bar/', 'utf-8')\n        self.assertEqual(url_path.segments, ['foo', 'bar'])\n        self.assertEqual(url_path.with_end_tag, True)\n\n    def test_parse_2(self):\n        url_path = UrlPath()\n        url_path.parse('aaa/bbb', 'utf-8')\n        self.assertEqual(url_path.segments, ['aaa', 'bbb'])\n        self.assertEqual(url_path.with_end_tag, False)\n\n    def test_parse_3(self):\n        url_path = UrlPath()\n        url_path.parse('/123/456/', 'utf-8')\n        self.assertEqual(url_path.segments, ['123', '456'])\n        self.assertEqual(url_path.with_end_tag, True)\n\n    def test_parse_4(self):\n        url_path = UrlPath()\n        url_path.parse('/123/456/789', 'utf-8')\n        self.assertEqual(url_path.segments, ['123', '456', '789'])\n        self.assertEqual(url_path.with_end_tag, False)\n\n    def test_parse_5(self):\n        url_path = UrlPath()\n        url_path.parse('/foo/bar', 'utf-8')\n        self.assertEqual(url_path.segments, ['foo', 'bar'])\n        self.assertEqual(url_path.with_end_tag, False)\n\n    def test_parse_6(self):\n        url_path = UrlPath()\n        url_path.parse('', 'utf-8')\n        self.assertEqual(url_path.segments, [])\n        self.assertEqual(url_path.with_end_tag, False)\n\n    def test_parse_7(self):\n        url_path = UrlPath()\n        url_path.parse('//', 'utf-8')\n        self.assertEqual(url_path.segments, [])\n        self.assertEqual(url_path.with_end_tag, True)\n\n\nclass UrlPathTestFixPath(unittest.TestCase):\n    def test_fix_path_1(self):\n        fixed_path = UrlPath.fix_path('/foo/bar/')\n        self.assertEqual(fixed_path, 'foo/bar')\n\n    def test_fix_path_2(self):\n        fixed_path = UrlPath.fix_path('/aaa/bbb/')\n        self.assertEqual(fixed_path, 'aaa/bbb')\n\n    def test_fix_path_3(self):\n        fixed_path = UrlPath.fix_path('/a/b/')\n        self.assertEqual(fixed_path, 'a/b')\n\n    def test_fix_path_4(self):\n        fixed_path = UrlPath.fix_path('/111/222/')\n        self.assertEqual(fixed_path, '111/222')\n\n    def test_fix_path_5(self):\n        fixed_path = UrlPath.fix_path('/a/')\n        self.assertEqual(fixed_path, 'a')\n\n    def test_fix_path_6(self):\n        fixed_path = UrlPath.fix_path('')\n        self.assertEqual(fixed_path, '')\n\n\nclass UrlPathTest(unittest.TestCase):\n    def test_urlpath(self):\n        url_path = UrlPath()\n        url_path.add('foo')\n        url_path.add('bar')\n        self.assertEqual(url_path.segments, ['foo', 'bar'])\n\n        url_path = UrlPath()\n        url_path.parse('/foo/bar/', 'utf-8')\n        self.assertEqual(url_path.segments, ['foo', 'bar'])\n        self.assertEqual(url_path.with_end_tag, True)\n\n        fixed_path = UrlPath.fix_path('/foo/bar/')\n        self.assertEqual(fixed_path, 'foo/bar')",
        "solution_code": "import urllib.parse\n\n\nclass UrlPath:\n    def __init__(self):\n        self.segments = []\n        self.with_end_tag = False\n\n    def add(self, segment):\n        self.segments.append(self.fix_path(segment))\n\n    def parse(self, path, charset):\n        if path:\n            if path.endswith('/'):\n                self.with_end_tag = True\n\n            path = self.fix_path(path)\n            if path:\n                split = path.split('/')\n                for seg in split:\n                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)\n                    self.segments.append(decoded_seg)\n\n    @staticmethod\n    def fix_path(path):\n        if not path:\n            return ''\n\n        segment_str = path.strip('/')\n        return segment_str",
        "import_statement": [
            "import urllib.parse"
        ],
        "class_description": "    \"\"\"\n    The  class is a utility for encapsulating and manipulating the path component of a URL, including adding nodes, parsing path strings, and building path strings with optional encoding.\n    \"\"\"\n",
        "class_name": "UrlPath",
        "test_classes": [
            "UrlPathTestAdd",
            "UrlPathTestParse",
            "UrlPathTestFixPath",
            "UrlPathTest"
        ],
        "class_constructor": "class UrlPath: \n    def __init__(self):\n        \"\"\"\n        Initializes the UrlPath object with an empty list of segments and a flag indicating the presence of an end tag.\n        \"\"\"\n        self.segments = []\n        self.with_end_tag = False\n\n",
        "fields": [
            "self.segments",
            "self.with_end_tag"
        ],
        "methods_info": [
            {
                "method_name": "add",
                "method_description": "def add(self, segment):\n        \"\"\"\n        Adds a segment to the list of segments in the UrlPath.\n        :param segment: str, the segment to add.\n        >>> url_path = UrlPath()\n        >>> url_path.add('foo')\n        >>> url_path.add('bar')\n\n        url_path.segments = ['foo', 'bar']\n        \"\"\"",
                "test_class": "UrlPathTestAdd",
                "test_code": "class UrlPathTestAdd(unittest.TestCase):\n    def test_add_1(self):\n        url_path = UrlPath()\n        url_path.add('foo')\n        url_path.add('bar')\n        self.assertEqual(url_path.segments, ['foo', 'bar'])\n\n    def test_add_2(self):\n        url_path = UrlPath()\n        url_path.add('aaa')\n        url_path.add('bbb')\n        self.assertEqual(url_path.segments, ['aaa', 'bbb'])\n\n    def test_add_3(self):\n        url_path = UrlPath()\n        url_path.add('123')\n        self.assertEqual(url_path.segments, ['123'])\n\n    def test_add_4(self):\n        url_path = UrlPath()\n        url_path.add('ddd')\n        self.assertEqual(url_path.segments, ['ddd'])\n\n    def test_add_5(self):\n        url_path = UrlPath()\n        url_path.add('eee')\n        self.assertEqual(url_path.segments, ['eee'])",
                "solution_code": "def add(self, segment):\n        self.segments.append(self.fix_path(segment))",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [],
                    "field_dependencies": [
                        "self.segments"
                    ],
                    "method_dependencies": [
                        "fix_path"
                    ]
                }
            },
            {
                "method_name": "parse",
                "method_description": "def parse(self, path, charset):\n        \"\"\"\n        Parses a given path string and populates the list of segments in the UrlPath.\n        :param path: str, the path string to parse.\n        :param charset: str, the character encoding of the path string.\n        >>> url_path = UrlPath()\n        >>> url_path.parse('/foo/bar/', 'utf-8')\n\n        url_path.segments = ['foo', 'bar']\n        \"\"\"",
                "test_class": "UrlPathTestParse",
                "test_code": "class UrlPathTestParse(unittest.TestCase):\n    def test_parse_1(self):\n        url_path = UrlPath()\n        url_path.parse('/foo/bar/', 'utf-8')\n        self.assertEqual(url_path.segments, ['foo', 'bar'])\n        self.assertEqual(url_path.with_end_tag, True)\n\n    def test_parse_2(self):\n        url_path = UrlPath()\n        url_path.parse('aaa/bbb', 'utf-8')\n        self.assertEqual(url_path.segments, ['aaa', 'bbb'])\n        self.assertEqual(url_path.with_end_tag, False)\n\n    def test_parse_3(self):\n        url_path = UrlPath()\n        url_path.parse('/123/456/', 'utf-8')\n        self.assertEqual(url_path.segments, ['123', '456'])\n        self.assertEqual(url_path.with_end_tag, True)\n\n    def test_parse_4(self):\n        url_path = UrlPath()\n        url_path.parse('/123/456/789', 'utf-8')\n        self.assertEqual(url_path.segments, ['123', '456', '789'])\n        self.assertEqual(url_path.with_end_tag, False)\n\n    def test_parse_5(self):\n        url_path = UrlPath()\n        url_path.parse('/foo/bar', 'utf-8')\n        self.assertEqual(url_path.segments, ['foo', 'bar'])\n        self.assertEqual(url_path.with_end_tag, False)\n\n    def test_parse_6(self):\n        url_path = UrlPath()\n        url_path.parse('', 'utf-8')\n        self.assertEqual(url_path.segments, [])\n        self.assertEqual(url_path.with_end_tag, False)\n\n    def test_parse_7(self):\n        url_path = UrlPath()\n        url_path.parse('//', 'utf-8')\n        self.assertEqual(url_path.segments, [])\n        self.assertEqual(url_path.with_end_tag, True)",
                "solution_code": "def parse(self, path, charset):\n        if path:\n            if path.endswith('/'):\n                self.with_end_tag = True\n\n            path = self.fix_path(path)\n            if path:\n                split = path.split('/')\n                for seg in split:\n                    decoded_seg = urllib.parse.unquote(seg, encoding=charset)\n                    self.segments.append(decoded_seg)",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "urllib.parse"
                    ],
                    "field_dependencies": [
                        "self.segments",
                        "self.with_end_tag"
                    ],
                    "method_dependencies": [
                        "fix_path"
                    ]
                }
            },
            {
                "method_name": "fix_path",
                "method_description": "@staticmethod\n    def fix_path(path):\n        \"\"\"\n        Fixes the given path string by removing leading and trailing slashes.\n        :param path: str, the path string to fix.\n        :return: str, the fixed path string.\n        >>> url_path = UrlPath()\n        >>> url_path.fix_path('/foo/bar/')\n        'foo/bar'\n\n        \"\"\"",
                "test_class": "UrlPathTestFixPath",
                "test_code": "class UrlPathTestFixPath(unittest.TestCase):\n    def test_fix_path_1(self):\n        fixed_path = UrlPath.fix_path('/foo/bar/')\n        self.assertEqual(fixed_path, 'foo/bar')\n\n    def test_fix_path_2(self):\n        fixed_path = UrlPath.fix_path('/aaa/bbb/')\n        self.assertEqual(fixed_path, 'aaa/bbb')\n\n    def test_fix_path_3(self):\n        fixed_path = UrlPath.fix_path('/a/b/')\n        self.assertEqual(fixed_path, 'a/b')\n\n    def test_fix_path_4(self):\n        fixed_path = UrlPath.fix_path('/111/222/')\n        self.assertEqual(fixed_path, '111/222')\n\n    def test_fix_path_5(self):\n        fixed_path = UrlPath.fix_path('/a/')\n        self.assertEqual(fixed_path, 'a')\n\n    def test_fix_path_6(self):\n        fixed_path = UrlPath.fix_path('')\n        self.assertEqual(fixed_path, '')",
                "solution_code": "@staticmethod\n    def fix_path(path):\n        if not path:\n            return ''\n\n        segment_str = path.strip('/')\n        return segment_str",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_93",
        "skeleton": "import numpy as np\nfrom gensim import matutils\nfrom numpy import dot, array\n\nclass VectorUtil:\n    \"\"\"\n    The class provides vector operations, including calculating similarity, cosine similarities, average similarity, and IDF weights.\n    \"\"\"\n\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        \"\"\"\n        Compute the cosine similarity between one vector and another vector.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vector_2: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :return: numpy.ndarray, Contains cosine distance between `vector_1` and `vector_2`\n        >>> vector_1 = np.array([1, 1])\n        >>> vector_2 = np.array([1, 0])\n        >>> VectorUtil.similarity(vector_1, vector_2)\n        0.7071067811865475\n        \"\"\"\n\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        \"\"\"\n        Compute cosine similarities between one vector and a set of other vectors.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vectors_all: list of numpy.ndarray, For each row in vectors_all, distance from vector_1 is computed, expected shape (num_vectors, dim).\n        :return: numpy.ndarray, Contains cosine distance between `vector_1` and each row in `vectors_all`, shape (num_vectors,).\n        >>> vector1 = np.array([1, 2, 3])\n        >>> vectors_all = [np.array([4, 5, 6]), np.array([7, 8, 9])]\n        >>> VectorUtil.cosine_similarities(vector1, vectors_all)\n        [0.97463185 0.95941195]\n        \"\"\"\n\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        \"\"\"\n        Compute cosine similarity between two sets of vectors.\n        :param vector_list_1: list of numpy vector\n        :param vector_list_2: list of numpy vector\n        :return: numpy.ndarray, Similarities between vector_list_1 and vector_list_2.\n        >>> vector_list1 = [np.array([1, 2, 3]), np.array([4, 5, 6])]\n        >>> vector_list2 = [np.array([7, 8, 9]), np.array([10, 11, 12])]\n        >>> VectorUtil.n_similarity(vector_list1, vector_list2)\n        0.9897287473881233\n        \"\"\"\n\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        \"\"\"\n        Calculate log(total_num+1/count+1) for each count in number_dict\n        :param total_num: int\n        :param number_dict: dict\n        :return: dict\n        >>> num_dict = {'key1':0.1, 'key2':0.5}\n        >>> VectorUtil.compute_idf_weight_dict(2, num_dict)\n        {'key1': 1.0033021088637848, 'key2': 0.6931471805599453}\n        \"\"\"",
        "test": "import unittest\n\n\nclass VectorUtilTestSimilarity(unittest.TestCase):\n    def test_similarity_1(self):\n        vector_1 = np.array([1, 1])\n        vector_2 = np.array([1, 0])\n        similarity = VectorUtil.similarity(vector_1, vector_2)\n        self.assertAlmostEqual(similarity, 0.7071067811865475)\n\n    def test_similarity_2(self):\n        vector_1 = np.array([1, 1])\n        vector_2 = np.array([0, 0])\n        similarity = VectorUtil.similarity(vector_1, vector_2)\n        self.assertAlmostEqual(similarity, 0.0)\n\n    def test_similarity_3(self):\n        vector_1 = np.array([1, 1])\n        vector_2 = np.array([1, 1])\n        similarity = VectorUtil.similarity(vector_1, vector_2)\n        self.assertAlmostEqual(similarity, 1.0)\n\n    def test_similarity_4(self):\n        vector_1 = np.array([1, 1, 0, 1, 0, 1, 0, 1])\n        vector_2 = np.array([1, 0, 0, 1, 0, 1, 0, 1])\n        similarity = VectorUtil.similarity(vector_1, vector_2)\n        self.assertAlmostEqual(similarity, 0.8944271909999159)\n\n    def test_similarity_5(self):\n        vector_1 = np.array([1, 1, 1, 1, 1, 1, 1, 1])\n        vector_2 = np.array([0, 0, 0, 0, 0, 0, 0, 0])\n        similarity = VectorUtil.similarity(vector_1, vector_2)\n        self.assertAlmostEqual(similarity, 0.0)\n\n\nclass VectorUtilTestCosineSimilarities(unittest.TestCase):\n    def test_cosine_similarities_1(self):\n        vector1 = np.array([1, 1])\n        vectors_all = [np.array([1, 0]), np.array([1, 1])]\n        similarities = VectorUtil.cosine_similarities(vector1, vectors_all)\n        res = [0.7071067811865475, 1.0]\n        for index, item in enumerate(similarities):\n            self.assertAlmostEqual(item, res[index])\n\n    def test_cosine_similarities_2(self):\n        vector1 = np.array([1, 1, 0, 0, 1, 0, 1, 0])\n        vectors_all = [np.array([1, 0, 0, 0, 1, 0, 1, 0]), np.array([1, 1, 0, 1, 1, 1, 1, 0])]\n        similarities = VectorUtil.cosine_similarities(vector1, vectors_all)\n        res = [0.8660254037844387, 0.8164965809277261]\n        for index, item in enumerate(similarities):\n            self.assertAlmostEqual(item, res[index])\n\n    def test_cosine_similarities_3(self):\n        vector1 = np.array([1, 1, 0, 0, 1, 0, 1, 0])\n        vectors_all = [np.array([1, 0, 0, 0, 1, 0, 1, 0]), np.array([1, 1, 1, 1, 1, 1, 1, 0])]\n        similarities = VectorUtil.cosine_similarities(vector1, vectors_all)\n        res = [0.8660254037844387, 0.7559289460184544]\n        for index, item in enumerate(similarities):\n            self.assertAlmostEqual(item, res[index])\n\n    def test_cosine_similarities_4(self):\n        vector1 = np.array([1, 1, 0, 0, 1, 0, 1, 0])\n        vectors_all = [np.array([1, 0, 0, 0, 1, 0, 1, 0]), np.array([1, 1, 1, 1, 1, 1, 1, 1])]\n        similarities = VectorUtil.cosine_similarities(vector1, vectors_all)\n        res = [0.8660254037844387, 0.7071067811865475]\n        for index, item in enumerate(similarities):\n            self.assertAlmostEqual(item, res[index])\n\n    def test_cosine_similarities_5(self):\n        vector1 = np.array([1, 1, 0, 0, 1, 0, 1, 0])\n        vectors_all = [np.array([1, 0, 0, 0, 1, 0, 1, 0]), np.array([0, 1, 1, 1, 1, 1, 1, 1])]\n        similarities = VectorUtil.cosine_similarities(vector1, vectors_all)\n        res = [0.8660254037844387, 0.5669467095138409]\n        for index, item in enumerate(similarities):\n            self.assertAlmostEqual(item, res[index])\n\n\nclass VectorUtilTestNSimilarity(unittest.TestCase):\n    def test_n_similarity_1(self):\n        vector_list1 = [np.array([1, 0]), np.array([0, 1])]\n        vector_list2 = [np.array([0, 0]), np.array([1, 1])]\n        similarity = VectorUtil.n_similarity(vector_list1, vector_list2)\n        self.assertAlmostEqual(similarity, 1.0)\n\n    def test_n_similarity_2(self):\n        vector_list1 = [np.array([1, 1]), np.array([0, 1])]\n        vector_list2 = [np.array([0, 0]), np.array([1, 1])]\n        similarity = VectorUtil.n_similarity(vector_list1, vector_list2)\n        self.assertAlmostEqual(similarity, 0.9486832980505137)\n\n    def test_n_similarity_3(self):\n        vector_list1 = [np.array([1, 0]), np.array([1, 1])]\n        vector_list2 = [np.array([0, 0]), np.array([1, 1])]\n        similarity = VectorUtil.n_similarity(vector_list1, vector_list2)\n        self.assertAlmostEqual(similarity, 0.9486832980505137)\n\n    def test_n_similarity_4(self):\n        vector_list1 = [np.array([1, 0]), np.array([0, 1])]\n        vector_list2 = [np.array([1, 0]), np.array([1, 1])]\n        similarity = VectorUtil.n_similarity(vector_list1, vector_list2)\n        self.assertAlmostEqual(similarity, 0.9486832980505137)\n\n    def test_n_similarity_5(self):\n        vector_list1 = [np.array([1, 0]), np.array([0, 1])]\n        vector_list2 = [np.array([0, 1]), np.array([1, 1])]\n        similarity = VectorUtil.n_similarity(vector_list1, vector_list2)\n        self.assertAlmostEqual(similarity, 0.9486832980505137)\n\n    def test_n_similarity_6(self):\n        try:\n            vector_list1 = []\n            vector_list2 = []\n            similarity = VectorUtil.n_similarity(vector_list1, vector_list2)\n        except:\n            pass\n\n\nclass VectorUtilTestComputeIdfWeightDict(unittest.TestCase):\n    def test_compute_idf_weight_dict_1(self):\n        num_dict = {'key1': 0.1, 'key2': 0.5}\n        res = VectorUtil.compute_idf_weight_dict(2, num_dict)\n        self.assertAlmostEqual(res['key1'], 1.0033021088637848)\n        self.assertAlmostEqual(res['key2'], 0.6931471805599453)\n\n    def test_compute_idf_weight_dict_2(self):\n        num_dict = {'key1': 0.2, 'key2': 0.5}\n        res = VectorUtil.compute_idf_weight_dict(2, num_dict)\n        self.assertAlmostEqual(res['key1'], 0.9162907318741551)\n        self.assertAlmostEqual(res['key2'], 0.6931471805599453)\n\n    def test_compute_idf_weight_dict_3(self):\n        num_dict = {'key1': 0.3, 'key2': 0.5}\n        res = VectorUtil.compute_idf_weight_dict(2, num_dict)\n        self.assertAlmostEqual(res['key1'], 0.8362480242006185)\n        self.assertAlmostEqual(res['key2'], 0.6931471805599453)\n\n    def test_compute_idf_weight_dict_4(self):\n        num_dict = {'key1': 0.4, 'key2': 0.5}\n        res = VectorUtil.compute_idf_weight_dict(2, num_dict)\n        self.assertAlmostEqual(res['key1'], 0.7621400520468967)\n        self.assertAlmostEqual(res['key2'], 0.6931471805599453)\n\n    def test_compute_idf_weight_dict_5(self):\n        num_dict = {'key1': 0.5, 'key2': 0.5}\n        res = VectorUtil.compute_idf_weight_dict(2, num_dict)\n        self.assertAlmostEqual(res['key1'], 0.6931471805599453)\n        self.assertAlmostEqual(res['key2'], 0.6931471805599453)\n\n\nclass VectorUtilTest(unittest.TestCase):\n    def test_vectorutil(self):\n        vector_1 = np.array([1, 1])\n        vector_2 = np.array([1, 0])\n        similarity = VectorUtil.similarity(vector_1, vector_2)\n        self.assertAlmostEqual(similarity, 0.7071067811865475)\n\n        vector1 = np.array([1, 1])\n        vectors_all = [np.array([1, 0]), np.array([1, 1])]\n        similarities = VectorUtil.cosine_similarities(vector1, vectors_all)\n        res = [0.7071067811865475, 1.0]\n        for index, item in enumerate(similarities):\n            self.assertAlmostEqual(item, res[index])\n\n        vector_list1 = [np.array([1, 0]), np.array([0, 1])]\n        vector_list2 = [np.array([0, 0]), np.array([1, 1])]\n        similarity = VectorUtil.n_similarity(vector_list1, vector_list2)\n        self.assertAlmostEqual(similarity, 1.0)\n\n        num_dict = {'key1': 0.1, 'key2': 0.5}\n        res = VectorUtil.compute_idf_weight_dict(2, num_dict)\n        self.assertAlmostEqual(res['key1'], 1.0033021088637848)\n        self.assertAlmostEqual(res['key2'], 0.6931471805599453)",
        "solution_code": "import numpy as np\nfrom gensim import matutils\nfrom numpy import dot, array\n\n\nclass VectorUtil:\n    @staticmethod\n    def similarity(vector_1, vector_2):\n        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))\n\n    @staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        norm = np.linalg.norm(vector_1)\n        all_norms = np.linalg.norm(vectors_all, axis=1)\n        dot_products = dot(vectors_all, vector_1)\n        similarities = dot_products / (norm * all_norms)\n        return similarities\n\n    @staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        if not (len(vector_list_1) and len(vector_list_2)):\n            raise ZeroDivisionError('At least one of the passed list is empty.')\n\n        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),\n                   matutils.unitvec(array(vector_list_2).mean(axis=0)))\n\n    @staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        index_2_key_map = {}\n\n        index = 0\n\n        count_list = []\n        for key, count in number_dict.items():\n            index_2_key_map[index] = key\n            count_list.append(count)\n            index = index + 1\n\n        a = np.array(count_list)\n        ## smooth, in case the divide by zero error\n        a = np.log((total_num + 1) / (a + 1))\n        result = {}\n\n        for index, w in enumerate(a):\n            key = index_2_key_map[index]\n            result[key] = w\n\n        return result",
        "import_statement": [
            "import numpy as np",
            "from gensim import matutils",
            "from numpy import dot, array"
        ],
        "class_description": "    \"\"\"\n    The class provides vector operations, including calculating similarity, cosine similarities, average similarity, and IDF weights.\n    \"\"\"\n",
        "class_name": "VectorUtil",
        "test_classes": [
            "VectorUtilTestSimilarity",
            "VectorUtilTestCosineSimilarities",
            "VectorUtilTestNSimilarity",
            "VectorUtilTestComputeIdfWeightDict",
            "VectorUtilTest"
        ],
        "class_constructor": "class VectorUtil: \n",
        "fields": [],
        "methods_info": [
            {
                "method_name": "similarity",
                "method_description": "def similarity(vector_1, vector_2):\n        \"\"\"\n        Compute the cosine similarity between one vector and another vector.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vector_2: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :return: numpy.ndarray, Contains cosine distance between `vector_1` and `vector_2`\n        >>> vector_1 = np.array([1, 1])\n        >>> vector_2 = np.array([1, 0])\n        >>> VectorUtil.similarity(vector_1, vector_2)\n        0.7071067811865475\n        \"\"\"",
                "test_class": "VectorUtilTestSimilarity",
                "test_code": "class VectorUtilTestSimilarity(unittest.TestCase):\n    def test_similarity_1(self):\n        vector_1 = np.array([1, 1])\n        vector_2 = np.array([1, 0])\n        similarity = VectorUtil.similarity(vector_1, vector_2)\n        self.assertAlmostEqual(similarity, 0.7071067811865475)\n\n    def test_similarity_2(self):\n        vector_1 = np.array([1, 1])\n        vector_2 = np.array([0, 0])\n        similarity = VectorUtil.similarity(vector_1, vector_2)\n        self.assertAlmostEqual(similarity, 0.0)\n\n    def test_similarity_3(self):\n        vector_1 = np.array([1, 1])\n        vector_2 = np.array([1, 1])\n        similarity = VectorUtil.similarity(vector_1, vector_2)\n        self.assertAlmostEqual(similarity, 1.0)\n\n    def test_similarity_4(self):\n        vector_1 = np.array([1, 1, 0, 1, 0, 1, 0, 1])\n        vector_2 = np.array([1, 0, 0, 1, 0, 1, 0, 1])\n        similarity = VectorUtil.similarity(vector_1, vector_2)\n        self.assertAlmostEqual(similarity, 0.8944271909999159)\n\n    def test_similarity_5(self):\n        vector_1 = np.array([1, 1, 1, 1, 1, 1, 1, 1])\n        vector_2 = np.array([0, 0, 0, 0, 0, 0, 0, 0])\n        similarity = VectorUtil.similarity(vector_1, vector_2)\n        self.assertAlmostEqual(similarity, 0.0)",
                "solution_code": "def similarity(vector_1, vector_2):\n        return dot(matutils.unitvec(vector_1), matutils.unitvec(vector_2))",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "matutils"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "cosine_similarities",
                "method_description": "@staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        \"\"\"\n        Compute cosine similarities between one vector and a set of other vectors.\n        :param vector_1: numpy.ndarray, Vector from which similarities are to be computed, expected shape (dim,).\n        :param vectors_all: list of numpy.ndarray, For each row in vectors_all, distance from vector_1 is computed, expected shape (num_vectors, dim).\n        :return: numpy.ndarray, Contains cosine distance between `vector_1` and each row in `vectors_all`, shape (num_vectors,).\n        >>> vector1 = np.array([1, 2, 3])\n        >>> vectors_all = [np.array([4, 5, 6]), np.array([7, 8, 9])]\n        >>> VectorUtil.cosine_similarities(vector1, vectors_all)\n        [0.97463185 0.95941195]\n        \"\"\"",
                "test_class": "VectorUtilTestCosineSimilarities",
                "test_code": "class VectorUtilTestCosineSimilarities(unittest.TestCase):\n    def test_cosine_similarities_1(self):\n        vector1 = np.array([1, 1])\n        vectors_all = [np.array([1, 0]), np.array([1, 1])]\n        similarities = VectorUtil.cosine_similarities(vector1, vectors_all)\n        res = [0.7071067811865475, 1.0]\n        for index, item in enumerate(similarities):\n            self.assertAlmostEqual(item, res[index])\n\n    def test_cosine_similarities_2(self):\n        vector1 = np.array([1, 1, 0, 0, 1, 0, 1, 0])\n        vectors_all = [np.array([1, 0, 0, 0, 1, 0, 1, 0]), np.array([1, 1, 0, 1, 1, 1, 1, 0])]\n        similarities = VectorUtil.cosine_similarities(vector1, vectors_all)\n        res = [0.8660254037844387, 0.8164965809277261]\n        for index, item in enumerate(similarities):\n            self.assertAlmostEqual(item, res[index])\n\n    def test_cosine_similarities_3(self):\n        vector1 = np.array([1, 1, 0, 0, 1, 0, 1, 0])\n        vectors_all = [np.array([1, 0, 0, 0, 1, 0, 1, 0]), np.array([1, 1, 1, 1, 1, 1, 1, 0])]\n        similarities = VectorUtil.cosine_similarities(vector1, vectors_all)\n        res = [0.8660254037844387, 0.7559289460184544]\n        for index, item in enumerate(similarities):\n            self.assertAlmostEqual(item, res[index])\n\n    def test_cosine_similarities_4(self):\n        vector1 = np.array([1, 1, 0, 0, 1, 0, 1, 0])\n        vectors_all = [np.array([1, 0, 0, 0, 1, 0, 1, 0]), np.array([1, 1, 1, 1, 1, 1, 1, 1])]\n        similarities = VectorUtil.cosine_similarities(vector1, vectors_all)\n        res = [0.8660254037844387, 0.7071067811865475]\n        for index, item in enumerate(similarities):\n            self.assertAlmostEqual(item, res[index])\n\n    def test_cosine_similarities_5(self):\n        vector1 = np.array([1, 1, 0, 0, 1, 0, 1, 0])\n        vectors_all = [np.array([1, 0, 0, 0, 1, 0, 1, 0]), np.array([0, 1, 1, 1, 1, 1, 1, 1])]\n        similarities = VectorUtil.cosine_similarities(vector1, vectors_all)\n        res = [0.8660254037844387, 0.5669467095138409]\n        for index, item in enumerate(similarities):\n            self.assertAlmostEqual(item, res[index])",
                "solution_code": "@staticmethod\n    def cosine_similarities(vector_1, vectors_all):\n        norm = np.linalg.norm(vector_1)\n        all_norms = np.linalg.norm(vectors_all, axis=1)\n        dot_products = dot(vectors_all, vector_1)\n        similarities = dot_products / (norm * all_norms)\n        return similarities",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "n_similarity",
                "method_description": "@staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        \"\"\"\n        Compute cosine similarity between two sets of vectors.\n        :param vector_list_1: list of numpy vector\n        :param vector_list_2: list of numpy vector\n        :return: numpy.ndarray, Similarities between vector_list_1 and vector_list_2.\n        >>> vector_list1 = [np.array([1, 2, 3]), np.array([4, 5, 6])]\n        >>> vector_list2 = [np.array([7, 8, 9]), np.array([10, 11, 12])]\n        >>> VectorUtil.n_similarity(vector_list1, vector_list2)\n        0.9897287473881233\n        \"\"\"",
                "test_class": "VectorUtilTestNSimilarity",
                "test_code": "class VectorUtilTestNSimilarity(unittest.TestCase):\n    def test_n_similarity_1(self):\n        vector_list1 = [np.array([1, 0]), np.array([0, 1])]\n        vector_list2 = [np.array([0, 0]), np.array([1, 1])]\n        similarity = VectorUtil.n_similarity(vector_list1, vector_list2)\n        self.assertAlmostEqual(similarity, 1.0)\n\n    def test_n_similarity_2(self):\n        vector_list1 = [np.array([1, 1]), np.array([0, 1])]\n        vector_list2 = [np.array([0, 0]), np.array([1, 1])]\n        similarity = VectorUtil.n_similarity(vector_list1, vector_list2)\n        self.assertAlmostEqual(similarity, 0.9486832980505137)\n\n    def test_n_similarity_3(self):\n        vector_list1 = [np.array([1, 0]), np.array([1, 1])]\n        vector_list2 = [np.array([0, 0]), np.array([1, 1])]\n        similarity = VectorUtil.n_similarity(vector_list1, vector_list2)\n        self.assertAlmostEqual(similarity, 0.9486832980505137)\n\n    def test_n_similarity_4(self):\n        vector_list1 = [np.array([1, 0]), np.array([0, 1])]\n        vector_list2 = [np.array([1, 0]), np.array([1, 1])]\n        similarity = VectorUtil.n_similarity(vector_list1, vector_list2)\n        self.assertAlmostEqual(similarity, 0.9486832980505137)\n\n    def test_n_similarity_5(self):\n        vector_list1 = [np.array([1, 0]), np.array([0, 1])]\n        vector_list2 = [np.array([0, 1]), np.array([1, 1])]\n        similarity = VectorUtil.n_similarity(vector_list1, vector_list2)\n        self.assertAlmostEqual(similarity, 0.9486832980505137)\n\n    def test_n_similarity_6(self):\n        try:\n            vector_list1 = []\n            vector_list2 = []\n            similarity = VectorUtil.n_similarity(vector_list1, vector_list2)\n        except:\n            pass",
                "solution_code": "@staticmethod\n    def n_similarity(vector_list_1, vector_list_2):\n        if not (len(vector_list_1) and len(vector_list_2)):\n            raise ZeroDivisionError('At least one of the passed list is empty.')\n\n        return dot(matutils.unitvec(array(vector_list_1).mean(axis=0)),\n                   matutils.unitvec(array(vector_list_2).mean(axis=0)))",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "matutils"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "compute_idf_weight_dict",
                "method_description": "@staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        \"\"\"\n        Calculate log(total_num+1/count+1) for each count in number_dict\n        :param total_num: int\n        :param number_dict: dict\n        :return: dict\n        >>> num_dict = {'key1':0.1, 'key2':0.5}\n        >>> VectorUtil.compute_idf_weight_dict(2, num_dict)\n        {'key1': 1.0033021088637848, 'key2': 0.6931471805599453}\n        \"\"\"",
                "test_class": "VectorUtilTestComputeIdfWeightDict",
                "test_code": "class VectorUtilTestComputeIdfWeightDict(unittest.TestCase):\n    def test_compute_idf_weight_dict_1(self):\n        num_dict = {'key1': 0.1, 'key2': 0.5}\n        res = VectorUtil.compute_idf_weight_dict(2, num_dict)\n        self.assertAlmostEqual(res['key1'], 1.0033021088637848)\n        self.assertAlmostEqual(res['key2'], 0.6931471805599453)\n\n    def test_compute_idf_weight_dict_2(self):\n        num_dict = {'key1': 0.2, 'key2': 0.5}\n        res = VectorUtil.compute_idf_weight_dict(2, num_dict)\n        self.assertAlmostEqual(res['key1'], 0.9162907318741551)\n        self.assertAlmostEqual(res['key2'], 0.6931471805599453)\n\n    def test_compute_idf_weight_dict_3(self):\n        num_dict = {'key1': 0.3, 'key2': 0.5}\n        res = VectorUtil.compute_idf_weight_dict(2, num_dict)\n        self.assertAlmostEqual(res['key1'], 0.8362480242006185)\n        self.assertAlmostEqual(res['key2'], 0.6931471805599453)\n\n    def test_compute_idf_weight_dict_4(self):\n        num_dict = {'key1': 0.4, 'key2': 0.5}\n        res = VectorUtil.compute_idf_weight_dict(2, num_dict)\n        self.assertAlmostEqual(res['key1'], 0.7621400520468967)\n        self.assertAlmostEqual(res['key2'], 0.6931471805599453)\n\n    def test_compute_idf_weight_dict_5(self):\n        num_dict = {'key1': 0.5, 'key2': 0.5}\n        res = VectorUtil.compute_idf_weight_dict(2, num_dict)\n        self.assertAlmostEqual(res['key1'], 0.6931471805599453)\n        self.assertAlmostEqual(res['key2'], 0.6931471805599453)",
                "solution_code": "@staticmethod\n    def compute_idf_weight_dict(total_num, number_dict):\n        index_2_key_map = {}\n\n        index = 0\n\n        count_list = []\n        for key, count in number_dict.items():\n            index_2_key_map[index] = key\n            count_list.append(count)\n            index = index + 1\n\n        a = np.array(count_list)\n        ## smooth, in case the divide by zero error\n        a = np.log((total_num + 1) / (a + 1))\n        result = {}\n\n        for index, w in enumerate(a):\n            key = index_2_key_map[index]\n            result[key] = w\n\n        return result",
                "dependencies": {
                    "Standalone": true,
                    "lib_dependencies": [],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    },
    {
        "task_id": "ClassEval_99",
        "skeleton": "import zipfile\n\n\nclass ZipFileProcessor:\n    \"\"\"\n    This is a compressed file processing class that provides the ability to read and decompress compressed files\n    \"\"\"\n\n    def __init__(self, file_name):\n        \"\"\"\n        Initialize file name\n        :param file_name:string\n        \"\"\"\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        \"\"\"\n        Get open file object\n        :return:If successful, returns the open file object; otherwise, returns None\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> file = zfp.read_zip_file()\n        \"\"\"\n\n    def extract_all(self, output_path):\n        \"\"\"\n        Extract all zip files and place them in the specified path\n        :param output_path: string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_all(\"result/aaa\")\n        \"\"\"\n\n    def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extract the file with the specified name from the zip file and place it in the specified path\n        :param file_name:string, The name of the file to be uncompressed\n        :param output_path:string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_file(\"bbb.txt\", \"result/aaa\")\n        \"\"\"\n\n    def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Compress the specified file list into a zip file and place it in the specified path\n        :param files:list of string, List of files to compress\n        :param output_file_name: string, Specified output path\n        :return:True or False, representing whether the compression operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.create_zip_file([\"bbb.txt\", \"ccc,txt\", \"ddd.txt\"], \"output/bcd\")\n        \"\"\"",
        "test": "import unittest\nimport os\n\n\nclass ZipFileProcessorTestReadZipFile(unittest.TestCase):\n    def test_read_zip_file_1(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example1.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n\n        zip_file = processor.read_zip_file()\n        self.assertEqual(zip_file.filename, 'example1.zip')\n        self.assertEqual(zip_file.mode, 'r')\n        zip_file.close()\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_read_zip_file_2(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example2.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n\n        zip_file = processor.read_zip_file()\n        self.assertEqual(zip_file.filename, 'example2.zip')\n        self.assertEqual(zip_file.mode, 'r')\n        zip_file.close()\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_read_zip_file_3(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example3.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n\n        zip_file = processor.read_zip_file()\n        self.assertEqual(zip_file.filename, 'example3.zip')\n        self.assertEqual(zip_file.mode, 'r')\n        zip_file.close()\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_read_zip_file_4(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example4.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n\n        zip_file = processor.read_zip_file()\n        self.assertEqual(zip_file.filename, 'example4.zip')\n        self.assertEqual(zip_file.mode, 'r')\n        zip_file.close()\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_read_zip_file_5(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example5.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        zip_file = processor.read_zip_file()\n        self.assertEqual(zip_file.filename, 'example5.zip')\n        self.assertEqual(zip_file.mode, 'r')\n        zip_file.close()\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_read_zip_file_6(self):\n        processor = ZipFileProcessor(\"\")\n\n        zip_file = processor.read_zip_file()\n        self.assertIsNone(zip_file)\n\n\nclass ZipFileProcessorTestExtractAll(unittest.TestCase):\n    def test_extract_all_1(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example1.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_all(output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example1.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_all_2(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example2.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_all(output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example2.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_all_3(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example3.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_all(output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example3.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_all_4(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example4.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_all(output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example4.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_all_5(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example5.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_all(output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example5.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_all_6(self):\n        processor = ZipFileProcessor(\"\")\n\n        success = processor.extract_all(\"\")\n        self.assertFalse(success)\n\n\nclass ZipFileProcessorTestExtractFile(unittest.TestCase):\n    def test_extract_file_1(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example1.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_file('example1.txt', output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example1.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_file_2(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example2.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_file('example2.txt', output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example2.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_file_3(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example3.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_file('example3.txt', output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example3.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_file_4(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example4.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_file('example4.txt', output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example4.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_file_5(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example5.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n\n        success = processor.extract_file('example5.txt', output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example5.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_file_6(self):\n        processor = ZipFileProcessor(\"\")\n\n        success = processor.extract_file(\"\", \"\")\n        self.assertFalse(success)\n\n\nclass ZipFileProcessorTestCreateZipFile(unittest.TestCase):\n    def test_create_zip_file_1(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example1.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        files_to_zip = [example_file_path]\n        success = processor.create_zip_file(files_to_zip, new_zip_file)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(new_zip_file))\n\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_create_zip_file_2(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example2.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        files_to_zip = [example_file_path]\n        success = processor.create_zip_file(files_to_zip, new_zip_file)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(new_zip_file))\n\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_create_zip_file_3(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example3.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        files_to_zip = [example_file_path]\n        success = processor.create_zip_file(files_to_zip, new_zip_file)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(new_zip_file))\n\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_create_zip_file_4(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example4.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        files_to_zip = [example_file_path]\n        success = processor.create_zip_file(files_to_zip, new_zip_file)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(new_zip_file))\n\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_create_zip_file_5(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example5.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        new_zip_file = 'new_zip_file.zip'\n\n        files_to_zip = [example_file_path]\n        success = processor.create_zip_file(files_to_zip, new_zip_file)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(new_zip_file))\n\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_create_zip_file_6(self):\n        processor = ZipFileProcessor(\"\")\n\n        success = processor.create_zip_file(\"\", \"\")\n        self.assertFalse(success)\n\n\nclass ZipFileProcessorTest(unittest.TestCase):\n    def test_ZipFileProcessor(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example1.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        zip_file = processor.read_zip_file()\n        self.assertEqual(zip_file.filename, 'example.zip')\n        self.assertEqual(zip_file.mode, 'r')\n        zip_file.close()\n\n        success = processor.extract_all(output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example1.txt')))\n\n        files_to_zip = [example_file_path]\n        success = processor.create_zip_file(files_to_zip, new_zip_file)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(new_zip_file))\n\n        success = processor.extract_file('example1.txt', output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example1.txt')))\n\n        files_to_zip = [example_file_path]\n        success = processor.create_zip_file(files_to_zip, new_zip_file)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(new_zip_file))\n\n        os.remove(example_file_path)\n        os.rmdir(test_folder)",
        "solution_code": "import zipfile\n\n\nclass ZipFileProcessor:\n    def __init__(self, file_name):\n        self.file_name = file_name\n\n    def read_zip_file(self):\n        try:\n            zip_file = zipfile.ZipFile(self.file_name, 'r')\n            return zip_file\n        except:\n            return None\n\n    def extract_all(self, output_path):\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extractall(output_path)\n            return True\n        except:\n            return False\n\n    def extract_file(self, file_name, output_path):\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extract(file_name, output_path)\n            return True\n        except:\n            return False\n\n    def create_zip_file(self, files, output_file_name):\n        try:\n            with zipfile.ZipFile(output_file_name, 'w') as zip_file:\n                for file in files:\n                    zip_file.write(file)\n            return True\n        except:\n            return False",
        "import_statement": [
            "import zipfile"
        ],
        "class_description": "    \"\"\"\n    This is a compressed file processing class that provides the ability to read and decompress compressed files\n    \"\"\"\n",
        "class_name": "ZipFileProcessor",
        "test_classes": [
            "ZipFileProcessorTestReadZipFile",
            "ZipFileProcessorTestExtractAll",
            "ZipFileProcessorTestExtractFile",
            "ZipFileProcessorTestCreateZipFile",
            "ZipFileProcessorTest"
        ],
        "class_constructor": "class ZipFileProcessor: \n    def __init__(self, file_name):\n        \"\"\"\n        Initialize file name\n        :param file_name:string\n        \"\"\"\n        self.file_name = file_name\n\n",
        "fields": [
            "self.file_name"
        ],
        "methods_info": [
            {
                "method_name": "read_zip_file",
                "method_description": "def read_zip_file(self):\n        \"\"\"\n        Get open file object\n        :return:If successful, returns the open file object; otherwise, returns None\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> file = zfp.read_zip_file()\n        \"\"\"",
                "test_class": "ZipFileProcessorTestReadZipFile",
                "test_code": "class ZipFileProcessorTestReadZipFile(unittest.TestCase):\n    def test_read_zip_file_1(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example1.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n\n        zip_file = processor.read_zip_file()\n        self.assertEqual(zip_file.filename, 'example1.zip')\n        self.assertEqual(zip_file.mode, 'r')\n        zip_file.close()\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_read_zip_file_2(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example2.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n\n        zip_file = processor.read_zip_file()\n        self.assertEqual(zip_file.filename, 'example2.zip')\n        self.assertEqual(zip_file.mode, 'r')\n        zip_file.close()\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_read_zip_file_3(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example3.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n\n        zip_file = processor.read_zip_file()\n        self.assertEqual(zip_file.filename, 'example3.zip')\n        self.assertEqual(zip_file.mode, 'r')\n        zip_file.close()\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_read_zip_file_4(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example4.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n\n        zip_file = processor.read_zip_file()\n        self.assertEqual(zip_file.filename, 'example4.zip')\n        self.assertEqual(zip_file.mode, 'r')\n        zip_file.close()\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_read_zip_file_5(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example5.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        zip_file = processor.read_zip_file()\n        self.assertEqual(zip_file.filename, 'example5.zip')\n        self.assertEqual(zip_file.mode, 'r')\n        zip_file.close()\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_read_zip_file_6(self):\n        processor = ZipFileProcessor(\"\")\n\n        zip_file = processor.read_zip_file()\n        self.assertIsNone(zip_file)",
                "solution_code": "def read_zip_file(self):\n        try:\n            zip_file = zipfile.ZipFile(self.file_name, 'r')\n            return zip_file\n        except:\n            return None",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "zipfile"
                    ],
                    "field_dependencies": [
                        "self.file_name"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "extract_all",
                "method_description": "def extract_all(self, output_path):\n        \"\"\"\n        Extract all zip files and place them in the specified path\n        :param output_path: string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_all(\"result/aaa\")\n        \"\"\"",
                "test_class": "ZipFileProcessorTestExtractAll",
                "test_code": "class ZipFileProcessorTestExtractAll(unittest.TestCase):\n    def test_extract_all_1(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example1.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_all(output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example1.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_all_2(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example2.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_all(output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example2.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_all_3(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example3.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_all(output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example3.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_all_4(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example4.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_all(output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example4.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_all_5(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example5.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_all(output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example5.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_all_6(self):\n        processor = ZipFileProcessor(\"\")\n\n        success = processor.extract_all(\"\")\n        self.assertFalse(success)",
                "solution_code": "def extract_all(self, output_path):\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extractall(output_path)\n            return True\n        except:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "zipfile"
                    ],
                    "field_dependencies": [
                        "self.file_name"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "extract_file",
                "method_description": "def extract_file(self, file_name, output_path):\n        \"\"\"\n        Extract the file with the specified name from the zip file and place it in the specified path\n        :param file_name:string, The name of the file to be uncompressed\n        :param output_path:string, The location of the extracted file\n        :return: True or False, representing whether the extraction operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.extract_file(\"bbb.txt\", \"result/aaa\")\n        \"\"\"",
                "test_class": "ZipFileProcessorTestExtractFile",
                "test_code": "class ZipFileProcessorTestExtractFile(unittest.TestCase):\n    def test_extract_file_1(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example1.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_file('example1.txt', output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example1.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_file_2(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example2.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_file('example2.txt', output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example2.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_file_3(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example3.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_file('example3.txt', output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example3.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_file_4(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example4.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        success = processor.extract_file('example4.txt', output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example4.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_file_5(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example5.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n\n        success = processor.extract_file('example5.txt', output_directory)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(os.path.join(output_directory, 'example5.txt')))\n\n        os.remove(zip_file_name)\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_extract_file_6(self):\n        processor = ZipFileProcessor(\"\")\n\n        success = processor.extract_file(\"\", \"\")\n        self.assertFalse(success)",
                "solution_code": "def extract_file(self, file_name, output_path):\n        try:\n            with zipfile.ZipFile(self.file_name, 'r') as zip_file:\n                zip_file.extract(file_name, output_path)\n            return True\n        except:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "zipfile"
                    ],
                    "field_dependencies": [
                        "self.file_name"
                    ],
                    "method_dependencies": []
                }
            },
            {
                "method_name": "create_zip_file",
                "method_description": "def create_zip_file(self, files, output_file_name):\n        \"\"\"\n        Compress the specified file list into a zip file and place it in the specified path\n        :param files:list of string, List of files to compress\n        :param output_file_name: string, Specified output path\n        :return:True or False, representing whether the compression operation was successful\n        >>> zfp = ZipFileProcessor(\"aaa.zip\")\n        >>> zfp.create_zip_file([\"bbb.txt\", \"ccc,txt\", \"ddd.txt\"], \"output/bcd\")\n        \"\"\"",
                "test_class": "ZipFileProcessorTestCreateZipFile",
                "test_code": "class ZipFileProcessorTestCreateZipFile(unittest.TestCase):\n    def test_create_zip_file_1(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example1.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        files_to_zip = [example_file_path]\n        success = processor.create_zip_file(files_to_zip, new_zip_file)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(new_zip_file))\n\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_create_zip_file_2(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example2.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        files_to_zip = [example_file_path]\n        success = processor.create_zip_file(files_to_zip, new_zip_file)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(new_zip_file))\n\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_create_zip_file_3(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example3.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        files_to_zip = [example_file_path]\n        success = processor.create_zip_file(files_to_zip, new_zip_file)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(new_zip_file))\n\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_create_zip_file_4(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example4.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        output_directory = 'output_directory'\n        new_zip_file = 'new_zip_file.zip'\n\n        files_to_zip = [example_file_path]\n        success = processor.create_zip_file(files_to_zip, new_zip_file)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(new_zip_file))\n\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_create_zip_file_5(self):\n        test_folder = 'test_folder'\n        os.makedirs(test_folder, exist_ok=True)\n        example_file_path = os.path.join(test_folder, 'example5.txt')\n        with open(example_file_path, 'w') as file:\n            file.write('This is an example file.')\n\n        zip_file_name = 'example.zip'\n        with zipfile.ZipFile(zip_file_name, 'w') as zip_file:\n            zip_file.write(example_file_path, os.path.basename(example_file_path))\n\n        processor = ZipFileProcessor(zip_file_name)\n        new_zip_file = 'new_zip_file.zip'\n\n        files_to_zip = [example_file_path]\n        success = processor.create_zip_file(files_to_zip, new_zip_file)\n        self.assertTrue(success)\n        self.assertTrue(os.path.exists(new_zip_file))\n\n        os.remove(example_file_path)\n        os.rmdir(test_folder)\n\n    def test_create_zip_file_6(self):\n        processor = ZipFileProcessor(\"\")\n\n        success = processor.create_zip_file(\"\", \"\")\n        self.assertFalse(success)",
                "solution_code": "def create_zip_file(self, files, output_file_name):\n        try:\n            with zipfile.ZipFile(output_file_name, 'w') as zip_file:\n                for file in files:\n                    zip_file.write(file)\n            return True\n        except:\n            return False",
                "dependencies": {
                    "Standalone": false,
                    "lib_dependencies": [
                        "zipfile"
                    ],
                    "field_dependencies": [],
                    "method_dependencies": []
                }
            }
        ]
    }
]